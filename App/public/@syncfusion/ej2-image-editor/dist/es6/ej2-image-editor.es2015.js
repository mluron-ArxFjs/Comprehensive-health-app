import { Browser, ChildProperty, Complex, Component, Event, EventHandler, L10n, NotifyPropertyChanges, Property, addClass, compile, detach, extend, getComponent, getUniqueID, isBlazor, isNullOrUndefined, removeClass, select } from '@syncfusion/ej2-base';
import { Dialog, createSpinner, hideSpinner, showSpinner } from '@syncfusion/ej2-popups';
import { Toolbar } from '@syncfusion/ej2-navigations';
import { DropDownButton } from '@syncfusion/ej2-splitbuttons';
import { ColorPicker, Slider, Uploader } from '@syncfusion/ej2-inputs';

class Crop {
    constructor(parent) {
        this.croppedDegree = 0; // Specifies the degree when crop is performed
        this.cropDestPoints = { startX: 0, startY: 0, width: 0, height: 0 }; // To redraw old image when navigate to crop tab
        this.tempFlipPanPoint = { x: 0, y: 0 };
        this.isPreventScaling = false;
        this.isInitCrop = false;
        this.parent = parent;
        this.addEventListener();
    }
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    }
    addEventListener() {
        this.parent.on('crop', this.cropping, this);
        this.parent.on('destroyed', this.destroy, this);
    }
    removeEventListener() {
        this.parent.off('crop', this.cropping);
        this.parent.off('destroyed', this.destroy);
    }
    cropping(args) {
        this.updateCropPvtVar();
        switch (args.prop) {
            case 'cropImg':
                this.cropImg(args.value['isRotateCrop']);
                break;
            case 'cropCircle':
                this.cropCircle(args.value['context'], args.value['isSave'], args.value['isFlip']);
                break;
            case 'setCurrSelPoints':
                this.setCurrSelPoints(args.value['isSetDimension']);
                break;
            case 'updateRotatePan':
                this.updateRotatePan();
                break;
            case 'crop':
                this.crop(args.value['obj']);
                break;
            case 'calcRatio':
                this.calcRatio(args.value['obj'], args.value['dimension']);
                break;
            case 'isObjInImage':
                this.isObjInImage(args.value['obj'], args.value['object']);
                break;
            case 'getCurrFlipState':
                this.getCurrFlipState(args.value['panObj']);
                break;
            case 'setPreviousCropCurrentObj':
                this.prevCropCurrObj = args.value['obj'];
                break;
            case 'setCropDestPoints':
                this.cropDestPoints = args.value['point'];
                break;
            case 'getTempFlipPanPoint':
                args.value['obj']['point'] = this.tempFlipPanPoint;
                break;
            case 'setTempFlipPanPoint':
                if (isNullOrUndefined(args.value['isAdd'])) {
                    this.tempFlipPanPoint = args.value['point'];
                }
                else {
                    this.tempFlipPanPoint.x += args.value['point'].x;
                    this.tempFlipPanPoint.y += args.value['point'].y;
                }
                break;
            case 'getPreventScaling':
                args.value['obj']['bool'] = this.isPreventScaling;
                break;
            case 'reset':
                this.reset();
                break;
        }
    }
    getModuleName() {
        return 'crop';
    }
    updateCropPvtVar() {
        const parent = this.parent;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
        if (parent.upperCanvas) {
            this.upperContext = parent.upperCanvas.getContext('2d');
        }
    }
    reset() {
        this.prevCropCurrObj = null;
        this.croppedDegree = 0;
        this.cropDestPoints = { startX: 0, startY: 0, width: 0, height: 0 };
        this.tempFlipPanPoint = { x: 0, y: 0 };
        this.isPreventScaling = false;
        this.isInitCrop = false;
    }
    cropImg(isRotateCrop) {
        const parent = this.parent;
        const isNullCrop = isNullOrUndefined(isRotateCrop);
        const actPoint = parent.activeObj.activePoint;
        parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
        if (isNullCrop) {
            this.croppedDegree = parent.transform.degree;
        }
        if (isNullCrop && parent.transform.degree !== 0) {
            this.updateCropObj();
            const point = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                height: parent.img.destHeight };
            parent.notify('transform', { prop: 'setCurrDestinationPoint', onPropertyChange: false, value: { point: point } });
            this.rotateCrop();
        }
        else if (isNullCrop && parent.transform.currFlipState !== '') {
            this.updateCropObj();
            const point = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                height: parent.img.destHeight };
            parent.notify('transform', { prop: 'setCurrDestinationPoint', onPropertyChange: false, value: { point: point } });
            this.flipCrop();
        }
        else {
            parent.notify('draw', { prop: 'setTempZoomFactor', onPropertyChange: false, value: { tempZoomFactor: parent.transform.zoomFactor } });
            const ratio = this.calcRatio();
            if (isNullCrop || !isRotateCrop) { // isRotateCrop is NULL or False
                this.updateCropObj();
                parent.notify('draw', { prop: 'resetPanPoints', onPropertyChange: false });
                parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
                const point = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                    height: parent.img.destHeight };
                parent.notify('transform', { prop: 'setCurrDestinationPoint', onPropertyChange: false, value: { point: point } });
                parent.currSelectionPoint = extend({}, parent.activeObj, {}, true);
                this.cropDestPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                    height: parent.img.destHeight };
            }
            const obj = { width: 0, height: 0 };
            parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
                value: { width: actPoint.width * ratio.width,
                    height: actPoint.height * ratio.height, obj: obj } });
            const maxDimension = obj;
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.img.srcLeft = (actPoint.startX * ratio.width) - (parent.img.destLeft * ratio.width);
            parent.img.srcTop = (actPoint.startY * ratio.height) - (parent.img.destTop * ratio.height);
            parent.img.srcWidth = (actPoint.width * ratio.width);
            parent.img.srcHeight = (actPoint.height * ratio.height);
            parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
            parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height) / 2;
            parent.img.destWidth = maxDimension.width;
            parent.img.destHeight = maxDimension.height;
            const temp = this.lowerContext.filter;
            parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
            this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
            this.lowerContext.filter = 'none';
            const activeObj = extend({}, parent.activeObj, {}, true);
            this.cropObjColl();
            parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
            for (let i = 0, len = parent.objColl.length; i < len; i++) {
                if (this.isObjInImage(parent.objColl[i])) {
                    parent.notify('shape', { prop: 'apply', onPropertyChange: false,
                        value: { shape: parent.objColl[i].shape, obj: parent.objColl[i], canvas: null } });
                    parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                }
            }
            parent.activeObj = activeObj;
            this.cropFreehandDrawColl();
            parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
            if (parent.currSelectionPoint.shape === 'crop-circle') {
                this.cropCircle(this.lowerContext);
            }
            else {
                parent.isCircleCrop = false;
            }
            this.lowerContext.filter = temp;
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.currObjType.isCustomCrop = false;
            parent.pan(false);
            parent.transform.defaultZoomFactor = 0;
        }
    }
    updateCropObj() {
        this.parent.afterCropActions = [];
        const object = { currObj: {} };
        this.parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const obj = object['currObj'];
        this.parent.cropObj = extend({}, obj, {}, true);
    }
    rotateCrop() {
        const parent = this.parent;
        const shape = parent.activeObj.shape || '';
        parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
        parent.currSelectionPoint = extend({}, parent.activeObj, {}, true);
        parent.objColl.push(parent.activeObj);
        parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        let activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        const tempCurrSelObj = extend({}, parent.currSelectionPoint, {}, true);
        const preventSelObj = { bool: null };
        parent.notify('transform', { prop: 'getPreventSelect', onPropertyChange: false, value: { obj: preventSelObj } });
        parent.notify('transform', { prop: 'setPreventSelect', onPropertyChange: false, value: { bool: true } });
        const coll = extend([], parent.rotateFlipColl, [], true);
        this.panToSelRangle(true);
        this.resetZoom();
        const afterCropActions = extend([], parent.afterCropActions, [], true);
        this.revertTransform('initial', coll);
        activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: activeObj } });
        parent.objColl.pop();
        parent.transform.degree = 0;
        this.cropImg(true);
        this.revertTransform('reverse', coll);
        parent.afterCropActions = afterCropActions;
        parent.currSelectionPoint = tempCurrSelObj;
        parent.notify('transform', { prop: 'setPreventSelect', onPropertyChange: false, value: { bool: preventSelObj['bool'] } });
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
        if (shape === 'crop-circle') {
            this.cropCircle(this.lowerContext);
        }
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify('draw', { prop: 'resetPanPoints', onPropertyChange: false });
    }
    revertTransform(type, coll) {
        const parent = this.parent;
        const obj = { isRotate: false };
        if (type === 'initial') {
            for (let i = coll.length - 1; i >= 0; i--) {
                switch (coll[i]) {
                    case 90:
                        parent.notify('transform', { prop: 'rotate', value: { degree: -90, obj: obj } });
                        break;
                    case -90:
                        parent.notify('transform', { prop: 'rotate', value: { degree: 90, obj: obj } });
                        break;
                    default:
                        parent.notify('transform', { prop: 'flipImage', value: { direction: parent.toPascalCase(coll[i]) } });
                        break;
                }
            }
        }
        else {
            for (let i = 0, len = parent.objColl.length; i < len; i++) {
                parent.objColl[i].shapeFlip = '';
            }
            for (let i = 0; i < parent.freehandCounter; i++) {
                parent.pointColl[i].shapeFlip = '';
            }
            for (let i = 0, len = coll.length; i < len; i++) {
                switch (coll[i]) {
                    case 90:
                        parent.notify('transform', { prop: 'rotate', value: { degree: 90, obj: obj } });
                        break;
                    case -90:
                        parent.notify('transform', { prop: 'rotate', value: { degree: -90, obj: obj } });
                        break;
                    default:
                        parent.notify('transform', { prop: 'flipImage', value: { direction: parent.toPascalCase(coll[i]) } });
                        break;
                }
            }
        }
    }
    resetZoom() {
        const parent = this.parent;
        if (parent.transform.zoomFactor > 0) {
            const zoomFactor = parent.transform.zoomFactor;
            const isUndoRedo = parent.isUndoRedo;
            for (let i = 0; i < (zoomFactor * 10); i++) {
                parent.isUndoRedo = true;
                parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                    value: { zoomFactor: -0.1, zoomPoint: null } });
            }
            parent.isUndoRedo = isUndoRedo;
            parent.notify('draw', { prop: 'resetPanPoints', onPropertyChange: false });
        }
    }
    flipCrop() {
        const parent = this.parent;
        parent.notify('transform', { prop: 'setReverseFlip', onPropertyChange: false, value: { isReverseFlip: true } });
        parent.panPoint.totalPannedPoint.x += this.tempFlipPanPoint.x;
        parent.panPoint.totalPannedPoint.y += this.tempFlipPanPoint.y;
        const tempCurrFlipState = parent.transform.currFlipState;
        const obj = { flipColl: null };
        parent.notify('transform', { prop: 'getFlipColl', onPropertyChange: false, value: { obj: obj } });
        const tempFlipColl = obj['flipColl'];
        parent.notify('transform', { prop: 'setFlipColl', onPropertyChange: false, value: { flipColl: [] } });
        parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
        parent.objColl.push(parent.activeObj);
        this.resetZoom();
        parent.currSelectionPoint = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        const temp = this.lowerContext.filter;
        parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        for (let i = 0, len = parent.objColl.length; i < len; i++) {
            parent.objColl[i].shapeFlip = '';
        }
        for (let i = 0; i < parent.freehandCounter; i++) {
            parent.pointColl[i].shapeFlip = '';
        }
        parent.notify('shape', { prop: 'redrawObj', onPropertyChange: false, value: { degree: this.getCurrFlipState() } });
        parent.notify('freehand-draw', { prop: 'flipFHDColl', onPropertyChange: false,
            value: { value: this.getCurrFlipState() } });
        parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
        parent.objColl.pop();
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
        this.cropImg(true);
        parent.notify('transform', { prop: 'setReverseRotate', onPropertyChange: false, value: { bool: true } });
        this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
        parent.notify('draw', { prop: 'setDestPoints', onPropertyChange: false });
        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,
            value: { type: 'initial', isPreventDestination: null, context: null, isPreventCircleCrop: null } });
        parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        this.lowerContext.filter = temp;
        parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: false } });
        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,
            value: { type: 'reverse', isPreventDestination: null, context: null, isPreventCircleCrop: null } });
        parent.transform.currFlipState = tempCurrFlipState;
        parent.notify('transform', { prop: 'setFlipColl', onPropertyChange: false, value: { flipColl: tempFlipColl } });
        this.lowerContext.filter = 'none';
        for (let i = 0, len = parent.objColl.length; i < len; i++) {
            parent.objColl[i].shapeFlip = '';
        }
        for (let i = 0; i < parent.freehandCounter; i++) {
            parent.pointColl[i].shapeFlip = '';
        }
        parent.notify('shape', { prop: 'redrawObj', onPropertyChange: false, value: { degree: this.getCurrFlipState() } });
        parent.notify('freehand-draw', { prop: 'flipFHDColl', onPropertyChange: false,
            value: { value: this.getCurrFlipState() } });
        parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
        parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
        this.lowerContext.filter = temp;
        if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
            this.cropCircle(this.lowerContext);
        }
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify('transform', { prop: 'setReverseFlip', onPropertyChange: false, value: { isReverseFlip: false } });
        parent.notify('draw', { prop: 'resetPanPoints', onPropertyChange: false });
        this.tempFlipPanPoint = { x: 0, y: 0 };
    }
    cropObjColl() {
        const parent = this.parent;
        let point;
        let activePoint;
        let shape;
        if (parent.objColl.length > 0) {
            for (let i = 0, len = parent.objColl.length; i < len; i++) {
                point = parent.objColl[i].activePoint;
                activePoint = parent.activeObj.activePoint;
                shape = parent.objColl[i].shape;
                parent.objColl[i].imageRatio = { startX: ((point.startX - activePoint.startX) / activePoint.width),
                    startY: ((point.startY - activePoint.startY) / activePoint.height),
                    endX: ((point.endX - activePoint.startX) / activePoint.width),
                    endY: ((point.endY - activePoint.startY) / activePoint.height),
                    width: activePoint.width / point.width,
                    height: activePoint.height / point.height };
                let degree;
                let size;
                switch (shape) {
                    case 'text':
                        if (parent.objColl[i].shapeDegree === 0) {
                            degree = this.parent.transform.degree;
                        }
                        else {
                            degree = this.parent.transform.degree - parent.objColl[i].shapeDegree;
                        }
                        size = (degree === 0 || Math.abs(degree) === 180) ? point.width : point.height;
                        parent.objColl[i].textSettings.fontRatio = size / parent.objColl[i].textSettings.fontSize;
                        break;
                    case 'line':
                    case 'arrow':
                        this.cropPointCollection(i);
                        if (shape === 'arrow') {
                            parent.notify('shape', { prop: 'updateArrowRatio', onPropertyChange: false, value: { obj: parent.objColl[i] } });
                        }
                        break;
                    case 'path':
                        this.cropPointCollection(i);
                        break;
                }
            }
        }
    }
    cropPointCollection(i) {
        const parent = this.parent;
        const shape = parent.objColl[i].shape;
        let x;
        let y;
        let width;
        let height;
        const point = parent.activeObj.activePoint;
        if (shape === 'path') {
            x = point.startX;
            y = point.startY;
            width = point.width;
            height = point.height;
        }
        else {
            x = parent.img.destLeft;
            y = parent.img.destTop;
            width = parent.img.destWidth;
            height = parent.img.destHeight;
        }
        const selPoint = parent.objColl[i];
        for (let n = 0, len = selPoint.pointColl.length; n < len; n++) {
            selPoint.pointColl[n].ratioX =
                (selPoint.pointColl[n].x - x) / width;
            selPoint.pointColl[n].ratioY =
                (selPoint.pointColl[n].y - y) / height;
        }
    }
    cropFreehandDrawColl() {
        const parent = this.parent;
        // Update crop values to point collection
        for (let n = 0; n < parent.freehandCounter; n++) {
            parent.points = extend([], parent.pointColl[n].points, []);
            parent.notify('freehand-draw', { prop: 'setPointCounter', onPropertyChange: false, value: { value: 0 } });
            const len = parent.points.length;
            for (let l = 0; l < len; l++) {
                parent.points[l].ratioX = (parent.points[l].x -
                    parent.activeObj.activePoint.startX) / parent.activeObj.activePoint.width;
                parent.points[l].ratioY = (parent.points[l].y -
                    parent.activeObj.activePoint.startY) / parent.activeObj.activePoint.height;
            }
        }
        parent.notify('freehand-draw', { prop: 'updateCropPtsForSel', onPropertyChange: false });
    }
    setCurrSelPoints(isSetDimension) {
        const parent = this.parent;
        const destPoint = this.cropDestPoints;
        const filter = this.lowerContext.filter;
        parent.img.srcLeft = 0;
        parent.img.srcTop = 0;
        parent.img.srcWidth = parent.baseImg.width;
        parent.img.srcHeight = parent.baseImg.height;
        parent.img.destLeft = destPoint.startX;
        parent.img.destTop = destPoint.startY;
        parent.img.destWidth = destPoint.width;
        parent.img.destHeight = destPoint.height;
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        if (isSetDimension) {
            parent.notify('draw', { prop: 'setDestPoints', onPropertyChange: false });
        }
        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,
            value: { type: 'initial', isPreventDestination: null, context: null, isPreventCircleCrop: null } });
        if (this.croppedDegree === 0 && parent.transform.degree === 0 && parent.currSelectionPoint
            && parent.currSelectionPoint.shape !== 'crop-circle' && parent.currSelectionPoint.shape !== 'crop-square') {
            parent.img.destLeft = destPoint.startX;
            parent.img.destTop = destPoint.startY;
            parent.img.destWidth = destPoint.width;
            parent.img.destHeight = destPoint.height;
        }
        if (parent.transform.degree === 0) {
            parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
            parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
        }
        parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        this.lowerContext.filter = filter;
        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,
            value: { type: 'reverse', isPreventDestination: null, context: null, isPreventCircleCrop: true } });
        let cropObjColl = extend([], parent.objColl, null, true);
        let cropPointColl = extend([], parent.pointColl, null, true);
        parent.objColl = [];
        parent.pointColl = [];
        parent.freehandCounter = 0;
        this.panToSelRangle();
        parent.objColl = cropObjColl;
        parent.pointColl = cropPointColl;
        parent.freehandCounter = parent.pointColl.length;
        if (parent.cropObj.activeObj.shape) {
            const destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                height: parent.img.destHeight };
            if (parent.currSelectionPoint && parent.currSelectionPoint.activePoint) {
                parent.img.destLeft = parent.currSelectionPoint.activePoint.startX;
                parent.img.destTop = parent.currSelectionPoint.activePoint.startY;
                parent.img.destWidth = parent.currSelectionPoint.activePoint.width;
                parent.img.destHeight = parent.currSelectionPoint.activePoint.height;
            }
            parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
            parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
            parent.img.destLeft = destPoints.startX;
            parent.img.destTop = destPoints.startY;
            parent.img.destWidth = destPoints.width;
            parent.img.destHeight = destPoints.height;
            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
            cropObjColl = extend([], parent.objColl, null, true);
            cropPointColl = extend([], parent.pointColl, null, true);
            parent.objColl = [];
            parent.pointColl = [];
            parent.freehandCounter = 0;
            const object = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: object } });
            const cropSelPointColl = object['selPointColl'];
            parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                value: { obj: { selPointColl: [] } } });
            parent.cropObj.filter = this.lowerContext.filter;
            const actObj = extend({}, parent.currSelectionPoint, null, true);
            parent.notify('draw', { prop: 'setCurrentObj', onPropertyChange: false, value: { obj: null } });
            parent.activeObj = extend({}, actObj, null, true);
            const activeObj = extend({}, parent.activeObj, null, true);
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.panToSelRangle();
            parent.objColl = cropObjColl;
            parent.pointColl = cropPointColl;
            parent.freehandCounter = parent.pointColl.length;
            parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                value: { obj: { selPointColl: cropSelPointColl } } });
            parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
            parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                value: { context: this.lowerContext, points: null } });
            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
            parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
            parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
            parent.currSelectionPoint = null;
            if (parent.transform.degree === 0) {
                parent.notify('transform', { prop: 'drawPannImage', onPropertyChange: false,
                    value: { point: { x: 0, y: 0 } } });
            }
            parent.activeObj = activeObj;
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
            parent.notify('transform', { prop: 'setTempPanMove', onPropertyChange: false,
                value: { point: null } });
            if (!this.isInitCrop && parent.transform.degree === 0 && parent.cropObj.currFlipState !== '' &&
                parent.cropObj.cropZoom !== 0) {
                this.isInitCrop = true;
                parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });
                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'croptransform',
                        isApplyBtn: false, isCropping: null, isZooming: null, cType: null } });
            }
            else {
                this.isInitCrop = false;
            }
        }
        else {
            const temp = this.lowerContext.filter;
            this.lowerContext.filter = 'none';
            parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
            parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                value: { context: this.lowerContext, points: null } });
            this.lowerContext.filter = temp;
            parent.currSelectionPoint = null;
        }
    }
    panToSelRangle(isReverse) {
        const parent = this.parent;
        const obj = extend({}, parent.currSelectionPoint, null, true);
        parent.currSelectionPoint = null;
        const panX = parent.transform.degree !== 0 ?
            isReverse ? -parent.cropObj.totalPannedClientPoint.x : parent.cropObj.totalPannedClientPoint.x : 0;
        const panY = parent.transform.degree !== 0 ?
            isReverse ? -parent.cropObj.totalPannedClientPoint.y : parent.cropObj.totalPannedClientPoint.y : 0;
        if (parent.transform.degree !== 0) {
            parent.panPoint.currentPannedPoint = { x: panX, y: panY };
            parent.notify('transform', { prop: 'drawPannedImage', value: { xDiff: panX, yDiff: panY } });
            parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
        }
        parent.currSelectionPoint = obj;
    }
    cropCircle(context, isSave, isFlip) {
        const parent = this.parent;
        if (isFlip && parent.transform.currFlipState !== '') {
            parent.notify('draw', { prop: 'setTransform', onPropertyChange: false,
                value: { context: context, value: parent.transform.currFlipState, isReverse: null } });
        }
        context.globalCompositeOperation = 'destination-in';
        context.beginPath();
        const centerX = isNullOrUndefined(isSave) ? parent.img.destLeft + (parent.img.destWidth / 2) : context.canvas.width / 2;
        const centerY = isNullOrUndefined(isSave) ? parent.img.destTop + (parent.img.destHeight / 2) : context.canvas.height / 2;
        const radius = isSave ? context.canvas.width / 2 : parent.img.destWidth / 2;
        context.arc(centerX, centerY, radius, 0, Math.PI * 2);
        context.closePath();
        context.fill();
        context.restore();
        context.globalCompositeOperation = 'source-over';
        parent.currObjType.isActiveObj = parent.isCircleCrop = true;
        if (isFlip && parent.transform.currFlipState !== '') {
            parent.notify('draw', { prop: 'setTransform', onPropertyChange: false,
                value: { context: context, value: parent.transform.currFlipState, isReverse: null } });
        }
    }
    getCurrCropState(type, isAllowInvert) {
        const parent = this.parent;
        let flipState = '';
        const state = [];
        const obj = { flipColl: null };
        parent.notify('transform', { prop: 'getFlipColl', onPropertyChange: false, value: { obj: obj } });
        if (type === 'initial') {
            if (Math.abs(parent.transform.degree) === 180) {
                flipState = obj['flipColl'].length > 1 ? this.getCurrFlipState() : parent.transform.currFlipState;
            }
            else {
                for (let i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
                    if (typeof (parent.rotateFlipColl[i]) === 'number') {
                        state.push('number');
                    }
                    else if (typeof (parent.rotateFlipColl[i]) === 'string') {
                        state.push('string');
                    }
                }
                if (state.length > 1 && state[state.length - 1] === 'string' && state[state.length - 2] === 'number') {
                    if (parent.transform.currFlipState === 'horizontal') {
                        flipState = 'vertical';
                    }
                    else if (parent.transform.currFlipState === 'vertical') {
                        flipState = 'horizontal';
                    }
                }
                else if (state.length > 1 && state[state.length - 1] === 'number' && state[state.length - 2] === 'string') {
                    flipState = obj['flipColl'].length > 1 ? this.getCurrFlipState() : parent.transform.currFlipState;
                }
            }
        }
        else {
            flipState = this.getCurrFlipState();
            if (isAllowInvert || !this.isInitialRotate()) {
                if (parent.transform.degree === -90 || parent.transform.degree === -270) {
                    if (flipState === 'horizontal') {
                        flipState = 'vertical';
                    }
                    else if (flipState === 'vertical') {
                        flipState = 'horizontal';
                    }
                }
            }
        }
        if (flipState === '') {
            flipState = obj['flipColl'].length > 1 ? this.getCurrFlipState() : parent.transform.currFlipState;
        }
        return flipState;
    }
    isInitialRotate() {
        let isRotate = false;
        if (this.parent.rotateFlipColl.length > 0 && typeof (this.parent.rotateFlipColl[0]) === 'number') {
            isRotate = true;
        }
        return isRotate;
    }
    updateRotatePan() {
        const parent = this.parent;
        if (isNullOrUndefined(parent.panPoint.currentPannedPoint)) {
            return;
        }
        let panRegion = '';
        if (parent.rotateFlipColl.length > 0 && typeof (parent.rotateFlipColl[0]) === 'number'
            && parent.transform.degree < 0) {
            panRegion = this.getCurrCropState('reverse', true);
        }
        else {
            panRegion = this.getCurrFlipState();
        }
        if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
            if (parent.transform.degree === 90 || (parent.transform.degree === -90 &&
                (panRegion === 'horizontal' || panRegion === 'vertical'))
                || (parent.transform.degree === -270 && (panRegion === '' || panRegion === 'verticalHorizontal'
                    || panRegion === 'horizontalVertical'))) {
                if (panRegion === 'horizontal' || panRegion === '') {
                    parent.img.destLeft += parent.panPoint.currentPannedPoint.y;
                }
                else {
                    parent.img.destLeft -= parent.panPoint.currentPannedPoint.y;
                }
                if (panRegion === '' || panRegion === 'vertical') {
                    parent.img.destTop -= parent.panPoint.currentPannedPoint.x;
                }
                else {
                    parent.img.destTop += parent.panPoint.currentPannedPoint.x;
                }
            }
            else if (parent.transform.degree === 270 || (parent.transform.degree === -270 &&
                (panRegion === 'horizontal' || panRegion === 'vertical'))
                || (parent.transform.degree === -90 && (panRegion === '' || panRegion === 'verticalHorizontal'
                    || panRegion === 'horizontalVertical'))) {
                if (panRegion === '' || panRegion === 'horizontal') {
                    parent.img.destLeft -= parent.panPoint.currentPannedPoint.y;
                }
                else {
                    parent.img.destLeft += parent.panPoint.currentPannedPoint.y;
                }
                if (panRegion === '' || panRegion === 'vertical') {
                    parent.img.destTop += parent.panPoint.currentPannedPoint.x;
                }
                else {
                    parent.img.destTop -= parent.panPoint.currentPannedPoint.x;
                }
            }
        }
        else {
            if (parent.transform.degree === 180 || parent.transform.degree === -180) {
                if (panRegion === '' || panRegion === 'vertical') {
                    parent.img.destLeft -= parent.panPoint.currentPannedPoint.x;
                }
                else {
                    parent.img.destLeft += parent.panPoint.currentPannedPoint.x;
                }
                if (panRegion === '' || panRegion === 'horizontal') {
                    parent.img.destTop -= parent.panPoint.currentPannedPoint.y;
                }
                else {
                    parent.img.destTop += parent.panPoint.currentPannedPoint.y;
                }
            }
        }
    }
    crop(obj) {
        const parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            const object = { isCropToolbar: parent.isCropToolbar };
            if (parent.currObjType.isUndoAction && !object['isCropToolbar']) {
                parent.notify('undo-redo', { prop: 'refreshUrc', value: { bool: null } });
            }
            const transitionArgs = { cancel: false, startPoint: { x: parent.activeObj.activePoint.startX,
                    y: parent.activeObj.activePoint.startY }, endPoint: { x: parent.activeObj.activePoint.endX,
                    y: parent.activeObj.activePoint.endY }, preventScaling: false };
            if (!object['isCropToolbar'] && isBlazor() && parent.events && parent.events.cropping.hasDelegate === true) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                parent.dotNetRef.invokeMethodAsync('CropEventAsync', 'OnCrop', transitionArgs).then((args) => {
                    this.cropEvent(args, obj, object);
                });
            }
            else {
                if (!object['isCropToolbar']) {
                    parent.trigger('cropping', transitionArgs);
                }
                this.cropEvent(transitionArgs, obj, object);
            }
        }
    }
    cropEvent(transitionArgs, obj, object) {
        const parent = this.parent;
        let splitWords;
        if (!transitionArgs.cancel) {
            splitWords = parent.activeObj.shape ? parent.activeObj.shape.split('-') : [];
            if (!parent.disabled && parent.activeObj.horTopLine && (parent.currObjType.isCustomCrop || (splitWords.length > 0 &&
                splitWords[0] === 'crop'))) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                obj.isCrop = true;
                const prevCropObj = extend({}, parent.cropObj, {}, true);
                const prevObj = extend({}, this.prevCropCurrObj, {}, true);
                if (transitionArgs.preventScaling) {
                    this.isPreventScaling = true;
                }
                else {
                    this.isPreventScaling = false;
                }
                this.cropImg();
                parent.transform.zoomFactor = 0;
                parent.setProperties({ zoomSettings: { zoomFactor: 1 } }, true);
                parent.notify('transform', { prop: 'setPreviousZoomValue', onPropertyChange: false,
                    value: { previousZoomValue: parent.zoomSettings.zoomFactor } });
                const currSelPtObj = { prevCurrSelectionPoint: this.parent.prevCurrSelectionPoint };
                prevObj.currSelectionPoint = extend({}, currSelPtObj['prevCurrSelectionPoint'], {}, true);
                parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                    value: { operation: 'crop', previousObj: prevObj, previousObjColl: prevObj.objColl,
                        previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                        previousCropObj: prevCropObj, previousText: null,
                        currentText: null, previousFilter: null, isCircleCrop: parent.isCircleCrop } });
                if (!object['isCropToolbar']) {
                    parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                }
                parent.notify('transform', { prop: 'setCropDimension', onPropertyChange: false,
                    value: { width: parent.cropObj.destPoints.width, height: parent.cropObj.destPoints.height } });
                if (!isBlazor() && !object['isCropToolbar']) {
                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                            isApplyBtn: false, isCropping: false, isZooming: null, cType: null } });
                }
                else if (!object['isCropToolbar']) {
                    this.parent.updateToolbar(this.parent.element, 'imageLoaded');
                }
            }
        }
    }
    calcRatio(obj, dimension) {
        const parent = this.parent;
        let widthRatio;
        let heightRatio;
        if (parent.transform.degree === 0 || parent.transform.degree % 180 === 0) {
            widthRatio = (dimension ? dimension.width : parent.baseImg.width) / parent.img.destWidth;
            heightRatio = (dimension ? dimension.height : parent.baseImg.height) / parent.img.destHeight;
        }
        else {
            widthRatio = (dimension ? dimension.height : parent.baseImg.height) / parent.img.destWidth;
            heightRatio = (dimension ? dimension.width : parent.baseImg.width) / parent.img.destHeight;
        }
        if (obj) {
            obj['width'] = widthRatio;
            obj['height'] = heightRatio;
        }
        return { width: widthRatio, height: heightRatio };
    }
    isObjInImage(obj, dummyObj) {
        const parent = this.parent;
        let isInside = false;
        const startX = obj.activePoint.startX;
        const endX = obj.activePoint.endX;
        const startY = obj.activePoint.startY;
        const endY = obj.activePoint.endY;
        if ((startX >= parent.img.destLeft && endX <= (parent.img.destLeft + parent.img.destWidth)) ||
            (startX <= parent.img.destLeft && endX >= parent.img.destLeft) ||
            (startX <= (parent.img.destLeft + parent.img.destWidth) && endX >= (parent.img.destLeft + parent.img.destWidth)) ||
            (startY >= parent.img.destTop && endY <= (parent.img.destTop + parent.img.destHeight)) ||
            (startY <= parent.img.destTop && endY >= parent.img.destTop) ||
            (startY <= (parent.img.destTop + parent.img.destHeight) && endY >= (parent.img.destTop + parent.img.destHeight))) {
            isInside = true;
        }
        if (dummyObj) {
            dummyObj['isInside'] = isInside;
        }
        return isInside;
    }
    getCurrFlipState(panObj) {
        const parent = this.parent;
        const obj = { panRegion: '' };
        const object = { collection: parent.rotateFlipColl };
        parent.notify('shape', { prop: 'alignRotateFlipColl', onPropertyChange: false,
            value: { collection: parent.rotateFlipColl, isRotateFlipCollection: true, obj: object } });
        parent.rotateFlipColl = object['collection'];
        for (let i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
            parent.notify('transform', { prop: 'setCurrPanRegion', onPropertyChange: false,
                value: { region: obj['panRegion'], type: parent.rotateFlipColl[i], obj: obj } });
        }
        if (panObj) {
            panObj['panRegion'] = obj['panRegion'];
        }
        return obj['panRegion'];
    }
}

class Draw {
    constructor(parent) {
        this.isInitialLoading = false; // Specifies whether image is loaded for the first time or not (for applying initial filter)
        this.fileName = '';
        this.isErrorImage = false;
        this.isShapeTextInserted = false;
        this.isRotateZoom = false; // To restore zoomed image on selection crop selection
        this.tempStrokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null }; // restore stroke settings on cancel
        this.tempTextSettings = { text: 'Enter Text', fontFamily: 'Arial', fontSize: null, fontRatio: null, bold: false, italic: false, underline: false }; // restore text settings on cancel
        this.tempAdjValue = ''; // for temp internal slider value
        this.tempFilter = ''; // restore filter style on cancel
        this.tempUndoRedoStep = 0;
        this.tempFreehandCounter = 0;
        this.tempCurrFhdIndex = 0;
        this.tempZoomFactor = null; // Restore zoom factor on cancel
        this.isCancelAction = false;
        this.rotatedFlipCropSel = false;
        this.zoomCrop = { width: 0, height: 0 };
        this.isImageEdited = false;
        this.isFileChanged = false;
        this.isNewPath = false;
        this.arrowDimension = { bar: { width: 10, height: 32, ratioX: null, ratioY: null },
            arrow: { width: 24, height: 24, ratioX: null, ratioY: null }, arrowSolid: { width: 32, height: 32, ratioX: null, ratioY: null },
            circle: { width: 10, height: 10, ratioX: null, ratioY: null }, square: { width: 20, height: 20, ratioX: null, ratioY: null } };
        this.parent = parent;
        this.addEventListener();
    }
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    }
    addEventListener() {
        this.parent.on('draw', this.draw, this);
        this.parent.on('destroyed', this.destroy, this);
    }
    removeEventListener() {
        this.parent.off('draw', this.draw);
        this.parent.off('destroyed', this.destroy);
    }
    draw(args) {
        this.updatePrivateVariables();
        switch (args.prop) {
            case 'drawObject':
                this.drawObject(args.value['canvas'], args.value['obj'], args.value['isCropRatio'], args.value['points'], args.value['isPreventDrag'], args.value['saveContext'], args.value['isPreventSelection']);
                break;
            case 'updateActiveObject':
                this.updateActiveObject(args.value['actPoint'], args.value['obj'], args.value['isMouseMove'], args.value['x'], args.value['y']);
                break;
            case 'clearOuterCanvas':
                this.clearOuterCanvas(args.value['context']);
                break;
            case 'setDestPoints':
                this.setDestPoints();
                break;
            case 'updateCurrTransState':
                this.updateCurrTransState(args.value['type'], args.value['isPreventDestination'], args.value['isRotatePan']);
                break;
            case 'currTransState':
                this.currTransState(args.value['type'], args.value['isPreventDestination'], args.value['context'], args.value['isPreventCircleCrop']);
                break;
            case 'setTransform':
                this.setTransform(args.value['context'], args.value['value'], args.value['isReverse']);
                break;
            case 'render-image':
                this.renderImage(args.value['isMouseWheel']);
                break;
            case 'draw-image-to-canvas':
                this.drawImgToCanvas(args.value['dimension']);
                break;
            case 'update-canvas':
                this.updateCanvas();
                break;
            case 'performCancel':
                this.performCancel(args.value['isContextualToolbar']);
                break;
            case 'updateFlipPan':
                this.updateFlipPan(args.value['tempSelectionObj']);
                break;
            case 'select':
                this.select(args.value['type'], args.value['startX'], args.value['startY'], args.value['width'], args.value['height']);
                break;
            case 'callUpdateCurrTransState':
                this.callUpdateCurrTransState();
                break;
            case 'resetPanPoints':
                this.resetPanPoints();
                break;
            case 'setClientTransDim':
                this.setClientTransDim(args.value['isPreventDimension']);
                break;
            case 'redrawImgWithObj':
                this.redrawImgWithObj();
                break;
            case 'setCurrentObj':
                this.setCurrentObj(args.value['obj']);
                break;
            case 'performPointZoom':
                this.performPointZoom(args.value['x'], args.value['y'], args.value['type']);
                break;
            case 'open':
                this.open(args.value['data']);
                break;
            case 'isInitialLoading':
                this.isInitialLoading = args.value['isInitialLoading'];
                break;
            case 'isInitialLoaded':
                this.getInitialLoaded(args.value['object']);
                break;
            case 'fileSelect':
                this.fileSelect(args.value['inputElement'], args.value['args']);
                break;
            case 'getFileName':
                args.value['obj']['fileName'] = this.fileName;
                args.value['obj']['fileType'] = this.fileType;
                break;
            case 'getErrorImage':
                args.value['obj']['isErrorImage'] = this.isErrorImage;
                break;
            case 'getInitialZoomValue':
                args.value['obj']['initialZoomValue'] = this.initZoomValue;
                break;
            case 'setShapeTextInsert':
                this.isShapeTextInserted = args.value['bool'];
                break;
            case 'resetCurrentSelectionPoint':
                this.currSelPoint = null;
                break;
            case 'setRotateZoom':
                this.isRotateZoom = args.value['isRotateZoom'];
                break;
            case 'setTempStrokeSettings':
                this.tempStrokeSettings = args.value['tempStrokeSettings'];
                break;
            case 'setTempTextSettings':
                this.tempTextSettings = args.value['tempTextSettings'];
                break;
            case 'setTempAdjustmentValue':
                this.tempAdjValue = args.value['tempAdjustmentValue'];
                break;
            case 'getTempAdjustmentValue':
                args.value['obj']['value'] = this.tempAdjValue;
                break;
            case 'setTempFilter':
                this.tempFilter = args.value['tempFilter'];
                break;
            case 'setTempUndoRedoStep':
                this.tempUndoRedoStep = args.value['tempUndoRedoStep'];
                break;
            case 'setTempFreehandCounter':
                this.tempFreehandCounter = args.value['tempFreehandCounter'];
                break;
            case 'setTempCurrentFreehandDrawIndex':
                this.tempCurrFhdIndex = args.value['tempCurrentFreehandDrawIndex'];
                break;
            case 'setTempZoomFactor':
                this.tempZoomFactor = args.value['tempZoomFactor'];
                break;
            case 'setCancelAction':
                this.isCancelAction = args.value['bool'];
                break;
            case 'getRotatedFlipCropSelection':
                args.value['bool']['isSelected'] = this.rotatedFlipCropSel;
                break;
            case 'getPrevActObj':
                args.value['obj']['prevActObj'] = this.prevActObj;
                break;
            case 'setPrevActObj':
                this.prevActObj = args.value['prevActObj'];
                break;
            case 'setZoomCropWidth':
                this.zoomCrop.width = args.value['width'];
                this.zoomCrop.height = args.value['height'];
                break;
            case 'setImageEdited':
                this.isImageEdited = true;
                break;
            case 'reset':
                this.reset();
                break;
            case 'dlgBtnClick':
                this.dlgBtnClick();
                break;
            case 'dlgCloseBtnClick':
                this.dlgCloseBtnClick();
                break;
            case 'setNewPath':
                this.isNewPath = args.value['bool'];
                break;
            case 'getNewPath':
                args.value['obj']['isNewPath'] = this.isNewPath;
                break;
            case 'getArrowDimension':
                args.value['obj']['arrowDimension'] = this.arrowDimension;
                break;
            case 'setArrowDimension':
                this.arrowDimension = args.value['arrowDimension'];
                break;
            case 'moveToSelectionRange':
                this.moveToSelectionRange(args.value['type'], args.value['activeObj']);
                break;
        }
    }
    getModuleName() {
        return 'draw';
    }
    updatePrivateVariables() {
        const parent = this.parent;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
        if (parent.upperCanvas) {
            this.upperContext = parent.upperCanvas.getContext('2d');
        }
        if (isNullOrUndefined(this.tempZoomFactor)) {
            this.tempZoomFactor = parent.transform.zoomFactor;
        }
    }
    reset() {
        this.isInitialLoading = this.isErrorImage = this.isNewPath = false;
        this.isShapeTextInserted = false;
        this.initZoomValue = null;
        this.tempFilter = '';
        this.currSelPoint = null;
        this.isRotateZoom = false;
        this.tempAdjValue = '';
        this.tempStrokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null };
        this.tempTextSettings =
            { text: 'Enter Text', fontFamily: 'Arial', fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
        this.tempUndoRedoStep = this.tempFreehandCounter = this.tempCurrFhdIndex = 0;
        this.tempZoomFactor = null;
        this.isCancelAction = false;
        this.rotatedFlipCropSel = false;
        this.prevActObj = null;
        this.arrowDimension = { bar: { width: 10, height: 32, ratioX: null, ratioY: null },
            arrow: { width: 24, height: 24, ratioX: null, ratioY: null }, arrowSolid: { width: 32, height: 32, ratioX: null, ratioY: null },
            circle: { width: 10, height: 10, ratioX: null, ratioY: null }, square: { width: 20, height: 20, ratioX: null, ratioY: null } };
    }
    drawObject(canvas, obj, isCropRatio, points, isPreventDrag, saveContext, isPreventSelection) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        let canvasDraw;
        if (canvas.toLowerCase() === 'original') {
            canvasDraw = this.lowerContext;
        }
        else if (canvas.toLowerCase() === 'duplicate') {
            canvasDraw = this.upperContext;
        }
        else if (saveContext) {
            canvasDraw = saveContext;
        }
        if (!isPreventDrag && parent.activeObj.shape) {
            this.setDragLimit();
        }
        if (parent.currObjType.shape) {
            const splitWords = parent.currObjType.shape.split('-');
            if (splitWords[0].toLowerCase() === 'crop' && isCropRatio) {
                this.drawCropRatio();
            }
        }
        if (points) {
            actPoint.startX = points.startX;
            actPoint.startY = points.startY;
            actPoint.endX = points.endX;
            actPoint.endY = points.endY;
            actPoint.width = points.width;
            actPoint.height = points.height;
        }
        if (isNullOrUndefined(parent.activeObj.strokeSettings)) {
            const obj = { strokeSettings: {} };
            parent.notify('shape', { prop: 'getStrokeSettings', onPropertyChange: false,
                value: { obj: obj } });
            parent.activeObj.strokeSettings = obj['strokeSettings'];
        }
        if (isNullOrUndefined(parent.activeObj.strokeSettings.strokeWidth)) {
            parent.activeObj.strokeSettings.strokeWidth = 2;
        }
        if (obj) {
            parent.activeObj = extend({}, obj, {}, true);
        }
        this.updateActiveObject();
        if (isNullOrUndefined(parent.activeObj.activePoint.startX) &&
            isNullOrUndefined(parent.activeObj.activePoint.startY)) {
            return;
        }
        if (parent.currObjType.isText) {
            const obj = { keyHistory: '' };
            parent.notify('shape', { prop: 'getKeyHistory', onPropertyChange: false, value: { obj: obj } });
            parent.activeObj.keyHistory = obj['keyHistory'];
        }
        if (canvas.toLowerCase() !== 'original') {
            let splitWords;
            let isCrop = false;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
                if (splitWords[0] === 'crop') {
                    isCrop = true;
                }
            }
            if (isCrop) {
                this.upperContext.fillStyle = 'rgb(0, 0, 0, 0.25)';
                this.upperContext.fillRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
                this.upperContext.clearRect(actPoint.startX, actPoint.startY, actPoint.width, actPoint.height);
            }
            if (isNullOrUndefined(isPreventSelection) && (canvasDraw === this.lowerContext || canvasDraw === this.upperContext)) {
                this.rotateContext('initial', canvasDraw);
                this.drawOuterSelection(canvasDraw);
                this.rotateContext('reverse', canvasDraw);
            }
        }
        parent.currObjType.isActiveObj = true;
        const object = { keyHistory: '' };
        parent.notify('shape', { prop: 'getKeyHistory', onPropertyChange: false, value: { obj: object } });
        if (obj) {
            this.drawShapeObj(canvas, obj.shape, saveContext, isPreventSelection);
        }
        else if (object['keyHistory'] !== '' && parent.currObjType.isText) {
            this.drawShapeObj(canvas, 'text', saveContext, isPreventSelection);
        }
        else if (parent.activeObj.shape) {
            this.drawShapeObj(canvas, parent.activeObj.shape, saveContext, isPreventSelection);
        }
        else {
            this.drawShapeObj(canvas, undefined, saveContext, isPreventSelection);
        }
    }
    rotateContext(type, ctx) {
        const parent = this.parent;
        const activePoint = extend({}, parent.activeObj.activePoint, {}, true);
        if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow') {
            return;
        }
        const rotationAngle = (type === 'initial') ? parent.activeObj.rotatedAngle : -parent.activeObj.rotatedAngle;
        ctx.translate(activePoint.startX + (activePoint.width / 2), activePoint.startY + (activePoint.height / 2));
        ctx.rotate(rotationAngle);
        ctx.translate(-(activePoint.startX + (activePoint.width / 2)), -(activePoint.startY + (activePoint.height / 2)));
    }
    setDragLimit() {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        if (actPoint && parent.activeObj.rotatedAngle === 0) {
            if (actPoint.startX < parent.img.destLeft) {
                actPoint.startX = parent.img.destLeft;
                actPoint.endX = actPoint.startX + actPoint.width;
            }
            else if (actPoint.endX > parent.img.destLeft + parent.img.destWidth) {
                actPoint.endX = parent.img.destLeft + parent.img.destWidth;
                actPoint.startX = actPoint.endX - actPoint.width;
            }
            if (actPoint.startY < parent.img.destTop) {
                actPoint.startY = parent.img.destTop;
            }
            else if (actPoint.endY > parent.img.destTop + parent.img.destHeight) {
                actPoint.endY = parent.img.destTop + parent.img.destHeight;
                actPoint.startY = actPoint.endY - actPoint.height;
            }
            parent.activeObj = this.updateWidthHeight(parent.activeObj);
        }
    }
    drawCropRatio() {
        const parent = this.parent;
        let actPoint = parent.activeObj.activePoint;
        let x;
        let y;
        let width;
        let height;
        if (parent.transform.zoomFactor > 0 && this.currSelPoint) {
            const activeObj = extend({}, parent.activeObj, {}, true);
            this.drawCustomSelection('crop-custom', null, null, null, null);
            if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
                width = parent.activeObj.activePoint.width < parent.activeObj.activePoint.height ?
                    parent.activeObj.activePoint.width : parent.activeObj.activePoint.height;
                height = width;
            }
            else {
                if (parent.img.destLeft + parent.img.destLeft + parent.img.destWidth <= parent.lowerCanvas.clientWidth) {
                    width = actPoint.width;
                }
                else {
                    width = parent.lowerCanvas.clientWidth - parent.img.destLeft;
                }
                if (parent.img.destTop + parent.img.destTop + parent.img.destHeight <= parent.lowerCanvas.clientHeight) {
                    height = actPoint.height;
                }
                else {
                    height = parent.lowerCanvas.clientHeight - parent.img.destTop;
                }
            }
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.activeObj = activeObj;
            parent.currObjType.shape = activeObj.shape;
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.currObjType.isCustomCrop = false;
        }
        else {
            width = parent.img.destWidth;
            height = parent.img.destHeight;
            if (parent.img.destLeft < 0) {
                width += parent.img.destLeft;
            }
            if (parent.img.destTop < 0) {
                height += parent.img.destTop;
            }
            if (parent.currObjType.shape.toLowerCase() !== 'crop-square' && parent.currObjType.shape.toLowerCase() !== 'crop-circle') {
                if (parent.img.destLeft + parent.img.destWidth > parent.lowerCanvas.width) {
                    width -= (parent.img.destLeft + parent.img.destWidth - parent.lowerCanvas.width);
                }
                if (parent.img.destTop + parent.img.destHeight > parent.lowerCanvas.height) {
                    height -= (parent.img.destTop + parent.img.destHeight - parent.lowerCanvas.height);
                }
            }
        }
        switch (parent.currObjType.shape.toLowerCase()) {
            case 'crop-square':
            case 'crop-circle':
                parent.notify('selection', { prop: 'setDragDirection', onPropertyChange: false, value: { width: width, height: height } });
                actPoint = parent.activeObj.activePoint;
                if (parent.lowerCanvas.width < (actPoint.endX - actPoint.startX)) {
                    actPoint.startX = 7.5;
                    actPoint.endX = parent.lowerCanvas.width - 7.5;
                }
                if (parent.lowerCanvas.height < (actPoint.endY - actPoint.startY)) {
                    actPoint.startY = 7.5;
                    actPoint.endY = parent.lowerCanvas.height - 7.5;
                }
                if (width === parent.img.destWidth && height === parent.img.destHeight) {
                    actPoint.startX += parent.img.destLeft;
                    actPoint.startY +=
                        parent.img.destTop;
                    actPoint.endX += parent.img.destLeft;
                    actPoint.endY +=
                        parent.img.destTop;
                }
                if (parent.lowerCanvas.width > parent.lowerCanvas.height) {
                    actPoint.height = actPoint.endY - actPoint.startY;
                    actPoint.width = actPoint.height;
                    actPoint.endX = actPoint.startX +
                        actPoint.width;
                }
                else {
                    actPoint.width = actPoint.endX - actPoint.startX;
                    actPoint.height = actPoint.width;
                    actPoint.endY = actPoint.startY +
                        actPoint.height;
                }
                break;
            case 'crop-3:2':
                x = 3;
                y = 2;
                break;
            case 'crop-4:3':
                x = 4;
                y = 3;
                break;
            case 'crop-5:4':
                x = 5;
                y = 4;
                break;
            case 'crop-7:5':
                x = 7;
                y = 5;
                break;
            case 'crop-16:9':
                x = 16;
                y = 9;
                break;
        }
        if (x !== undefined && y !== undefined) {
            parent.notify('selection', { prop: 'calcShapeRatio', onPropertyChange: false,
                value: { x: x, y: y, imgWidth: width, imgHeight: height } });
            if (width === parent.img.destWidth && height === parent.img.destHeight) {
                this.updatePoints();
            }
            actPoint = parent.activeObj.activePoint;
        }
        if (actPoint.startX < parent.img.destLeft) {
            const diff = (parent.img.destLeft - actPoint.startX) + 7.5;
            actPoint.startX += diff;
            actPoint.endX += diff;
        }
        if (actPoint.startY < parent.img.destTop) {
            const diff = (parent.img.destTop - actPoint.startY) + 7.5;
            actPoint.startY += diff;
            actPoint.endY += diff;
        }
        parent.activeObj = this.updateWidthHeight(parent.activeObj);
        this.adjToCenter();
    }
    adjToCenter() {
        const parent = this.parent;
        const diffX = ((parent.lowerCanvas.width) / 2) - (parent.activeObj.activePoint.endX -
            parent.activeObj.activePoint.width / 2);
        const diffY = ((parent.lowerCanvas.height) / 2) - (parent.activeObj.activePoint.endY -
            parent.activeObj.activePoint.height / 2);
        parent.activeObj.activePoint.startX += diffX;
        parent.activeObj.activePoint.endX += diffX;
        parent.activeObj.activePoint.startY += diffY;
        parent.activeObj.activePoint.endY += diffY;
        if (parent.activeObj.activePoint.startX < (parent.img.destLeft >= 7.5 ? parent.img.destLeft : 7.5)) {
            const diff = ((parent.img.destLeft >= 7.5 ? parent.img.destLeft : 0) - parent.activeObj.activePoint.startX) + 7.5;
            parent.activeObj.activePoint.startX += diff;
            parent.activeObj.activePoint.endX += diff;
        }
        else if (parent.activeObj.activePoint.endX > parent.img.destLeft + parent.img.destWidth) {
            const diff = (parent.activeObj.activePoint.endX - (parent.img.destLeft + parent.img.destWidth)) + 7.5;
            parent.activeObj.activePoint.startX -= diff;
            parent.activeObj.activePoint.endX -= diff;
        }
        if (parent.activeObj.activePoint.startY < (parent.img.destTop > 7.5 ? parent.img.destTop : 7.5)) {
            const diff = ((parent.img.destTop > 7.5 ? parent.img.destTop : 0) - parent.activeObj.activePoint.startY) + 7.5;
            parent.activeObj.activePoint.startY += diff;
            parent.activeObj.activePoint.endY += diff;
        }
        else if (parent.activeObj.activePoint.endY > parent.img.destTop + parent.img.destHeight) {
            const diff = (parent.activeObj.activePoint.endY - (parent.img.destTop + parent.img.destHeight)) + 7.5;
            parent.activeObj.activePoint.startY -= diff;
            parent.activeObj.activePoint.endY -= diff;
        }
    }
    updateActiveObject(actPoint, obj, isMouseMove, x, y) {
        actPoint = actPoint ? actPoint : extend({}, this.parent.activeObj.activePoint, {}, true);
        obj = obj ? obj : extend({}, this.parent.activeObj, {}, true);
        actPoint.width = actPoint.endX - actPoint.startX;
        actPoint.height = actPoint.endY - actPoint.startY;
        x = x ? x : 0;
        y = y ? y : 0;
        const horCircleWidth = actPoint.width / 2;
        const verCircleHeight = actPoint.height / 2;
        const radius = 7.5;
        obj.horTopLine = { startX: actPoint.startX + x, startY: actPoint.startY - y,
            endX: actPoint.endX + x, endY: actPoint.endY + y };
        obj.horBottomLine = { startX: actPoint.startX - x, startY: actPoint.endY - y,
            endX: actPoint.endX - x, endY: actPoint.endY + y };
        obj.verLeftLine = { startX: actPoint.startX + x, startY: actPoint.startY - y,
            endX: actPoint.startX - y, endY: actPoint.endY - y };
        obj.verRightLine = { startX: actPoint.endX + x, startY: actPoint.startY + y,
            endX: actPoint.endX - x, endY: actPoint.endY + y };
        obj.topLeftCircle = { startX: actPoint.startX, startY: actPoint.startY,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.topCenterCircle = { startX: actPoint.startX + horCircleWidth, startY: actPoint.startY,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.topRightCircle = { startX: actPoint.endX, startY: actPoint.startY,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.centerLeftCircle = { startX: actPoint.startX, startY: actPoint.startY + verCircleHeight,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.centerRightCircle = { startX: actPoint.endX, startY: actPoint.startY + verCircleHeight,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.bottomLeftCircle = { startX: actPoint.startX, startY: actPoint.endY,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.bottomCenterCircle = { startX: actPoint.startX + horCircleWidth, startY: actPoint.endY,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        obj.bottomRightCircle = { startX: actPoint.endX, startY: actPoint.endY,
            radius: obj.horTopLine.endX ? (radius) : 0 };
        if (obj.rotatedAngle === 0) {
            obj.rotationCirclePoint = { x: obj.bottomCenterCircle.startX,
                y: obj.bottomCenterCircle.startY + 25 };
            obj.rotationCirclePoint.ratioX = (obj.rotationCirclePoint.x - this.parent.img.destLeft) / this.parent.img.destWidth;
            obj.rotationCirclePoint.ratioY = (obj.rotationCirclePoint.y - this.parent.img.destTop) / this.parent.img.destHeight;
        }
        obj.activePoint = actPoint;
        if (isNullOrUndefined(isMouseMove)) {
            this.parent.activeObj = extend({}, obj, {}, true);
        }
    }
    drawOuterSelection(canvasDraw, isCropCircle) {
        let splitWords;
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        canvasDraw.lineWidth = (0.5);
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        const tempObj = extend({}, parent.activeObj, {}, true);
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (((splitWords !== undefined && splitWords[0] === 'crop') || parent.activeObj.shape === undefined) && !isCropCircle) {
            this.upperContext.fillStyle = 'rgb(0, 0, 0, 0.25)';
            this.upperContext.fillRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            this.upperContext.clearRect(actPoint.startX, actPoint.startY, actPoint.width, actPoint.height);
        }
        canvasDraw.strokeStyle = parent.themeColl[parent.theme]['primaryColor'];
        canvasDraw.fillStyle = parent.themeColl[parent.theme]['secondaryColor'];
        let degree;
        if (tempObj.shapeDegree === 0) {
            degree = parent.transform.degree;
        }
        else {
            degree = parent.transform.degree - tempObj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        if (parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'line') {
            canvasDraw.beginPath();
            canvasDraw.moveTo(actPoint.startX, actPoint.startY);
            canvasDraw.lineTo(actPoint.endX, actPoint.endY);
            canvasDraw.stroke();
        }
        else if (parent.activeObj.shape === 'path') {
            canvasDraw.beginPath();
            const activeObj = extend({}, parent.activeObj, {}, true);
            canvasDraw.moveTo(activeObj.pointColl[0].x, activeObj.pointColl[0].y);
            if (activeObj.pointColl.length > 1) {
                for (let i = 1, len = activeObj.pointColl.length; i < len; i++) {
                    actPoint.endX = activeObj.pointColl[i].x;
                    actPoint.endY = activeObj.pointColl[i].y;
                    canvasDraw.lineTo(actPoint.endX, actPoint.endY);
                }
            }
            const obj = { shape: null };
            parent.notify('selection', { prop: 'getCurrentDrawingShape', value: { obj: obj } });
            if (obj['shape'] === 'path') {
                parent.activeObj = activeObj;
            }
            canvasDraw.lineTo(actPoint.endX, actPoint.endY);
            canvasDraw.stroke();
        }
        else {
            canvasDraw.beginPath();
            canvasDraw.rect(tempObj.activePoint.startX, tempObj.activePoint.startY, tempObj.activePoint.width, tempObj.activePoint.height);
            canvasDraw.stroke();
            canvasDraw.closePath();
            if (parent.selectionSettings.showCircle) {
                const strokeColor = canvasDraw.strokeStyle;
                const fillColor = canvasDraw.fillStyle;
                canvasDraw.strokeStyle = parent.selectionSettings.strokeColor;
                canvasDraw.fillStyle = parent.selectionSettings.fillColor;
                canvasDraw.lineWidth *= 2;
                canvasDraw.beginPath();
                canvasDraw.moveTo(tempObj.topLeftCircle.startX, tempObj.topLeftCircle.startY);
                canvasDraw.arc(tempObj.topLeftCircle.startX, tempObj.topLeftCircle.startY, tempObj.topLeftCircle.radius, 0, 2 * Math.PI);
                canvasDraw.moveTo(tempObj.topRightCircle.startX, tempObj.topRightCircle.startY);
                canvasDraw.arc(tempObj.topRightCircle.startX, tempObj.topRightCircle.startY, tempObj.topRightCircle.radius, 0, 2 * Math.PI);
                canvasDraw.moveTo(tempObj.bottomLeftCircle.startX, tempObj.bottomLeftCircle.startY);
                canvasDraw.arc(tempObj.bottomLeftCircle.startX, tempObj.bottomLeftCircle.startY, tempObj.bottomLeftCircle.radius, 0, 2 * Math.PI);
                canvasDraw.moveTo(tempObj.bottomRightCircle.startX, tempObj.bottomRightCircle.startY);
                canvasDraw.arc(tempObj.bottomRightCircle.startX, tempObj.bottomRightCircle.startY, tempObj.bottomRightCircle.radius, 0, 2 * Math.PI);
                canvasDraw.stroke();
                canvasDraw.fill();
                canvasDraw.closePath();
                canvasDraw.lineWidth /= 2;
                canvasDraw.strokeStyle = strokeColor;
                canvasDraw.fillStyle = fillColor;
            }
        }
        if (parent.selectionSettings.showCircle && (splitWords === undefined || splitWords[0] !== 'crop')) {
            const strokeColor = canvasDraw.strokeStyle;
            const fillColor = canvasDraw.fillStyle;
            canvasDraw.strokeStyle = parent.selectionSettings.strokeColor;
            canvasDraw.fillStyle = parent.selectionSettings.fillColor;
            if (parent.activeObj.shape === 'text') {
                // Text rotation codes
                // canvasDraw.lineWidth *= 2;
                // canvasDraw.beginPath();
                // this.drawRotationArcLine(canvasDraw);
                // canvasDraw.lineTo(parent.activeObj.rotationCirclePoint.x, parent.activeObj.rotationCirclePoint.y);
                // canvasDraw.stroke(); canvasDraw.fill(); canvasDraw.closePath();
                // canvasDraw.beginPath();
                // canvasDraw.moveTo(parent.activeObj.rotationCirclePoint.x, parent.activeObj.rotationCirclePoint.y);
                // canvasDraw.arc(parent.activeObj.rotationCirclePoint.x, parent.activeObj.rotationCirclePoint.y,
                //                parent.activeObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
                // canvasDraw.stroke();
                // canvasDraw.fill();
                // canvasDraw.closePath();
                // canvasDraw.lineWidth /= 2;
            }
            else {
                this.drawCenterCircles(canvasDraw);
            }
            canvasDraw.strokeStyle = strokeColor;
            canvasDraw.fillStyle = fillColor;
        }
        tempObj.rotationCircleLine = parent.activeObj.rotationCircleLine;
        parent.activeObj = extend({}, tempObj, {}, true);
    }
    drawArrowHead(canvasDraw, isStartHead) {
        const headType = isStartHead ? this.parent.activeObj.start : this.parent.activeObj.end;
        switch (headType) {
            case 'arrowSolid':
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                isStartHead ? this.arrowSolid(canvasDraw, true) : this.arrowSolid(canvasDraw, false);
                break;
            case 'arrow':
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                isStartHead ? this.arrow(canvasDraw, true) : this.arrow(canvasDraw, false);
                break;
            case 'circleSolid':
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                isStartHead ? this.arrowCircleSolid(canvasDraw, true) : this.arrowCircleSolid(canvasDraw, false);
                break;
            case 'circle':
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                isStartHead ? this.arrowCircle(canvasDraw, true) : this.arrowCircle(canvasDraw, false);
                break;
            case 'bar':
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                isStartHead ? this.arrowBar(canvasDraw, true) : this.arrowBar(canvasDraw, false);
                break;
            case 'square':
            case 'squareSolid':
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                isStartHead ? this.arrowSquareStart(canvasDraw) : this.arrowSquareEnd(canvasDraw);
                break;
        }
    }
    drawShapeObj(canvas, shape, saveContext, isPreventSelection) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        const currentShape = shape !== undefined ? shape : parent.currObjType.shape;
        parent.currObjType.shape = currentShape;
        let canvasDraw;
        if (canvas.toLowerCase() === 'original') {
            canvasDraw = this.lowerContext;
        }
        else if (canvas.toLowerCase() === 'duplicate') {
            canvasDraw = this.upperContext;
        }
        else if (saveContext) {
            canvasDraw = saveContext;
        }
        if (parent.currObjType.shape.toLowerCase() === 'rectangle' || parent.currObjType.shape.toLowerCase() === 'ellipse'
            || parent.currObjType.shape.toLowerCase() === 'line' || parent.activeObj.shape === 'arrow' ||
            parent.activeObj.shape === 'path') {
            parent.activeObj.shape = parent.currObjType.shape;
        }
        canvasDraw.strokeStyle = parent.activeObj.strokeSettings.strokeColor;
        if (shape === 'text' || shape === 'freehanddraw') {
            canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
        }
        else {
            canvasDraw.fillStyle = parent.activeObj.strokeSettings.fillColor;
        }
        const horLineWidth = actPoint.width / 3;
        const verLineHeight = actPoint.height / 3;
        let selectionWidth = actPoint.endX - actPoint.startX;
        let selectionHeight = actPoint.endY - actPoint.startY;
        this.rotateContext('initial', canvasDraw);
        let degree;
        const tempFillStyle = canvasDraw.fillStyle;
        let activeObj;
        switch (parent.currObjType.shape.toLowerCase()) {
            case 'rectangle':
                this.drawSquareLines(canvasDraw);
                if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'ellipse':
                selectionWidth = Math.abs(selectionWidth);
                selectionHeight = Math.abs(selectionHeight);
                canvasDraw.beginPath();
                canvasDraw.ellipse(actPoint.startX + (selectionWidth / 2), actPoint.startY + (selectionHeight / 2), selectionWidth / 2, selectionHeight / 2, 0, 0, 2 * Math.PI, false);
                if (parent.activeObj.strokeSettings.fillColor !== '') {
                    canvasDraw.fillStyle = parent.activeObj.strokeSettings.fillColor;
                    canvasDraw.fill();
                }
                canvasDraw.ellipse(actPoint.startX + (selectionWidth / 2), actPoint.startY + (selectionHeight / 2), Math.abs((selectionWidth / 2) - (parent.activeObj.strokeSettings.strokeWidth)), Math.abs((selectionHeight / 2) - (parent.activeObj.strokeSettings.strokeWidth)), 0, 0, 2 * Math.PI, false);
                canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
                canvasDraw.fill('evenodd');
                canvasDraw.closePath();
                if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'crop-circle':
                if (canvasDraw === this.lowerContext) {
                    canvasDraw = this.upperContext;
                }
                this.shapeCircle(canvasDraw, selectionWidth, selectionHeight);
                break;
            case 'line':
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
                if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'arrow':
                if (parent.activeObj.shapeDegree === 0) {
                    degree = parent.transform.degree;
                }
                else {
                    degree = parent.transform.degree - parent.activeObj.shapeDegree;
                }
                if (degree < 0) {
                    degree = 360 + degree;
                }
                canvasDraw.fillStyle = canvasDraw.strokeStyle;
                if (isNullOrUndefined(parent.activeObj.triangleDirection)) {
                    parent.activeObj.triangleDirection = 'right';
                }
                if (isNullOrUndefined(parent.activeObj.start)) {
                    parent.activeObj.start = 'none';
                }
                if (isNullOrUndefined(parent.activeObj.end)) {
                    parent.activeObj.end = 'arrowSolid';
                }
                this.drawArrowHead(canvasDraw, true);
                this.drawArrowHead(canvasDraw, false);
                if (parent.activeObj.end === 'none') {
                    this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
                }
                canvasDraw.fillStyle = tempFillStyle;
                if (isNullOrUndefined(isPreventSelection) && canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'path':
                activeObj = extend({}, parent.activeObj, {}, true);
                if (activeObj.pointColl.length > 1) {
                    const obj = { shape: null };
                    parent.notify('selection', { prop: 'getCurrentDrawingShape', value: { obj: obj } });
                    if (obj['shape'] === 'path') {
                        const nextPoint = { x: 0, y: 0 };
                        for (let i = 0, len = activeObj.pointColl.length; i < len; i++) {
                            if (isNullOrUndefined(activeObj.pointColl[i + 1])) {
                                nextPoint.x = activeObj.activePoint.endX;
                                nextPoint.y = activeObj.activePoint.endY;
                            }
                            else {
                                nextPoint.x = activeObj.pointColl[i + 1].x;
                                nextPoint.y = activeObj.pointColl[i + 1].y;
                            }
                            actPoint.startX = activeObj.pointColl[i].x;
                            actPoint.startY = activeObj.pointColl[i].y;
                            actPoint.endX = nextPoint.x;
                            actPoint.endY = nextPoint.y;
                            parent.activeObj = this.updateWidthHeight(parent.activeObj);
                            this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
                        }
                    }
                    else {
                        for (let i = 1, len = activeObj.pointColl.length; i < len; i++) {
                            actPoint.startX = activeObj.pointColl[i - 1].x;
                            actPoint.startY = activeObj.pointColl[i - 1].y;
                            actPoint.endX = activeObj.pointColl[i].x;
                            actPoint.endY = activeObj.pointColl[i].y;
                            parent.activeObj = this.updateWidthHeight(parent.activeObj);
                            this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
                        }
                    }
                    parent.activeObj = activeObj;
                }
                else {
                    this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
                }
                if (canvasDraw === this.upperContext) {
                    this.drawOuterSelection(canvasDraw);
                }
                break;
            case 'text':
                this.shapeText(canvasDraw);
                break;
            case 'crop-square':
            case 'crop-3:4':
            case 'crop-4:3':
            case 'crop-6:9':
            case 'crop-9:6':
            case 'crop-9:16':
            case 'crop-16:9':
                if (canvasDraw === this.lowerContext) {
                    canvasDraw = this.upperContext;
                }
                this.drawSelection(horLineWidth, verLineHeight);
                parent.currObjType.shape = '';
                break;
            default:
                this.drawSelection(horLineWidth, verLineHeight);
                break;
        }
        this.rotateContext('reverse', canvasDraw);
    }
    updatePoints() {
        const parent = this.parent;
        parent.activeObj.activePoint.startX += parent.img.destLeft;
        parent.activeObj.activePoint.startY += parent.img.destTop;
        parent.activeObj.activePoint.endX += parent.img.destLeft;
        parent.activeObj.activePoint.endY += parent.img.destTop;
        parent.activeObj = this.updateWidthHeight(parent.activeObj);
    }
    updateWidthHeight(obj) {
        obj.activePoint.width = obj.activePoint.endX - obj.activePoint.startX;
        obj.activePoint.height = obj.activePoint.endY - obj.activePoint.startY;
        return obj;
    }
    drawCenterCircles(canvasDraw) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        canvasDraw.lineWidth *= 2;
        canvasDraw.beginPath();
        if (parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'line') {
            canvasDraw.moveTo(actPoint.startX, actPoint.startY);
            canvasDraw.arc(actPoint.startX, actPoint.startY, parent.activeObj.topCenterCircle.radius, 0, 2 * Math.PI);
            canvasDraw.moveTo(actPoint.endX, actPoint.endY);
            canvasDraw.arc(actPoint.endX, actPoint.endY, parent.activeObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
        }
        else if (parent.activeObj.shape === 'path') {
            const activeObj = extend({}, parent.activeObj, {}, true);
            if (activeObj.pointColl.length > 1) {
                for (let i = 1, len = activeObj.pointColl.length; i < len; i++) {
                    actPoint.startX = activeObj.pointColl[i - 1].x;
                    actPoint.startY = activeObj.pointColl[i - 1].y;
                    actPoint.endX = activeObj.pointColl[i].x;
                    actPoint.endY = activeObj.pointColl[i].y;
                    canvasDraw.moveTo(actPoint.startX, actPoint.startY);
                    canvasDraw.arc(actPoint.startX, actPoint.startY, parent.activeObj.topCenterCircle.radius, 0, 2 * Math.PI);
                    canvasDraw.moveTo(actPoint.endX, actPoint.endY);
                    canvasDraw.arc(actPoint.endX, actPoint.endY, parent.activeObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
                }
            }
            const obj = { shape: null };
            parent.notify('selection', { prop: 'getCurrentDrawingShape', value: { obj: obj } });
            if (obj['shape'] === 'path') {
                parent.activeObj = activeObj;
            }
            canvasDraw.moveTo(actPoint.startX, actPoint.startY);
            canvasDraw.arc(actPoint.startX, actPoint.startY, parent.activeObj.topCenterCircle.radius, 0, 2 * Math.PI);
            canvasDraw.moveTo(actPoint.endX, actPoint.endY);
            canvasDraw.arc(actPoint.endX, actPoint.endY, parent.activeObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
        }
        else {
            this.drawRotationArcLine(canvasDraw);
            canvasDraw.lineTo(parent.activeObj.rotationCirclePoint.x, parent.activeObj.rotationCirclePoint.y);
        }
        canvasDraw.stroke();
        canvasDraw.fill();
        canvasDraw.closePath();
        if (parent.activeObj.shape !== 'arrow' && parent.activeObj.shape !== 'line' &&
            parent.activeObj.shape !== 'path') {
            canvasDraw.beginPath();
            canvasDraw.moveTo(parent.activeObj.rotationCirclePoint.x, parent.activeObj.rotationCirclePoint.y);
            canvasDraw.arc(parent.activeObj.rotationCirclePoint.x, parent.activeObj.rotationCirclePoint.y, parent.activeObj.bottomCenterCircle.radius, 0, 2 * Math.PI);
            canvasDraw.stroke();
            canvasDraw.fill();
            canvasDraw.closePath();
        }
        canvasDraw.lineWidth /= 2;
    }
    drawRotationArcLine(canvasDraw) {
        const parent = this.parent;
        if (isNullOrUndefined(parent.activeObj.rotationCircleLine)) {
            parent.activeObj.rotationCircleLine = 22.5;
        }
        let degree;
        let isHorizontalflip = false;
        let isVerticalflip = false;
        if (parent.activeObj.shapeDegree === 0) {
            degree = parent.transform.degree;
        }
        else {
            degree = parent.transform.degree - parent.activeObj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        if (parent.activeObj.flipObjColl) {
            for (let i = 0, len = parent.activeObj.flipObjColl.length; i < len; i++) {
                if (parent.activeObj.flipObjColl[i].toLowerCase() === 'horizontal') {
                    isHorizontalflip = true;
                }
                else if (parent.activeObj.flipObjColl[i].toLowerCase() === 'vertical') {
                    isVerticalflip = true;
                }
            }
        }
        switch (degree) {
            case 0:
            case 360:
                if (isVerticalflip) {
                    parent.activeObj.rotationCirclePoint = { x: parent.activeObj.topCenterCircle.startX,
                        y: parent.activeObj.topCenterCircle.startY - parent.activeObj.rotationCircleLine };
                    canvasDraw.moveTo(parent.activeObj.rotationCirclePoint.x, parent.activeObj.rotationCirclePoint.y + parent.activeObj.rotationCircleLine);
                }
                else {
                    parent.activeObj.rotationCirclePoint = { x: parent.activeObj.bottomCenterCircle.startX,
                        y: parent.activeObj.bottomCenterCircle.startY + parent.activeObj.rotationCircleLine };
                    canvasDraw.moveTo(parent.activeObj.rotationCirclePoint.x, parent.activeObj.rotationCirclePoint.y - parent.activeObj.rotationCircleLine);
                }
                break;
            case 90:
            case -270:
                if (isHorizontalflip) {
                    parent.activeObj.rotationCirclePoint = { x: parent.activeObj.centerRightCircle.startX +
                            parent.activeObj.rotationCircleLine, y: parent.activeObj.centerLeftCircle.startY };
                    canvasDraw.moveTo(parent.activeObj.rotationCirclePoint.x - parent.activeObj.rotationCircleLine, parent.activeObj.rotationCirclePoint.y);
                }
                else {
                    parent.activeObj.rotationCirclePoint = { x: parent.activeObj.centerLeftCircle.startX -
                            parent.activeObj.rotationCircleLine, y: parent.activeObj.centerLeftCircle.startY };
                    canvasDraw.moveTo(parent.activeObj.rotationCirclePoint.x + parent.activeObj.rotationCircleLine, parent.activeObj.rotationCirclePoint.y);
                }
                break;
            case 180:
            case -180:
                if (isVerticalflip) {
                    parent.activeObj.rotationCirclePoint = { x: parent.activeObj.bottomCenterCircle.startX,
                        y: parent.activeObj.bottomCenterCircle.startY + parent.activeObj.rotationCircleLine };
                    canvasDraw.moveTo(parent.activeObj.rotationCirclePoint.x, parent.activeObj.rotationCirclePoint.y - parent.activeObj.rotationCircleLine);
                }
                else {
                    parent.activeObj.rotationCirclePoint = { x: parent.activeObj.topCenterCircle.startX,
                        y: parent.activeObj.topCenterCircle.startY - parent.activeObj.rotationCircleLine };
                    canvasDraw.moveTo(parent.activeObj.rotationCirclePoint.x, parent.activeObj.rotationCirclePoint.y + parent.activeObj.rotationCircleLine);
                }
                break;
            case 270:
            case -90:
                if (isHorizontalflip) {
                    parent.activeObj.rotationCirclePoint = { x: parent.activeObj.centerLeftCircle.startX -
                            parent.activeObj.rotationCircleLine, y: parent.activeObj.centerLeftCircle.startY };
                    canvasDraw.moveTo(parent.activeObj.rotationCirclePoint.x + parent.activeObj.rotationCircleLine, parent.activeObj.rotationCirclePoint.y);
                }
                else {
                    parent.activeObj.rotationCirclePoint = { x: parent.activeObj.centerRightCircle.startX +
                            parent.activeObj.rotationCircleLine, y: parent.activeObj.centerLeftCircle.startY };
                    canvasDraw.moveTo(parent.activeObj.rotationCirclePoint.x - parent.activeObj.rotationCircleLine, parent.activeObj.rotationCirclePoint.y);
                }
                break;
        }
    }
    drawSquareLines(canvasDraw) {
        let splitWords;
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (splitWords[0] === 'crop') {
            canvasDraw.strokeStyle = '#fff';
        }
        else {
            canvasDraw.strokeStyle = parent.activeObj.strokeSettings.strokeColor;
        }
        canvasDraw.beginPath();
        canvasDraw.rect(actPoint.startX, actPoint.startY, actPoint.width, actPoint.height);
        if (parent.activeObj.strokeSettings.fillColor !== '') {
            canvasDraw.fillStyle = parent.activeObj.strokeSettings.fillColor;
            canvasDraw.fill();
        }
        canvasDraw.rect(actPoint.startX + parent.activeObj.strokeSettings.strokeWidth, actPoint.startY + parent.activeObj.strokeSettings.strokeWidth, actPoint.width - (2 * parent.activeObj.strokeSettings.strokeWidth), actPoint.height - (2 * parent.activeObj.strokeSettings.strokeWidth));
        canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
        canvasDraw.fill('evenodd');
        canvasDraw.closePath();
    }
    drawSelection(horLineWidth, verLineHeight) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        this.upperContext.strokeStyle = parent.themeColl[parent.theme]['primaryColor'];
        this.upperContext.beginPath();
        parent.activeObj.horTopInnerLine = { startX: actPoint.startX, startY: actPoint.startY +
                verLineHeight, endX: actPoint.endX, endY: actPoint.endY + verLineHeight };
        parent.activeObj.horBottomInnerLine = { startX: actPoint.startX, startY: actPoint.startY + (2 * verLineHeight), endX: actPoint.endX, endY: actPoint.endY + (2 * verLineHeight) };
        parent.activeObj.verLeftInnerLine = { startX: actPoint.startX + horLineWidth,
            startY: actPoint.startY, endX: actPoint.startX + horLineWidth,
            endY: actPoint.endY };
        parent.activeObj.verRightInnerLine = { startX: actPoint.startX + (2 * horLineWidth),
            startY: actPoint.startY, endX: actPoint.startX + (2 * horLineWidth),
            endY: actPoint.endY };
        this.upperContext.moveTo(parent.activeObj.horTopInnerLine.startX, parent.activeObj.horTopInnerLine.startY);
        this.upperContext.lineTo(parent.activeObj.horTopInnerLine.endX, parent.activeObj.horTopInnerLine.startY);
        this.upperContext.moveTo(parent.activeObj.horBottomInnerLine.startX, parent.activeObj.horBottomInnerLine.startY);
        this.upperContext.lineTo(parent.activeObj.horBottomInnerLine.endX, parent.activeObj.horBottomInnerLine.startY);
        this.upperContext.moveTo(parent.activeObj.verLeftInnerLine.startX, parent.activeObj.verLeftInnerLine.startY);
        this.upperContext.lineTo(parent.activeObj.verLeftInnerLine.endX, parent.activeObj.verLeftInnerLine.endY);
        this.upperContext.moveTo(parent.activeObj.verRightInnerLine.startX, parent.activeObj.verRightInnerLine.startY);
        this.upperContext.lineTo(parent.activeObj.verRightInnerLine.endX, parent.activeObj.verRightInnerLine.endY);
        this.upperContext.stroke();
        this.upperContext.closePath();
    }
    shapeCircle(canvasDraw, selectionWidth, selectionHeight) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        canvasDraw.strokeStyle = parent.themeColl[parent.theme]['primaryColor'];
        canvasDraw.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        canvasDraw.fillStyle = 'rgb(0, 0, 0, 0.25)';
        canvasDraw.fillRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        const tempWidth = canvasDraw.lineWidth;
        canvasDraw.lineWidth = (2);
        canvasDraw.beginPath();
        canvasDraw.ellipse(parent.activeObj.horTopLine.startX + (selectionWidth / 2), parent.activeObj.horTopLine.startY
            + (selectionHeight / 2), selectionWidth / 2, selectionHeight / 2, 0, 0, 2 * Math.PI, false);
        canvasDraw.stroke();
        canvasDraw.closePath();
        canvasDraw.save();
        canvasDraw.beginPath();
        canvasDraw.arc(((actPoint.endX - actPoint.startX) / 2) + actPoint.startX, ((actPoint.endY - actPoint.startY) / 2) + actPoint.startY, (actPoint.width / 2), 0, Math.PI * 2);
        canvasDraw.closePath();
        canvasDraw.clip();
        canvasDraw.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        canvasDraw.restore();
        canvasDraw.lineWidth = tempWidth;
        this.drawOuterSelection(canvasDraw, true);
        parent.currObjType.shape = '';
    }
    shapeLine(canvasDraw, x1, y1, x2, y2) {
        const tempLineWidth = canvasDraw.lineWidth;
        canvasDraw.lineWidth = (this.parent.activeObj.strokeSettings.strokeWidth);
        canvasDraw.beginPath();
        canvasDraw.moveTo(x1, y1);
        canvasDraw.lineTo(x2, y2);
        canvasDraw.stroke();
        canvasDraw.lineWidth = tempLineWidth;
    }
    manipulateSaveCtx(canvasDraw, x, y) {
        if (canvasDraw !== this.lowerContext && canvasDraw !== this.upperContext) {
            const obj = { width: 0, height: 0 };
            this.parent.notify('crop', { prop: 'calcRatio', onPropertyChange: false,
                value: { obj: obj, dimension: { width: canvasDraw.canvas.width, height: canvasDraw.canvas.height } } });
            const ratio = obj;
            if (x) {
                x *= (ratio.width);
            }
            if (y) {
                y *= (ratio.height);
            }
        }
        return { x: x, y: y };
    }
    arrow(canvasDraw, start) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        canvasDraw.lineWidth = (parent.activeObj.strokeSettings.strokeWidth);
        let x = this.arrowDimension['arrow']['width'];
        let y = this.arrowDimension['arrow']['height'];
        const point = this.manipulateSaveCtx(canvasDraw, x, y);
        x = point.x + parent.activeObj.strokeSettings.strokeWidth;
        y = point.y + parent.activeObj.strokeSettings.strokeWidth;
        this.dx = actPoint.endX - actPoint.startX;
        this.dy = actPoint.endY - actPoint.startY;
        canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
        const angle = Math.atan2(this.dy, this.dx);
        if ((start && (parent.activeObj.triangleDirection === 'left' || parent.activeObj.triangleDirection === 'right')
            && (parent.activeObj.start === 'arrow' && parent.activeObj.end === 'none')
            || (parent.activeObj.start === 'arrow' && parent.activeObj.end !== 'circle'
                && parent.activeObj.end !== 'square')) ||
            (!start && (parent.activeObj.end === 'arrow' && parent.activeObj.start === 'none'
                || parent.activeObj.start !== 'circle' && parent.activeObj.start !== 'square'))) {
            this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
        }
        if ((start && parent.activeObj.triangleDirection === 'left') ||
            (!start && parent.activeObj.triangleDirection === 'right')) {
            canvasDraw.translate(actPoint.endX, actPoint.endY);
            canvasDraw.rotate(angle);
            this.shapeLine(canvasDraw, 0, 0, -x, y / 2);
            this.shapeLine(canvasDraw, 0, 0, -x, -y / 2);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-actPoint.endX, -actPoint.endY);
        }
        else if ((start && parent.activeObj.triangleDirection === 'right') ||
            (!start && parent.activeObj.triangleDirection === 'left')) {
            canvasDraw.translate(actPoint.startX, actPoint.startY);
            canvasDraw.rotate(angle);
            this.shapeLine(canvasDraw, 0, 0, x, y / 2);
            this.shapeLine(canvasDraw, 0, 0, x, -y / 2);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-actPoint.startX, -actPoint.startY);
        }
    }
    arrowSolid(canvasDraw, start) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        let x = this.arrowDimension['arrowSolid']['width'];
        let y = this.arrowDimension['arrowSolid']['height'];
        const point = this.manipulateSaveCtx(canvasDraw, x, y);
        x = point.x + parent.activeObj.strokeSettings.strokeWidth;
        y = point.y + parent.activeObj.strokeSettings.strokeWidth;
        this.dx = actPoint.endX - actPoint.startX;
        this.dy = actPoint.endY - actPoint.startY;
        const angle = Math.atan2(this.dy, this.dx);
        if ((start && (parent.activeObj.start === 'arrowSolid' && parent.activeObj.end === 'none')
            || (parent.activeObj.start === 'arrowSolid' && parent.activeObj.end !== 'circle' && parent.activeObj.end !== 'square')) ||
            (!start && (parent.activeObj.end === 'arrowSolid' && parent.activeObj.start === 'none'
                || parent.activeObj.start !== 'circle' && parent.activeObj.start !== 'square'))) {
            this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
        }
        if ((start && parent.activeObj.triangleDirection === 'left') ||
            (!start && parent.activeObj.triangleDirection === 'right')) {
            canvasDraw.translate(actPoint.endX, actPoint.endY);
            canvasDraw.rotate(angle);
            canvasDraw.beginPath();
            canvasDraw.moveTo(parent.activeObj.strokeSettings.strokeWidth, 0);
            canvasDraw.lineTo(-x + y / 2, y / 2);
            canvasDraw.lineTo(-x + y / 2, -y / 2);
            canvasDraw.closePath();
            canvasDraw.fill();
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-actPoint.endX, -actPoint.endY);
            parent.activeObj.rotatedAngle = angle;
        }
        else if ((start && parent.activeObj.triangleDirection === 'right') ||
            (!start && parent.activeObj.triangleDirection === 'left')) {
            canvasDraw.translate(actPoint.startX, actPoint.startY);
            canvasDraw.rotate(angle);
            canvasDraw.beginPath();
            canvasDraw.moveTo(0 - parent.activeObj.strokeSettings.strokeWidth, 0);
            canvasDraw.lineTo(x - y / 2, y / 2);
            canvasDraw.lineTo(x - y / 2, -y / 2);
            canvasDraw.closePath();
            canvasDraw.fill();
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-actPoint.startX, -actPoint.startY);
            parent.activeObj.rotatedAngle = angle;
        }
    }
    arrowSquareStart(canvasDraw) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        if ((parent.activeObj.start === 'square' && parent.activeObj.end === 'none')
            || (parent.activeObj.start === 'square' && parent.activeObj.end !== 'circle'
                && parent.activeObj.start !== 'square') || (parent.activeObj.start === 'squareSolid' && parent.activeObj.end === 'circleSolid')) {
            this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
        }
        canvasDraw.lineWidth = (parent.activeObj.strokeSettings.strokeWidth);
        canvasDraw.beginPath();
        canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
        let x = this.arrowDimension['square']['width'];
        let y = this.arrowDimension['square']['height'];
        const point = this.manipulateSaveCtx(canvasDraw, x, y);
        x = point.x + parent.activeObj.strokeSettings.strokeWidth;
        y = point.y + parent.activeObj.strokeSettings.strokeWidth;
        this.dx = actPoint.endX - actPoint.startX;
        this.dy = actPoint.endY - actPoint.startY;
        const angle = Math.atan2(this.dy, this.dx);
        if (parent.activeObj.triangleDirection === 'left') {
            canvasDraw.translate(actPoint.endX, actPoint.endY);
            canvasDraw.rotate(angle);
            if (parent.activeObj.start === 'squareSolid') {
                canvasDraw.fillRect(-x + y / 2, -y / 2, x, y);
            }
            canvasDraw.strokeRect(-x + y / 2, -y / 2, x, y);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-actPoint.endX, -actPoint.endY);
            this.squareStartIntersectX1 = actPoint.endX - (y / 2) * Math.cos(angle);
            this.squareStartIntersectY1 = actPoint.endY - (y / 2) * Math.sin(angle);
            if (parent.activeObj.start === 'square' && parent.activeObj.end !== 'square'
                && parent.activeObj.end !== 'circle' && parent.activeObj.end !== 'square') {
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, this.squareStartIntersectX1, this.squareStartIntersectY1);
            }
            if (parent.activeObj.start === 'square' && parent.activeObj.end === 'circle') {
                this.shapeLine(canvasDraw, this.endCircleIntersectX1, this.endCircleIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
            }
            if (parent.activeObj.start === 'squareSolid' && parent.activeObj.end === 'squareSolid') {
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
            }
        }
        else if (parent.activeObj.triangleDirection === 'right') {
            canvasDraw.lineWidth = (parent.activeObj.strokeSettings.strokeWidth);
            canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
            if (parent.activeObj.start === 'squareSolid' && parent.activeObj.end === 'squareSolid') {
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
            }
            canvasDraw.translate(actPoint.startX, actPoint.startY);
            canvasDraw.rotate(angle);
            if (parent.activeObj.start === 'squareSolid') {
                canvasDraw.fillRect(y / 2 - x, -y / 2, x, y);
            }
            canvasDraw.strokeRect(y / 2 - x, -y / 2, x, y);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-actPoint.startX, -actPoint.startY);
            parent.activeObj.rotatedAngle = angle;
            this.squareStartIntersectX1 = actPoint.startX + (y / 2) * Math.cos(angle);
            this.squareStartIntersectY1 = actPoint.startY + (y / 2) * Math.sin(angle);
            if (parent.activeObj.start === 'square' && parent.activeObj.end !== 'square'
                && parent.activeObj.end !== 'circle' && parent.activeObj.end !== 'square') {
                this.shapeLine(canvasDraw, actPoint.endX, actPoint.endY, this.squareStartIntersectX1, this.squareStartIntersectY1);
            }
            if (parent.activeObj.start === 'square' && parent.activeObj.end === 'circle') {
                this.shapeLine(canvasDraw, this.endCircleIntersectX1, this.endCircleIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
            }
        }
    }
    arrowSquareEnd(canvasDraw) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        let x = this.arrowDimension['square']['width'];
        let y = this.arrowDimension['square']['height'];
        const point = this.manipulateSaveCtx(canvasDraw, x, y);
        x = point.x + parent.activeObj.strokeSettings.strokeWidth;
        y = point.y + parent.activeObj.strokeSettings.strokeWidth;
        this.dx = actPoint.endX - actPoint.startX;
        this.dy = actPoint.endY - actPoint.startY;
        const angle = Math.atan2(this.dy, this.dx);
        canvasDraw.lineWidth = (parent.activeObj.strokeSettings.strokeWidth);
        if (parent.activeObj.triangleDirection === 'right') {
            canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
            if (parent.activeObj.end === 'squareSolid' && parent.activeObj.start === 'none') {
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
            }
            canvasDraw.translate(actPoint.endX, actPoint.endY);
            canvasDraw.rotate(angle);
            if (parent.activeObj.end === 'squareSolid') {
                canvasDraw.fillRect(-x + y / 2, -y / 2, x, y);
            }
            canvasDraw.strokeRect(-x + y / 2, -y / 2, x, y);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-actPoint.endX, -actPoint.endY);
            parent.activeObj.rotatedAngle = angle;
            this.squareEndIntersectX1 = actPoint.endX - (y / 2) * Math.cos(angle);
            this.squareEndIntersectY1 = actPoint.endY - (y / 2) * Math.sin(angle);
            if (parent.activeObj.end === 'square' && parent.activeObj.start !== 'square' && parent.activeObj.start !== 'circle'
                && parent.activeObj.end === 'square') {
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, this.squareEndIntersectX1, this.squareEndIntersectY1);
            }
            else if ((parent.activeObj.start === 'circle') && parent.activeObj.end === 'square') {
                this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.startCircleIntersectX1, this.startCircleIntersectY1);
            }
            else if ((parent.activeObj.start === 'square') && parent.activeObj.end === 'square') {
                this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
            }
        }
        else if (parent.activeObj.triangleDirection === 'left') {
            canvasDraw.translate(actPoint.startX, actPoint.startY);
            canvasDraw.rotate(angle);
            if (parent.activeObj.end === 'squareSolid') {
                canvasDraw.fillRect(y / 2 - x, -y / 2, x, y);
            }
            canvasDraw.strokeRect(y / 2 - x, -y / 2, x, y);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-actPoint.startX, -actPoint.startY);
            parent.activeObj.rotatedAngle = angle;
            this.squareEndIntersectX1 = actPoint.startX + (y / 2) * Math.cos(angle);
            this.squareEndIntersectY1 = actPoint.startY + (y / 2) * Math.sin(angle);
            if (parent.activeObj.end === 'square' && parent.activeObj.start !== 'square' &&
                parent.activeObj.start !== 'circle' && parent.activeObj.end === 'square') {
                this.shapeLine(canvasDraw, actPoint.endX, actPoint.endY, this.squareEndIntersectX1, this.squareEndIntersectY1);
            }
            else if ((parent.activeObj.start === 'circle') && parent.activeObj.end === 'square') {
                this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.startCircleIntersectX1, this.startCircleIntersectY1);
            }
            else if ((parent.activeObj.start === 'square') && parent.activeObj.end === 'square') {
                this.shapeLine(canvasDraw, this.squareEndIntersectX1, this.squareEndIntersectY1, this.squareStartIntersectX1, this.squareStartIntersectY1);
            }
        }
    }
    arrowCircle(canvasDraw, start) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        if ((start && parent.activeObj.triangleDirection === 'left') ||
            (!start && parent.activeObj.triangleDirection === 'right')) {
            canvasDraw.lineWidth = (parent.activeObj.strokeSettings.strokeWidth);
            let circleRadius = this.arrowDimension['circle']['width'];
            const point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
            circleRadius = point.x + parent.activeObj.strokeSettings.strokeWidth;
            canvasDraw.beginPath();
            canvasDraw.arc(actPoint.endX, actPoint.endY, circleRadius, 0, 2 * Math.PI);
            canvasDraw.stroke();
            canvasDraw.closePath();
            this.dx = actPoint.endX - actPoint.startX;
            this.dy = actPoint.endY - actPoint.startY;
            const a = this.dx * this.dx + this.dy * this.dy;
            const b = 2 * (this.dx * (actPoint.startX - actPoint.endX) + this.dy * (actPoint.startY - actPoint.endY));
            const c = (actPoint.startX - actPoint.endX) *
                (actPoint.startX - actPoint.endX) +
                (actPoint.startY - actPoint.endY) *
                    (actPoint.startY - actPoint.endY) - circleRadius * circleRadius;
            const intersect = b * b - 4 * a * c;
            if (intersect >= 0) {
                canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
                const t2 = (-b - Math.sqrt(intersect)) / (2 * a);
                const intersectionX1 = actPoint.startX + this.dx * t2;
                const intersectionY1 = actPoint.startY + this.dy * t2;
                if (start) {
                    this.startCircleIntersectX1 = intersectionX1;
                    this.startCircleIntersectY1 = intersectionY1;
                    canvasDraw.beginPath();
                    canvasDraw.fill();
                    canvasDraw.beginPath();
                    if (parent.activeObj.start === 'circle' && parent.activeObj.end === 'circle') {
                        this.shapeLine(canvasDraw, this.startCircleIntersectX1, this.startCircleIntersectY1, this.endCircleIntersectX1, this.endCircleIntersectY1);
                    }
                    else if (parent.activeObj.start === 'circle' && parent.activeObj.end !== 'circle' && parent.activeObj.end !== 'square') {
                        this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, this.startCircleIntersectX1, this.startCircleIntersectY1);
                    }
                    canvasDraw.stroke();
                    canvasDraw.closePath();
                }
                else {
                    this.endCircleIntersectX1 = intersectionX1;
                    this.endCircleIntersectY1 = intersectionY1;
                    if (parent.activeObj.end === 'circle' && (parent.activeObj.start !== 'circle' && parent.activeObj.start !== 'square')) {
                        this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, this.endCircleIntersectX1, this.endCircleIntersectY1);
                    }
                }
            }
            const angle = Math.atan2(this.dy, this.dx);
            parent.activeObj.rotatedAngle = angle;
        }
        else if ((start && parent.activeObj.triangleDirection === 'right') ||
            (!start && parent.activeObj.triangleDirection === 'left')) {
            canvasDraw.lineWidth = (parent.activeObj.strokeSettings.strokeWidth);
            let circleRadius = this.arrowDimension['circle']['width'];
            const point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
            circleRadius = point.x + parent.activeObj.strokeSettings.strokeWidth;
            canvasDraw.beginPath();
            canvasDraw.arc(actPoint.startX, actPoint.startY, circleRadius, 0, 2 * Math.PI);
            canvasDraw.stroke();
            canvasDraw.closePath();
            this.dx = actPoint.startX - actPoint.endX;
            this.dy = actPoint.startY - actPoint.endY;
            const a = this.dx * this.dx + this.dy * this.dy;
            const b = 2 * (this.dx * (actPoint.endX - actPoint.startX) +
                this.dy * (actPoint.endY - actPoint.startY));
            const c = (actPoint.endX - actPoint.startX) *
                (actPoint.endX - actPoint.startX) +
                (actPoint.endY - actPoint.startY) *
                    (actPoint.endY - actPoint.startY) - circleRadius * circleRadius;
            const intersect = b * b - 4 * a * c;
            if (intersect >= 0) {
                canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
                const t2 = (-b - Math.sqrt(intersect)) / (2 * a);
                const intersectionX1 = actPoint.endX + this.dx * t2;
                const intersectionY1 = actPoint.endY + this.dy * t2;
                if (start) {
                    this.startCircleIntersectX1 = intersectionX1;
                    this.startCircleIntersectY1 = intersectionY1;
                    if (parent.activeObj.start === 'circle' && parent.activeObj.end === 'circle') {
                        this.shapeLine(canvasDraw, this.endCircleIntersectX1, this.endCircleIntersectY1, this.startCircleIntersectX1, this.startCircleIntersectY1);
                    }
                    else if (parent.activeObj.start === 'circle' && parent.activeObj.end !== 'circle' && parent.activeObj.end !== 'square') {
                        this.shapeLine(canvasDraw, actPoint.endX, actPoint.endY, this.startCircleIntersectX1, this.startCircleIntersectY1);
                    }
                }
                else {
                    this.endCircleIntersectX1 = intersectionX1;
                    this.endCircleIntersectY1 = intersectionY1;
                    canvasDraw.beginPath();
                    canvasDraw.fill();
                    canvasDraw.beginPath();
                    if (parent.activeObj.end === 'circle' && (parent.activeObj.start !== 'circle' && parent.activeObj.start !== 'square')) {
                        this.shapeLine(canvasDraw, actPoint.endX, actPoint.endY, this.endCircleIntersectX1, this.endCircleIntersectY1);
                    }
                }
            }
            const angle = Math.atan2(this.dy, this.dx);
            parent.activeObj.rotatedAngle = angle;
        }
    }
    arrowCircleSolid(canvasDraw, start) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        if ((start && parent.activeObj.triangleDirection === 'left') ||
            (!start && parent.activeObj.triangleDirection === 'right')) {
            canvasDraw.lineWidth = (parent.activeObj.strokeSettings.strokeWidth);
            canvasDraw.beginPath();
            canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
            if ((start && (parent.activeObj.start === 'circleSolid' && parent.activeObj.end === 'none') ||
                (parent.activeObj.start === 'circleSolid' && parent.activeObj.end !== 'circle' && parent.activeObj.end !== 'square')) ||
                (!start && (parent.activeObj.end === 'circleSolid' && parent.activeObj.start === 'none'))) {
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
            }
            let circleRadius = this.arrowDimension['circle']['width'];
            const point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
            circleRadius = point.x + parent.activeObj.strokeSettings.strokeWidth;
            this.dx = actPoint.endX - actPoint.startX;
            this.dy = actPoint.endY - actPoint.startY;
            canvasDraw.save();
            canvasDraw.beginPath();
            canvasDraw.arc(actPoint.endX, actPoint.endY, circleRadius, 0, 2 * Math.PI);
            canvasDraw.stroke();
            canvasDraw.fill();
            canvasDraw.closePath();
            parent.activeObj.rotatedAngle = Math.atan2(this.dy, this.dx);
        }
        else if ((start && parent.activeObj.triangleDirection === 'right') ||
            (!start && parent.activeObj.triangleDirection === 'left')) {
            canvasDraw.lineWidth = (parent.activeObj.strokeSettings.strokeWidth);
            canvasDraw.beginPath();
            canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
            if ((start && (parent.activeObj.start === 'circleSolid' && parent.activeObj.end === 'none') ||
                (parent.activeObj.start === 'circleSolid' && parent.activeObj.end !== 'circle' && parent.activeObj.end !== 'square')) ||
                !start && (parent.activeObj.end === 'circleSolid' && parent.activeObj.start === 'none')) {
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
            }
            let circleRadius = this.arrowDimension['circle']['width'];
            const point = this.manipulateSaveCtx(canvasDraw, circleRadius, null);
            circleRadius = point.x + parent.activeObj.strokeSettings.strokeWidth;
            this.dx = actPoint.endX - actPoint.startX;
            this.dy = actPoint.endY - actPoint.startY;
            canvasDraw.save();
            canvasDraw.beginPath();
            canvasDraw.arc(actPoint.startX, actPoint.startY, circleRadius, 0, 2 * Math.PI);
            canvasDraw.stroke();
            canvasDraw.fill();
            canvasDraw.closePath();
            parent.activeObj.rotatedAngle = Math.atan2(this.dy, this.dx);
        }
    }
    arrowBar(canvasDraw, start) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        if ((start && parent.activeObj.triangleDirection === 'left') ||
            (!start && parent.activeObj.triangleDirection === 'right')) {
            canvasDraw.lineWidth = (parent.activeObj.strokeSettings.strokeWidth);
            canvasDraw.beginPath();
            canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
            if ((start && (parent.activeObj.start === 'bar' && parent.activeObj.end === 'none') ||
                (parent.activeObj.start === 'bar' && (parent.activeObj.end !== 'circle' && parent.activeObj.end !== 'square'))) ||
                (!start && ((parent.activeObj.end === 'bar' && parent.activeObj.start === 'none') ||
                    (parent.activeObj.end === 'bar' && (parent.activeObj.start !== 'circle' && parent.activeObj.start !== 'square'))))) {
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
            }
            let x = this.arrowDimension['bar']['width'];
            let y = this.arrowDimension['bar']['height'];
            const point = this.manipulateSaveCtx(canvasDraw, x, y);
            x = point.x + parent.activeObj.strokeSettings.strokeWidth;
            y = point.y + parent.activeObj.strokeSettings.strokeWidth;
            this.dx = actPoint.endX - actPoint.startX;
            this.dy = actPoint.endY - actPoint.startY;
            const angle = Math.atan2(this.dy, this.dx);
            canvasDraw.translate(actPoint.endX, actPoint.endY);
            canvasDraw.rotate(angle);
            canvasDraw.fillRect(-x + y / 4, -y / 2, x, y);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-actPoint.endX, -actPoint.endY);
            parent.activeObj.rotatedAngle = angle;
        }
        else if ((start && parent.activeObj.triangleDirection === 'right') ||
            (!start && parent.activeObj.triangleDirection === 'left')) {
            canvasDraw.lineWidth = (parent.activeObj.strokeSettings.strokeWidth);
            canvasDraw.beginPath();
            canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
            if ((start && (parent.activeObj.start === 'bar' && parent.activeObj.end === 'none')
                || (parent.activeObj.start === 'bar' && (parent.activeObj.end !== 'circle' && parent.activeObj.end !== 'square'))) ||
                (!start && (parent.activeObj.end === 'bar' && parent.activeObj.start === 'none'))) {
                this.shapeLine(canvasDraw, actPoint.startX, actPoint.startY, actPoint.endX, actPoint.endY);
            }
            let x = this.arrowDimension['bar']['width'];
            let y = this.arrowDimension['bar']['height'];
            const point = this.manipulateSaveCtx(canvasDraw, x, y);
            x = point.x + parent.activeObj.strokeSettings.strokeWidth;
            y = point.y + parent.activeObj.strokeSettings.strokeWidth;
            this.dx = actPoint.endX - actPoint.startX;
            this.dy = actPoint.endY - actPoint.startY;
            const angle = Math.atan2(this.dy, this.dx);
            canvasDraw.translate(actPoint.startX, actPoint.startY);
            canvasDraw.rotate(angle);
            canvasDraw.fillRect(y / 4 - x, -y / 2, x, y);
            canvasDraw.rotate(-angle);
            canvasDraw.translate(-actPoint.startX, -actPoint.startY);
            parent.activeObj.rotatedAngle = angle;
        }
    }
    shapeText(canvasDraw) {
        const parent = this.parent;
        let actPoint = parent.activeObj.activePoint;
        const rows = parent.activeObj.keyHistory.split('\n');
        const height = parent.activeObj.textSettings.fontSize + parent.activeObj.textSettings.fontSize * 0.25;
        const lineHeight = ((height * rows.length) - (parent.activeObj.textSettings.fontSize * rows.length)) / rows.length;
        for (let i = 0; i < rows.length; i++) {
            const text = rows[i];
            const yPoint = ((i + 1) * parent.activeObj.textSettings.fontSize * 0.85) + (i * lineHeight);
            if (parent.transform.degree === -360) {
                parent.transform.degree = 0;
            }
            if (parent.transform.degree === 0 || parent.transform.degree === 180) {
                if (parent.activeObj.textSettings.fontSize > actPoint.height) {
                    parent.activeObj.textSettings.fontSize = actPoint.height -
                        (actPoint.height * 0.1);
                }
            }
            else {
                if (parent.activeObj.textSettings.fontSize > actPoint.width) {
                    parent.activeObj.textSettings.fontSize = actPoint.width -
                        (actPoint.width * 0.1);
                }
            }
            canvasDraw.strokeStyle = parent.activeObj.strokeSettings.strokeColor;
            canvasDraw.fillStyle = parent.activeObj.strokeSettings.strokeColor;
            let textStyle = '';
            if (parent.activeObj.textSettings.bold) {
                textStyle = 'bold ';
            }
            if (parent.activeObj.textSettings.italic) {
                textStyle = 'italic ';
            }
            if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
                textStyle = 'italic bold ';
            }
            canvasDraw.font = textStyle + parent.activeObj.textSettings.fontSize + 'px' + ' ' +
                parent.activeObj.textSettings.fontFamily;
            if (parent.activeObj.flipObjColl.length === 4) {
                parent.activeObj.flipObjColl = [];
                parent.activeObj.shapeFlip = '';
            }
            for (let j = 0, len = parent.activeObj.flipObjColl.length; j < len; j++) {
                if (parent.activeObj.flipObjColl[j].toLowerCase() === 'horizontal') {
                    canvasDraw.translate(canvasDraw.canvas.width, 0);
                    canvasDraw.scale(-1, 1);
                    actPoint = this.updateActPoint('horizontal', canvasDraw);
                }
                else if (parent.activeObj.flipObjColl[j].toLowerCase() === 'vertical') {
                    canvasDraw.translate(0, canvasDraw.canvas.height);
                    canvasDraw.scale(1, -1);
                    actPoint = this.updateActPoint('vertical', canvasDraw);
                }
            }
            if (parent.activeObj.shapeDegree !== parent.transform.degree) {
                this.rotateText(canvasDraw);
            }
            else {
                canvasDraw.fillText(text, actPoint.startX + parent.activeObj.textSettings.fontSize * 0.1, actPoint.startY + yPoint);
            }
            for (let k = 0, len = parent.activeObj.flipObjColl.length; k < len; k++) {
                if (parent.activeObj.flipObjColl[k].toLowerCase() === 'horizontal') {
                    canvasDraw.translate(canvasDraw.canvas.width, 0);
                    canvasDraw.scale(-1, 1);
                    actPoint = this.updateActPoint('horizontal', canvasDraw);
                }
                else if (parent.activeObj.flipObjColl[k].toLowerCase() === 'vertical') {
                    canvasDraw.translate(0, canvasDraw.canvas.height);
                    canvasDraw.scale(1, -1);
                    actPoint = this.updateActPoint('vertical', canvasDraw);
                }
            }
        }
        parent.currObjType.isText = false;
    }
    updateActPoint(degree, canvasDraw) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        if (degree.toLowerCase() === 'horizontal') {
            if (actPoint.startX <= canvasDraw.canvas.width / 2) {
                actPoint.startX = canvasDraw.canvas.width / 2 + ((canvasDraw.canvas.width / 2) -
                    actPoint.endX);
                actPoint.endX = actPoint.startX +
                    actPoint.width;
                this.updateActiveObject(actPoint, parent.activeObj);
            }
            else if (actPoint.startX >= canvasDraw.canvas.width / 2) {
                actPoint.startX = canvasDraw.canvas.width - actPoint.endX;
                actPoint.endX = actPoint.startX +
                    actPoint.width;
                this.updateActiveObject(actPoint, parent.activeObj);
            }
        }
        else if (degree.toLowerCase() === 'vertical') {
            if (actPoint.startY <= canvasDraw.canvas.height / 2) {
                actPoint.startY = canvasDraw.canvas.height / 2 + ((canvasDraw.canvas.height / 2) - actPoint.endY);
                actPoint.endY = actPoint.startY + actPoint.height;
                this.updateActiveObject(actPoint, parent.activeObj);
            }
            else if (actPoint.startY >= canvasDraw.canvas.height / 2) {
                actPoint.startY = canvasDraw.canvas.height - actPoint.endY;
                actPoint.endY = actPoint.startY + actPoint.height;
                this.updateActiveObject(actPoint, parent.activeObj);
            }
        }
        return actPoint;
    }
    rotateText(canvasDraw) {
        const parent = this.parent;
        let startX = parent.activeObj.activePoint.startX;
        let startY = parent.activeObj.activePoint.startY;
        let degree;
        const actPoint = parent.activeObj.activePoint;
        if (parent.activeObj.shapeDegree === 0) {
            degree = parent.transform.degree;
        }
        else {
            degree = parent.transform.degree - parent.activeObj.shapeDegree;
        }
        if (degree === -450) {
            degree = -90;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        if (degree % 360 === 0 && (parent.transform.degree !== -360 || parent.transform.currFlipState === '')) {
            startX = actPoint.startX + parent.activeObj.textSettings.fontSize * 0.15;
            startY = actPoint.startY + (actPoint.endY - actPoint.startY);
            const rows = parent.activeObj.keyHistory.split('\n');
            for (let i = 0; i < rows.length; i++) {
                startY = actPoint.startY + (i * parent.activeObj.textSettings.fontSize + parent.activeObj.textSettings.fontSize * 0.25);
                canvasDraw.fillText(rows[i], startX, startY);
            }
        }
        else if (degree % 90 === 0 && degree % 180 !== 0) {
            canvasDraw.translate(parent.lowerCanvas.width / 2, parent.lowerCanvas.height / 2);
            canvasDraw.rotate(Math.PI / 180 * degree);
            canvasDraw.translate(-parent.lowerCanvas.height / 2, -parent.lowerCanvas.width / 2);
            if (degree % 90 === 0 && degree % 270 !== 0) {
                startY = (parent.lowerCanvas.width - actPoint.endX) +
                    parent.activeObj.textSettings.fontSize * 0.4;
                startX = actPoint.startY;
            }
            else if (degree % 270 === 0) {
                startX = parent.lowerCanvas.height - actPoint.endY;
                startY = actPoint.startX + parent.activeObj.textSettings.fontSize * 0.4;
            }
            this.textFlipDegree(canvasDraw, startX, startY);
            canvasDraw.translate(parent.lowerCanvas.height / 2, parent.lowerCanvas.width / 2);
            canvasDraw.rotate(Math.PI / 180 * -degree);
            canvasDraw.translate(-parent.lowerCanvas.width / 2, -parent.lowerCanvas.height / 2);
        }
        else {
            canvasDraw.translate(parent.lowerCanvas.width / 2, parent.lowerCanvas.height / 2);
            canvasDraw.rotate(Math.PI / 180 * degree);
            startX = parent.lowerCanvas.width - actPoint.endX;
            startY = (parent.lowerCanvas.height - actPoint.endY) +
                parent.activeObj.textSettings.fontSize * 0.4;
            canvasDraw.translate(-parent.lowerCanvas.width / 2, -parent.lowerCanvas.height / 2);
            this.textFlipDegree(canvasDraw, startX, startY);
            canvasDraw.translate(parent.lowerCanvas.width / 2, parent.lowerCanvas.height / 2);
            canvasDraw.rotate(Math.PI / 180 * -degree);
            canvasDraw.translate(-parent.lowerCanvas.width / 2, -parent.lowerCanvas.height / 2);
        }
        if (parent.transform.degree === 360 || parent.transform.degree === -360) {
            parent.transform.degree = 0;
        }
    }
    textFlipDegree(canvasDraw, startX, startY) {
        const parent = this.parent;
        const rows = parent.activeObj.keyHistory.split('\n');
        const height = parent.activeObj.textSettings.fontSize;
        const lineHeight = ((height * rows.length) - (parent.activeObj.textSettings.fontSize * rows.length)) / rows.length;
        let yPoint = (parent.activeObj.textSettings.fontSize * 0.85) + lineHeight;
        for (let i = 0; i < rows.length; i++) {
            const text = rows[i];
            if (i > 0) {
                if (i === 1) {
                    yPoint -= (parent.activeObj.textSettings.fontSize * 0.85);
                }
                yPoint += parent.activeObj.textSettings.fontSize + parent.activeObj.textSettings.fontSize * 0.15;
            }
            canvasDraw.fillText(text, startX + parent.activeObj.textSettings.fontSize * 0.15, startY +
                yPoint + (i > 0 ? parent.activeObj.textSettings.fontSize * 0.25 : -parent.activeObj.textSettings.fontSize * 0.35));
        }
    }
    clearOuterCanvas(context) {
        const parent = this.parent;
        const destLeft = parent.img.destLeft;
        const destTop = parent.img.destTop;
        if (parent.img.destWidth < parent.lowerCanvas.width) {
            const left = parent.img.destLeft > 0 ? parent.img.destLeft : 0;
            context.clearRect(0, 0, left, parent.lowerCanvas.height);
            context.clearRect(parent.img.destLeft + parent.img.destWidth, 0, left, parent.lowerCanvas.height);
        }
        if (parent.img.destHeight < parent.lowerCanvas.height) {
            const top = parent.img.destTop > 0 ? parent.img.destTop : 0;
            context.clearRect(0, 0, parent.lowerCanvas.width, top);
            context.clearRect(0, parent.img.destTop + parent.img.destHeight, parent.lowerCanvas.width, top);
        }
        if (parent.transform.currFlipState !== '') {
            parent.img.destLeft = destLeft;
            parent.img.destTop = destTop;
        }
    }
    setDestPoints() {
        let maxDimension;
        const parent = this.parent;
        if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
            const obj = { width: 0, height: 0 };
            parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
                value: { width: parent.img.srcHeight, height: parent.img.srcWidth, obj: obj } });
            maxDimension = obj;
            if (this.isRotateZoom) {
                maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
                maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
                parent.img.destWidth = maxDimension.height;
                parent.img.destHeight = maxDimension.width;
            }
            parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.height) / 2;
            parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.width) / 2;
            parent.img.destWidth = maxDimension.height;
            parent.img.destHeight = maxDimension.width;
        }
        else {
            const obj = { width: 0, height: 0 };
            parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
                value: { width: parent.img.srcWidth, height: parent.img.srcHeight, obj: obj } });
            maxDimension = obj;
            if (this.isRotateZoom) {
                maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
                maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
                parent.img.destWidth = maxDimension.width;
                parent.img.destHeight = maxDimension.height;
            }
            parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
            parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height) / 2;
            parent.img.destWidth = maxDimension.width;
            parent.img.destHeight = maxDimension.height;
        }
    }
    updateCurrTransState(type, isPreventDestination, isRotatePan) {
        const parent = this.parent;
        const destLeft = parent.img.destLeft;
        const destTop = parent.img.destTop;
        if (type === 'initial') {
            this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
            if (isNullOrUndefined(isPreventDestination)) {
                this.setDestPoints();
            }
        }
        this.currTransState(type, null, null, isRotatePan);
        if (parent.transform.degree === 0 && parent.transform.currFlipState === '') {
            parent.img.destLeft = destLeft;
            parent.img.destTop = destTop;
        }
        if (parent.isCircleCrop || (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle')) {
            if (isRotatePan) {
                parent.img.destLeft += parent.panPoint.totalPannedClientPoint.x;
                parent.img.destTop +=
                    parent.panPoint.totalPannedClientPoint.y;
            }
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
            if (isRotatePan) {
                parent.img.destLeft -= parent.panPoint.totalPannedClientPoint.x;
                parent.img.destTop -=
                    parent.panPoint.totalPannedClientPoint.y;
            }
        }
    }
    currTransState(type, isPreventDimension, context, isPreventCircleCrop) {
        const parent = this.parent;
        context = context ? context : this.lowerContext;
        if (type === 'initial') {
            this.setTransformColl(context, type);
        }
        else if (type === 'reverse') {
            this.setTransformColl(context, type);
            this.setClientTransDim(isPreventDimension);
            if (parent.isCircleCrop || (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle'
                && isNullOrUndefined(isPreventCircleCrop))) {
                if (isPreventCircleCrop) {
                    parent.img.destLeft += parent.panPoint.totalPannedClientPoint.x;
                    parent.img.destTop += parent.panPoint.totalPannedClientPoint.y;
                }
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: this.lowerContext, isSave: null, isFlip: null } });
                if (isPreventCircleCrop) {
                    parent.img.destLeft -= parent.panPoint.totalPannedClientPoint.x;
                    parent.img.destTop -= parent.panPoint.totalPannedClientPoint.y;
                }
            }
        }
    }
    setTransformColl(context, type) {
        const parent = this.parent;
        if (type === 'initial') {
            for (let i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
                this.setTransform(context, parent.rotateFlipColl[i]);
            }
        }
        else if (type === 'reverse') {
            for (let i = parent.rotateFlipColl.length - 1; i >= 0; i--) {
                this.setTransform(context, parent.rotateFlipColl[i], true);
            }
        }
    }
    setTransform(context, value, isReverse) {
        const parent = this.parent;
        if (isReverse && value === 90) {
            value = -90;
        }
        else if (isReverse && value === -90) {
            value = 90;
        }
        if (value === 'horizontal' && parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
            value = 'vertical';
        }
        else if (value === 'vertical' && parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
            value = 'horizontal';
        }
        parent.notify('transform', { prop: 'setReverseRotate', onPropertyChange: false, value: { bool: true } });
        parent.notify('transform', { prop: 'setReverseFlip', onPropertyChange: false, value: { isReverseFlip: true } });
        if (isNullOrUndefined(isReverse)) {
            context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        }
        switch (value) {
            case 90:
            case -90:
                context.translate(context.canvas.width / 2, context.canvas.height / 2);
                context.rotate(Math.PI / 180 * value);
                context.translate(-context.canvas.width / 2, -context.canvas.height / 2);
                break;
            case 'horizontal':
                context.translate(context.canvas.width, 0);
                context.scale(-1, 1);
                break;
            case 'vertical':
                context.translate(0, context.canvas.height);
                context.scale(1, -1);
                break;
        }
        parent.notify('transform', { prop: 'setReverseRotate', onPropertyChange: false, value: { bool: false } });
        parent.notify('transform', { prop: 'setReverseFlip', onPropertyChange: false, value: { isReverseFlip: false } });
    }
    drawImgToCanvas(maxDimension) {
        const parent = this.parent;
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.img.destWidth = maxDimension.width;
        parent.img.destHeight = maxDimension.height;
        if (this.isInitialLoading) {
            parent.notify('filter', { prop: 'initFilter', onPropertyChange: false });
            this.isInitialLoading = false;
        }
        const temp = this.lowerContext.filter;
        parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
        this.lowerContext.filter = temp;
    }
    renderImage(isMouseWheel) {
        const parent = this.parent;
        const temp = this.lowerContext.filter;
        parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: null } });
        this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        if (isMouseWheel) {
            this.setTransformColl(this.lowerContext, 'initial');
        }
        else {
            if (parent.transform.zoomFactor > 0) {
                this.isRotateZoom = true;
            }
            this.updateCurrTransState('initial');
        }
        parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        parent.notify('transform', { prop: 'setDestPointsForFlipState', onPropertyChange: false });
        this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        parent.notify('transform', { prop: 'setDestPointsForFlipState', onPropertyChange: false });
        if (isMouseWheel) {
            this.setTransformColl(this.lowerContext, 'reverse');
        }
        else {
            this.updateCurrTransState('reverse');
            this.isRotateZoom = false;
        }
        this.lowerContext.filter = 'none';
        parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
        parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
            value: { context: this.lowerContext, points: null } });
        this.lowerContext.filter = temp;
        if (parent.isCircleCrop || (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle')) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
    }
    imageOnLoad(src) {
        const parent = this.parent;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const proxy = this;
        parent.baseImg.src = src;
        parent.baseImg.onload = () => {
            parent.notify('filter', { prop: 'update-finetunes', onPropertyChange: false });
            proxy.lowerContext.drawImage(parent.baseImg, 0, 0, proxy.parent.lowerCanvas.width, proxy.parent.lowerCanvas.height);
            hideSpinner(parent.element);
            parent.element.style.opacity = '1';
            proxy.updateCanvas();
            if (parent.currObjType.isUndoZoom) {
                parent.currObjType.isUndoZoom = false;
                proxy.parent.lowerCanvas.style.display = 'block';
            }
            parent.isUndoRedo = this.isErrorImage = false;
            if (!isBlazor()) {
                if (Browser.isDevice) {
                    parent.notify('toolbar', { prop: 'destroy-top-toolbar', onPropertyChange: false });
                    parent.notify('toolbar', { prop: 'destroy-bottom-toolbar', onPropertyChange: false });
                    const eventargs = { isApplyBtn: false, isDevice: Browser.isDevice, isOkBtn: null };
                    parent.notify('toolbar', { prop: 'init-main-toolbar', onPropertyChange: false, value: eventargs });
                    parent.notify('toolbar', { prop: 'create-bottom-toolbar', onPropertyChange: false });
                }
                else {
                    parent.notify('toolbar', { prop: 'destroy-top-toolbar', onPropertyChange: false });
                    const eventargs = { isApplyBtn: false, isDevice: false, isOkBtn: null };
                    parent.notify('toolbar', { prop: 'init-main-toolbar', onPropertyChange: false, value: eventargs });
                }
            }
            else {
                parent.updateToolbar(parent.element, 'imageLoaded', 'initial');
                if (Browser.isDevice) {
                    parent.element.querySelector('.e-bottom-toolbar-area').style.display = 'block';
                    parent.element.querySelector('.e-canvas-wrapper').style.height = (parent.element.offsetHeight
                        - parent.toolbarHeight * 2) - 3 + 'px';
                }
            }
        };
        parent.baseImg.onerror = () => {
            hideSpinner(parent.element);
            // proxy.reset();
            // proxy.parent.baseImg.src = proxy.baseImgSrc;
            proxy.isErrorImage = true;
            proxy.errorLoading();
        };
    }
    errorLoading() {
        const parent = this.parent;
        const fileOpened = { fileName: null, fileType: null, isValidImage: false };
        if (isBlazor() && parent.events && parent.events.fileOpened.hasDelegate === true) {
            parent.dotNetRef.invokeMethodAsync('FileOpenEventAsync', 'FileOpened', fileOpened);
        }
        else {
            parent.trigger('fileOpened', fileOpened);
        }
    }
    updateCanvas() {
        const parent = this.parent;
        const fileOpened = { fileName: this.fileName, fileType: this.fileType, isValidImage: true };
        parent.img.srcWidth = parent.baseImg.width;
        parent.img.srcHeight = parent.baseImg.height;
        const obj = { width: 0, height: 0 };
        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: parent.img.srcWidth, height: parent.img.srcHeight, obj: obj } });
        const maxDimension = obj;
        parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
        parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height) / 2;
        this.drawImgToCanvas(maxDimension);
        this.zoomCrop.width = parent.img.destWidth;
        this.zoomCrop.height = parent.img.destHeight;
        parent.notify('transform', { prop: 'setCropDimension', onPropertyChange: false,
            value: { width: parent.img.destWidth, height: parent.img.destHeight } });
        const point = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
            height: parent.img.destHeight };
        parent.notify('crop', { prop: 'setCropDestPoints', onPropertyChange: false, value: { point: point } });
        const temp = this.lowerContext.filter;
        this.lowerContext.filter = 'none';
        parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
        parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
        this.lowerContext.filter = temp;
        if (parent.img.destWidth > 0 && parent.img.destHeight > 0) {
            parent.isImageLoaded = true;
        }
        if (parent.isUndoRedo) {
            if (parent.transform.currFlipState !== '') {
                parent.notify('transform', { prop: 'flipImage', onPropertyChange: false,
                    value: { direction: parent.toPascalCase(parent.transform.currFlipState) } });
            }
        }
        if (parent.disabled) {
            parent.element.setAttribute('class', 'e-disabled');
        }
        if (parent.isImageLoaded && parent.element.style.opacity !== '0.5') {
            if (isBlazor() && parent.events && parent.events.fileOpened.hasDelegate === true) {
                parent.dotNetRef.invokeMethodAsync('FileOpenEventAsync', 'FileOpened', fileOpened);
            }
            else {
                parent.trigger('fileOpened', fileOpened);
            }
        }
        if (parent.zoomSettings.zoomFactor !== 1 || parent.zoomSettings.zoomPoint) {
            parent.zoom(parent.zoomSettings.zoomFactor, parent.zoomSettings.zoomPoint);
        }
        if (isNullOrUndefined(this.initZoomValue)) {
            this.initZoomValue = parent.zoomSettings.zoomFactor;
        }
        this.isImageEdited = false;
    }
    performCancel(isContextualToolbar) {
        const parent = this.parent;
        isContextualToolbar = isContextualToolbar ? isContextualToolbar : false;
        const obj = { bool: false };
        parent.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
        if (obj['bool']) {
            parent.notify('freehand-draw', { prop: 'cancelFhd', onPropertyChange: false });
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
            }
            else {
                parent.updateToolbar(parent.element, 'destroyQuickAccessToolbar');
            }
            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'cancel' } });
        }
        else if (parent.textArea.style.display === 'block') {
            parent.textArea.style.display = 'none';
            parent.textArea.value = '';
            parent.textArea.style.transform = '';
            if (this.prevActObj) {
                parent.activeObj = this.prevActObj;
                this.prevActObj = null;
            }
            else {
                parent.activeObj.strokeSettings = this.tempStrokeSettings;
                parent.activeObj.textSettings = this.tempTextSettings;
            }
            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'cancel' } });
            if (this.isShapeTextInserted) {
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            }
            parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: true } });
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            }
            else {
                parent.updateToolbar(parent.element, 'imageLoaded');
            }
        }
        else if ((!isBlazor() && document.querySelector('#' + parent.element.id + '_sliderWrapper')) || (isBlazor() && !parent.element.querySelector('.e-ie-contextual-slider').classList.contains('e-hidden')) ||
            parent.currObjType.isFiltered) {
            this.lowerContext.filter = this.tempAdjValue;
            parent.canvasFilter = this.tempAdjValue;
            parent.notify('filter', { prop: 'setAdjustmentValue', onPropertyChange: false, value: { adjustmentValue: this.tempAdjValue } });
            parent.initialAdjustmentValue = this.tempAdjValue;
            if (this.lowerContext.filter.split(' ').length > 1 &&
                this.lowerContext.filter.split(' ')[0].split('(')[1].split(')')[0] === '1') {
                parent.notify('filter', { prop: 'setBrightnessAdjusted', onPropertyChange: false, value: { isBrightnessAdjusted: false } });
            }
            parent.currentFilter = this.tempFilter;
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            this.redrawImgWithObj();
            parent.currObjType.isFiltered = false;
            const obj = { tempAdjustmentLevel: null };
            parent.notify('filter', { prop: 'getTempAdjustmentLevel', onPropertyChange: false, value: { obj: obj } });
            parent.notify('filter', { prop: 'setAdjustmentLevel', onPropertyChange: false,
                value: { adjustmentLevel: extend({}, obj['tempAdjustmentLevel'], {}, true) } });
            parent.notify('undo-redo', { prop: 'setUndoRedoStep', onPropertyChange: false, value: { step: this.tempUndoRedoStep } });
            parent.upperCanvas.style.cursor = parent.cursor = 'default';
            parent.currObjType.isCustomCrop = false;
            this.tempStrokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null };
            this.clearOuterCanvas(this.lowerContext);
            if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: this.lowerContext, isSave: null, isFlip: null } });
            }
            const eventargs = { type: 'main', isApplyBtn: null, isCropping: null, isZooming: null };
            if (!isBlazor()) {
                parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: eventargs });
            }
            else {
                parent.updateToolbar(parent.element, 'imageLoaded');
            }
            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'cancel' } });
        }
        else {
            if (isContextualToolbar) {
                const eventargs = { type: 'main', isApplyBtn: null, isCropping: null, isZooming: null };
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: eventargs });
                }
                else {
                    parent.updateToolbar(parent.element, 'imageLoaded');
                }
            }
            else {
                this.cancelItems();
                parent.togglePan = false;
                parent.notify('selection', { prop: 'setDragCanvas', value: { bool: false } });
            }
        }
        this.isShapeTextInserted = false;
        this.isNewPath = false;
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'refresh-dropdown-btn', value: { isDisabled: false } });
            parent.notify('toolbar', { prop: 'setCurrentToolbar', value: { type: 'main' } });
        }
    }
    cancelItems() {
        const parent = this.parent;
        let isCropSelection = false;
        let splitWords;
        const shapes = ['rectangle', 'ellipse', 'line', 'arrow', 'path'];
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (splitWords === undefined && parent.currObjType.isCustomCrop) {
            isCropSelection = true;
        }
        else if (splitWords !== undefined && splitWords[0] === 'crop') {
            isCropSelection = true;
        }
        if (isCropSelection && parent.isCropTab) {
            parent.isCropTab = false;
            parent.transform.zoomFactor = parent.transform.defaultZoomFactor;
        }
        if (parent.togglePen) {
            this.cancelPen();
        }
        else if (parent.activeObj.shape === 'text') {
            this.cancelText(isCropSelection);
        }
        else if (shapes.indexOf(parent.activeObj.shape) !== -1) {
            this.cancelShape();
        }
        else if (isCropSelection) {
            this.cancelSelection();
        }
        else {
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'cancel' } });
        }
        parent.notify('selection', { prop: 'setCurrentDrawingShape', onPropertyChange: false, value: { value: '' } });
        parent.upperCanvas.style.cursor = parent.cursor = 'default';
        parent.currObjType.isCustomCrop = false;
        this.tempStrokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null };
        const eventargs = { type: 'main', isApplyBtn: null, isCropping: false, isZooming: null };
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: eventargs });
        }
        else {
            parent.updateToolbar(parent.element, 'imageLoaded');
        }
    }
    cancelPen() {
        const parent = this.parent;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.togglePen = false;
        parent.upperCanvas.style.cursor = parent.cursor = 'default';
        // eslint-disable-next-line
        const tempPointsColl = extend([], parent.pointColl, [], true);
        parent.pointColl = {};
        for (let i = 0; i < this.tempFreehandCounter; i++) {
            parent.pointColl[i] = tempPointsColl[i];
        }
        parent.freehandCounter = this.tempFreehandCounter;
        parent.notify('freehand-draw', { prop: 'setCurrentFreehandDrawIndex', value: { value: this.tempCurrFhdIndex } });
        parent.activeObj.strokeSettings = this.tempStrokeSettings;
        parent.notify('shape', { prop: 'setStrokeSettings',
            value: { strokeSettings: parent.activeObj.strokeSettings, strokeColor: null, fillColor: null, strokeWidth: null } });
        parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'cancel' } });
        parent.notify('selection', { prop: 'setFreehandDrawCustomized', value: { isFreehandDrawCustomized: false } });
    }
    cancelText(isCropSelection) {
        const parent = this.parent;
        parent.notify('shape', { prop: 'setTextSettings', onPropertyChange: false,
            value: { textSettings: this.tempTextSettings, fontFamily: null, fontSize: null } });
        parent.notify('shape', { prop: 'setStrokeSettings',
            value: { strokeSettings: this.tempStrokeSettings, strokeColor: null, fillColor: null, strokeWidth: null } });
        if (isNullOrUndefined(parent.activeObj.currIndex)) {
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
        else {
            const object = { appliedUndoRedoColl: [] };
            parent.notify('undo-redo', { prop: 'getAppliedUndoRedoColl', value: { obj: object } });
            const len = object['appliedUndoRedoColl'].length;
            if (this.prevActObj && object['appliedUndoRedoColl'][len - 1] &&
                object['appliedUndoRedoColl'][len - 1].currentObjColl[object['appliedUndoRedoColl'][len - 1].currentObjColl.length - 1].currIndex
                    === this.prevActObj.currIndex) {
                parent.activeObj = this.prevActObj;
                this.prevActObj = null;
            }
            else {
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }
            if (parent.activeObj.shape && parent.activeObj.keyHistory === 'Enter Text') {
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                parent.notify('shape', { prop: 'draw-shape-text' });
                parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'cancel' } });
                parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: true } });
            }
            else if (parent.activeObj.shape) {
                parent.notify('shape', { prop: 'redraw-text' });
                parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false, value: { obj: parent.activeObj } });
                if (!isCropSelection && parent.activeObj.topLeftCircle !== undefined) {
                    parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: true } });
                }
                parent.clearSelection();
            }
        }
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
        }
        else {
            parent.updateToolbar(parent.element, 'destroyQuickAccessToolbar');
        }
        this.tempTextSettings = { text: 'Enter Text', fontFamily: 'Arial', fontSize: null, fontRatio: null, bold: false,
            italic: false, underline: false };
    }
    cancelShape() {
        const parent = this.parent;
        parent.notify('shape', { prop: 'setStrokeSettings',
            value: { strokeSettings: this.tempStrokeSettings, strokeColor: null, fillColor: null, strokeWidth: null } });
        if (isNullOrUndefined(parent.activeObj.currIndex)) {
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
        else if (this.isNewPath) {
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            this.renderImage();
        }
        else {
            const object = { appliedUndoRedoColl: [] };
            parent.notify('undo-redo', { prop: 'getAppliedUndoRedoColl', value: { obj: object } });
            const len = object['appliedUndoRedoColl'].length;
            if (this.prevActObj && object['appliedUndoRedoColl'][len - 1] &&
                object['appliedUndoRedoColl'][len - 1].currentObjColl[object['appliedUndoRedoColl'][len - 1].currentObjColl.length - 1].currIndex
                    === this.prevActObj.currIndex) {
                parent.activeObj = this.prevActObj;
                this.prevActObj = null;
                parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false, value: { obj: parent.activeObj } });
                parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'cancel' } });
                parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: true } });
            }
            else {
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }
        }
        parent.currObjType.isDragging = false;
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
        }
        else {
            parent.updateToolbar(parent.element, 'destroyQuickAccessToolbar');
        }
    }
    cancelSelection() {
        const parent = this.parent;
        if (parent.cancelCropSelection) {
            parent.cropObj = extend({}, parent.cancelCropSelection.previousCropObj, {}, true);
            parent.afterCropActions = parent.cancelCropSelection.previousObj.afterCropActions;
            parent.notify('undo-redo', { prop: 'undoDefault', onPropertyChange: false, value: { obj: parent.cancelCropSelection } });
            parent.currSelectionPoint = extend({}, parent.cancelCropSelection.previousCropObj.activeObj, true);
            if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
                parent.currSelectionPoint = null;
            }
            this.clearOuterCanvas(this.lowerContext);
            if (parent.isCircleCrop || (parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle')) {
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: this.lowerContext, isSave: null, isFlip: null } });
            }
        }
    }
    updateFlipPan(tempSelectionObj) {
        const parent = this.parent;
        if (parent.transform.currFlipState !== '') {
            const temp = this.lowerContext.filter;
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.notify('transform', { prop: 'rotatedFlip', onPropertyChange: false });
            this.lowerContext.filter = 'none';
            parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                value: { context: this.lowerContext, points: null } });
            this.lowerContext.filter = temp;
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (tempSelectionObj) {
                this.drawObject('duplicate', tempSelectionObj);
            }
        }
    }
    select(type, startX, startY, width, height) {
        const parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            const object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            const previousObj = object['currObj'];
            previousObj.objColl = extend([], parent.objColl, [], true);
            previousObj.pointColl = extend([], parent.pointColl, [], true);
            previousObj.afterCropActions = parent.afterCropActions;
            const selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            previousObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            parent.notify('crop', { prop: 'setPreviousCropCurrentObj', onPropertyChange: false, value: { obj: previousObj } });
            if (parent.transform.zoomFactor > 0 && parent.activeObj.shape && parent.activeObj.shape.split('-')[0] === 'crop' && isNullOrUndefined(this.currSelPoint)) {
                this.currSelPoint = extend({}, parent.activeObj, {}, true);
            }
            let isPrevent = false;
            let splitWords;
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (splitWords === undefined && parent.currObjType.isCustomCrop) {
                isPrevent = true;
            }
            else if (splitWords !== undefined && splitWords[0] === 'crop') {
                isPrevent = true;
            }
            const obj = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: obj } });
            const prevObj = obj['currObj'];
            prevObj.objColl = extend([], parent.objColl, [], true);
            prevObj.pointColl = extend([], parent.pointColl, [], true);
            prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: null } });
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.notify('shape', { prop: 'setKeyHistory', onPropertyChange: false, value: { keyHistory: '' } });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.upperCanvas.style.display = 'block';
            if (parent.currSelectionPoint || parent.transform.defaultZoomFactor !== 0 ||
                (parent.transform.degree !== 0 && parent.panPoint.totalPannedInternalPoint.x !== 0 &&
                    parent.panPoint.totalPannedInternalPoint.y !== 0 && !isPrevent)) {
                parent.isCircleCrop = false;
                if (parent.transform.defaultZoomFactor !== 0) {
                    const isCropTab = parent.isCropTab;
                    parent.isCropTab = false;
                    parent.notify('transform', { prop: 'resetZoom', onPropertyChange: false });
                    parent.isCropTab = isCropTab;
                    this.resetPanPoints();
                }
                parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
                parent.isCropTab = true;
                parent.isCircleCrop = false;
                parent.notify('crop', { prop: 'setCurrSelPoints', onPropertyChange: false, value: { isSetDimension: true } });
                parent.transform.zoomFactor = parent.transform.cropZoomFactor;
                if (isNullOrUndefined(parent.cropObj.activeObj.shape)) {
                    parent.currObjType.shape = 'crop-' + type.toLowerCase();
                    this.drawNewSelection(type, startX, startY, width, height);
                }
            }
            else {
                if (type === 'custom') {
                    parent.currObjType.shape = '';
                }
                this.drawNewSelection(type, startX, startY, width, height);
            }
        }
    }
    drawNewSelection(type, startX, startY, width, height) {
        const parent = this.parent;
        let points;
        const cropShape = 'crop-' + type;
        if (cropShape.toLowerCase() === 'crop-custom') {
            if (parent.currObjType.shape === '' || parent.currObjType.shape === 'crop-custom') {
                this.drawCustomSelection('crop-custom', startX, startY, width, height);
            }
        }
        else if (cropShape.toLowerCase() === 'crop-canvas') {
            parent.upperCanvas.style.display = 'block';
            parent.notify('selection', { prop: 'setDragCanvas', value: { bool: true } });
        }
        else {
            parent.currObjType.isCustomCrop = false;
            parent.currObjType.shape = cropShape.toLowerCase();
            if (width && height) {
                points = { startX: startX, startY: startY, endX: startX + width, endY: startY + height,
                    width: width, height: height };
            }
            else if (width && cropShape === 'crop-circle') {
                points = { startX: startX, startY: startY, endX: startX + width, endY: startY + width,
                    width: width, height: width };
            }
            parent.activeObj.shape = cropShape.toLowerCase();
            this.updateSelectionInsert(points);
        }
    }
    updateSelectionInsert(points) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        const obj = { shapeSettingsObj: {} };
        parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
        const selectionSettings = { type: parent.getSelectionType(obj['shapeSettingsObj']['type']), startX: obj['shapeSettingsObj']['startX'],
            startY: obj['shapeSettingsObj']['startY'], width: obj['shapeSettingsObj']['width'], height: obj['shapeSettingsObj']['height'] };
        const selectionChangingArgs = { action: 'insert', previousSelectionSettings: selectionSettings,
            currentSelectionSettings: selectionSettings };
        if (isBlazor() && parent.events && parent.events.onSelectionResizeStart.hasDelegate === true) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            parent.dotNetRef.invokeMethodAsync('SelectionEventAsync', 'OnSelectionResizeStart', selectionChangingArgs).then((selectionChangingArgs) => {
                parent.notify('shape', { prop: 'updSelChangeEventArgs', onPropertyChange: false,
                    value: { selectionSettings: selectionChangingArgs.currentSelectionSettings } });
                if (selectionChangingArgs.currentSelectionSettings.type === 'Custom') {
                    this.drawObject('duplicate', parent.activeObj, null, null, true);
                }
                else {
                    if (actPoint.startX !== 0 || actPoint.startY !== 0 ||
                        actPoint.width !== 0 || actPoint.height !== 0) {
                        points = { startX: actPoint.startX, startY: actPoint.startY,
                            endX: actPoint.endX, endY: actPoint.endY,
                            width: actPoint.width, height: actPoint.height };
                    }
                    this.drawObject('duplicate', null, true, points);
                }
            });
        }
        else {
            parent.trigger('selectionChanging', selectionChangingArgs);
            parent.notify('shape', { prop: 'updSelChangeEventArgs', onPropertyChange: false,
                value: { selectionSettings: selectionChangingArgs.currentSelectionSettings } });
            if (selectionChangingArgs.currentSelectionSettings.type === 'Custom') {
                this.drawObject('duplicate', parent.activeObj, null, null, true);
            }
            else {
                if (actPoint.startX !== 0 || actPoint.startY !== 0 ||
                    actPoint.width !== 0 || actPoint.height !== 0) {
                    points = { startX: actPoint.startX, startY: actPoint.startY,
                        endX: actPoint.endX, endY: actPoint.endY,
                        width: actPoint.width, height: actPoint.height };
                }
                this.drawObject('duplicate', null, true, points);
            }
        }
    }
    drawCustomSelection(cropShape, startX, startY, width, height) {
        const parent = this.parent;
        const actPoint = parent.activeObj.activePoint;
        parent.currObjType.isCustomCrop = true;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.currObjType.shape = parent.activeObj.shape = cropShape.toLowerCase();
        if (!isNullOrUndefined(startX) && !isNullOrUndefined(startY) && !isNullOrUndefined(width) && !isNullOrUndefined(height)) {
            actPoint.startX = startX;
            actPoint.startY = startY;
            actPoint.endX = startX + width;
            actPoint.endY = startY + height;
            actPoint.width = width;
            actPoint.height = height;
        }
        else {
            if (isNullOrUndefined(parent.transform.zoomFactor) || parent.transform.zoomFactor === 0) {
                const imgLeft = parent.img.destLeft;
                const imgTop = parent.img.destTop;
                const imgWidth = parent.img.destWidth;
                const imgHeight = parent.img.destHeight;
                const lowerCanvasWidth = parent.lowerCanvas.width;
                const lowerCanvasHeight = parent.lowerCanvas.height;
                const activePoint = actPoint;
                if (imgLeft >= 0 && imgTop >= 0) {
                    activePoint.startX = imgLeft;
                    activePoint.startY = imgTop;
                    activePoint.endX = imgLeft + imgWidth;
                    activePoint.endY = imgTop + imgHeight;
                }
                else if (imgLeft >= 0) {
                    activePoint.startX = imgLeft;
                    activePoint.startY = 7.5;
                    activePoint.endX = imgLeft + imgWidth;
                    activePoint.endY = lowerCanvasHeight - 15;
                }
                else if (imgTop >= 0) {
                    activePoint.startX = 7.5;
                    activePoint.startY = imgTop;
                    activePoint.endX = lowerCanvasWidth - 15;
                    activePoint.endY = imgTop + imgHeight;
                }
                else {
                    activePoint.startX = 7.5;
                    activePoint.startY = 7.5;
                    activePoint.endX = lowerCanvasWidth - 15;
                    activePoint.endY = lowerCanvasHeight - 15;
                }
            }
            else {
                const imgLeft = parent.img.destLeft;
                const imgTop = parent.img.destTop;
                const imgWidth = parent.img.destWidth;
                const imgHeight = parent.img.destHeight;
                const lowerCanvasWidth = parent.lowerCanvas.width;
                const lowerCanvasHeight = parent.lowerCanvas.height;
                const activePoint = actPoint;
                activePoint.startX = Math.max(imgLeft > 0 ? imgLeft : 7.5, imgLeft);
                activePoint.startY = Math.max(imgTop > 0 ? imgTop : 7.5, imgTop);
                activePoint.endX = Math.min(imgLeft + imgWidth + 15 < lowerCanvasWidth ? imgLeft + imgWidth - 15 :
                    lowerCanvasWidth - 15, imgLeft + imgWidth);
                activePoint.endY = Math.min(imgTop + imgHeight + 15 < lowerCanvasHeight ? imgTop + imgHeight - 15 :
                    lowerCanvasHeight - 15, imgTop + imgHeight);
            }
            const imgLeft = parent.img.destLeft;
            const imgTop = parent.img.destTop;
            const imgWidth = parent.img.destWidth;
            const imgHeight = parent.img.destHeight;
            const lowerCanvasWidth = parent.lowerCanvas.clientWidth;
            const lowerCanvasHeight = parent.lowerCanvas.clientHeight;
            const activePoint = actPoint;
            activePoint.startX = Math.max(activePoint.startX, imgLeft);
            activePoint.startY = Math.max(activePoint.startY, imgTop);
            activePoint.endX = Math.min(activePoint.endX, imgLeft + imgWidth);
            activePoint.endY = Math.min(activePoint.endY, imgTop + imgHeight);
            if (activePoint.startX === imgLeft && imgLeft + imgWidth > lowerCanvasWidth) {
                activePoint.endX = lowerCanvasWidth - 15;
            }
            if (activePoint.startY === imgTop && imgTop + imgHeight > lowerCanvasHeight) {
                activePoint.endY = lowerCanvasHeight - 15;
            }
            parent.activeObj = this.updateWidthHeight(parent.activeObj);
            this.updateActiveObject(actPoint, parent.activeObj);
        }
        this.updateSelectionInsert();
    }
    callUpdateCurrTransState() {
        const parent = this.parent;
        const tempObjColl = extend([], parent.objColl, [], true);
        const tempActiveObj = extend({}, parent.activeObj, {}, true);
        parent.objColl = [];
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        this.isRotateZoom = true;
        this.updateCurrTransState('initial');
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
            parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
            parent.img.destTop += parent.panPoint.totalPannedPoint.y;
        }
        parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
        const temp = this.lowerContext.filter;
        if (parent.transform.degree === 0) {
            parent.notify('transform', { prop: 'setDestPointsForFlipState', onPropertyChange: false });
        }
        parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        this.updateCurrTransState('reverse');
        if (parent.transform.degree === 0 && parent.rotateFlipColl.length > 0) {
            parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
            parent.img.destTop += parent.panPoint.totalPannedPoint.y;
        }
        this.isRotateZoom = false;
        parent.objColl = tempObjColl;
        const tempTogglePen = parent.togglePen;
        parent.togglePen = false;
        this.lowerContext.filter = 'none';
        parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
        parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
        parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
            value: { context: this.lowerContext, points: null } });
        parent.img.destLeft -= parent.panPoint.totalPannedInternalPoint.x;
        parent.img.destTop -= parent.panPoint.totalPannedInternalPoint.y;
        parent.togglePen = tempTogglePen;
        this.lowerContext.filter = temp;
        parent.activeObj = tempActiveObj;
    }
    resetPanPoints() {
        this.parent.panPoint.totalPannedPoint = { x: 0, y: 0 };
        this.parent.panPoint.totalPannedClientPoint = { x: 0, y: 0 };
        this.parent.panPoint.totalPannedInternalPoint = { x: 0, y: 0 };
    }
    setClientTransDim(isPreventDimension) {
        const parent = this.parent;
        if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
            parent.img.destLeft = (parent.lowerCanvas.width - parent.img.destHeight) / 2;
            parent.img.destTop = (parent.lowerCanvas.height - parent.img.destWidth) / 2;
            const temp = parent.img.destWidth;
            parent.img.destWidth = parent.img.destHeight;
            parent.img.destHeight = temp;
        }
        else {
            if (isNullOrUndefined(isPreventDimension)) {
                parent.img.destLeft = (parent.lowerCanvas.width - parent.img.destWidth) / 2;
                parent.img.destTop = (parent.lowerCanvas.height - parent.img.destHeight) / 2;
            }
        }
    }
    redrawImgWithObj() {
        const parent = this.parent;
        const obj = { canvasFilter: parent.canvasFilter };
        this.lowerContext.filter = obj['canvasFilter'];
        if (parent.rotateFlipColl.length !== 0) {
            const totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
            const destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                height: parent.img.destHeight };
            this.callUpdateCurrTransState();
            parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
            parent.img.destLeft = destPoints.startX;
            parent.img.destTop = destPoints.startY;
            parent.img.destWidth = destPoints.width;
            parent.img.destHeight = destPoints.height;
        }
        else {
            this.callUpdateCurrTransState();
        }
        if (parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
        const tempFilter = this.lowerContext.filter;
        this.lowerContext.filter = parent.getDefaultFilter();
        parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
        parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
            value: { context: this.lowerContext, points: null } });
        this.lowerContext.filter = tempFilter;
    }
    setCurrentObj(obj) {
        const parent = this.parent;
        const isObj = obj ? true : false;
        obj = obj ? obj : parent.cropObj;
        parent.transform.cropZoomFactor = obj.cropZoom;
        parent.transform.defaultZoomFactor = obj.defaultZoom;
        if (!isObj) {
            parent.transform.zoomFactor = obj.cropZoom;
        }
        else {
            if (obj.activeObj.shape && obj.activeObj.shape.split('-')[0] === 'crop') {
                parent.transform.zoomFactor = obj.cropZoom;
            }
            else {
                parent.transform.zoomFactor = obj.defaultZoom;
            }
        }
        parent.setProperties({ zoomSettings: { zoomFactor: obj.zoomFactor } }, true);
        parent.notify('transform', { prop: 'setPreviousZoomValue', onPropertyChange: false, value: { previousZoomValue: obj.previousZoomValue } });
        parent.panPoint.totalPannedPoint = extend({}, obj.totalPannedPoint, {}, true);
        parent.panPoint.totalPannedClientPoint = extend({}, obj.totalPannedClientPoint, {}, true);
        parent.panPoint.totalPannedInternalPoint = extend({}, obj.totalPannedInternalPoint, {}, true);
        const point = extend({}, obj.tempFlipPanPoint, {}, true);
        parent.notify('crop', { prop: 'setTempFlipPanPoint', onPropertyChange: false, value: { point: point } });
        parent.rotateFlipColl = extend([], obj.rotateFlipColl, [], true);
        parent.transform.degree = obj.degree;
        parent.transform.currFlipState = obj.currFlipState;
        parent.img.destLeft = obj.destPoints.startX;
        parent.img.destTop = obj.destPoints.startY;
        parent.img.destWidth = obj.destPoints.width;
        parent.img.destHeight = obj.destPoints.height;
        parent.img.srcLeft = obj.srcPoints.startX;
        parent.img.srcTop = obj.srcPoints.startY;
        parent.img.srcWidth = obj.srcPoints.width;
        parent.img.srcHeight = obj.srcPoints.height;
        if (obj.afterCropActions) {
            parent.afterCropActions = obj.afterCropActions;
        }
        this.lowerContext.filter = obj.filter;
        parent.notify('filter', { prop: 'setBrightnessAdjusted', onPropertyChange: false, value: { isBrightnessAdjusted: obj.isBrightAdjust } });
        const isCircleCrop = parent.isCircleCrop;
        let currSelectionPoint;
        if (isNullOrUndefined(parent.currSelectionPoint)) {
            currSelectionPoint = null;
        }
        else {
            currSelectionPoint = extend({}, parent.currSelectionPoint, {}, true);
            parent.currSelectionPoint = null;
        }
        parent.isCircleCrop = false;
        this.drawCropSelectionImage(obj, false);
        if (parent.transform.degree !== 0) {
            if (parent.transform.currFlipState === '') {
                parent.notify('transform', { prop: 'rotatePan', onPropertyChange: false,
                    value: { isCropSelection: null, isDefaultZoom: null } });
            }
            else {
                parent.notify('transform', { prop: 'drawPannedImage', value: { xDiff: 0, yDiff: 0 } });
            }
            parent.img.destLeft = obj.destPoints.startX;
            parent.img.destTop = obj.destPoints.startY;
            parent.panPoint.totalPannedClientPoint = extend({}, obj.totalPannedClientPoint, {}, true);
            parent.panPoint.totalPannedInternalPoint = extend({}, obj.totalPannedInternalPoint, {}, true);
        }
        parent.activeObj = extend({}, obj.activeObj, {}, true);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
            this.drawObject('duplicate', null, null, null, true);
        }
        let activeObj = extend({}, obj.activeObj, {}, true);
        let isAfterCropAction = false;
        if (parent.afterCropActions.length > 0) {
            const object = { collection: parent.afterCropActions };
            parent.notify('shape', { prop: 'alignRotateFlipColl', onPropertyChange: false,
                value: { collection: parent.afterCropActions, isRotateFlipCollection: null, obj: object } });
            parent.afterCropActions = object['collection'];
        }
        const afterCropActions = extend([], parent.afterCropActions, [], true);
        if (!isObj && afterCropActions.length > 0) {
            isAfterCropAction = true;
            for (let i = 0; i < afterCropActions.length; i++) {
                if (afterCropActions[i] === 'horizontalflip' || afterCropActions[i] === 'verticalflip') {
                    parent.activeObj = extend({}, currSelectionPoint, {}, true);
                    this.rotatedFlipCropSel = true;
                }
                parent.notify('transform', { prop: 'updateTransform', onPropertyChange: false, value: { text: afterCropActions[i] } });
            }
            activeObj = extend({}, parent.activeObj, {}, true);
            this.resetPanPoints();
            parent.activeObj = activeObj;
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
                this.drawObject('duplicate', null, null, null, true);
            }
            if (obj.degree !== parent.transform.degree) {
                parent.transform.cropZoomFactor = null;
                parent.transform.zoomFactor = 0;
            }
            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
            if (this.rotatedFlipCropSel) {
                this.rotatedFlipCropSel = false;
            }
        }
        parent.afterCropActions = afterCropActions;
        if (!this.isCancelAction && !isAfterCropAction) {
            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
            parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
            parent.img.destLeft = obj.destPoints.startX;
            parent.img.destTop = obj.destPoints.startY;
        }
        parent.activeObj = activeObj;
        parent.isCircleCrop = isCircleCrop;
        if (isNullOrUndefined(currSelectionPoint)) {
            parent.currSelectionPoint = null;
        }
        else {
            parent.currSelectionPoint = extend({}, currSelectionPoint, {}, true);
            if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
                parent.currSelectionPoint = null;
            }
        }
    }
    drawCropSelectionImage(obj, isObj) {
        const parent = this.parent;
        const temp = this.lowerContext.filter;
        parent.clearContext(this.lowerContext);
        parent.clearContext(this.upperContext);
        this.lowerContext.setTransform(1, 0, 0, 1, 0, 0);
        if (isObj) {
            this.updateCurrTransState('initial');
        }
        else {
            this.setTransformColl(this.lowerContext, 'initial');
        }
        parent.notify('transform', { prop: 'setDestPointsForFlipState', onPropertyChange: false });
        parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        if (isObj) {
            this.updateCurrTransState('reverse');
        }
        else {
            this.setTransformColl(this.lowerContext, 'reverse');
        }
        parent.img.destLeft = parent.cropObj.destPoints.startX;
        parent.img.destTop = parent.cropObj.destPoints.startY;
        const activeObj = extend({}, obj.activeObj, {}, true);
        this.lowerContext.filter = 'none';
        if (this.isCancelAction) {
            parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
            parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
        }
        else {
            parent.img.destLeft = obj.destPoints.startX;
            parent.img.destTop = obj.destPoints.startY;
            parent.img.destWidth = obj.destPoints.width;
            parent.img.destHeight = obj.destPoints.height;
            parent.img.srcLeft = obj.srcPoints.startX;
            parent.img.srcTop = obj.srcPoints.startY;
            parent.img.srcWidth = obj.srcPoints.width;
            parent.img.srcHeight = obj.srcPoints.height;
            const destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                height: parent.img.destHeight };
            parent.img.destLeft = obj.activeObj.activePoint.startX;
            parent.img.destTop = obj.activeObj.activePoint.startY;
            parent.img.destWidth = obj.activeObj.activePoint.width;
            parent.img.destHeight = obj.activeObj.activePoint.height;
            parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
            parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
            parent.img.destLeft = destPoints.startX;
            parent.img.destTop = destPoints.startY;
            parent.img.destWidth = destPoints.width;
            parent.img.destHeight = destPoints.height;
        }
        parent.activeObj = activeObj;
        this.lowerContext.filter = temp;
    }
    performPointZoom(x, y, type) {
        const parent = this.parent;
        const ratioX = (x - parent.img.destLeft) / parent.img.destWidth;
        const ratioY = (y - parent.img.destTop) / parent.img.destHeight;
        const isUndoRedo = parent.isUndoRedo;
        parent.isUndoRedo = true;
        parent.setProperties({ zoomSettings: { zoomPoint: { x: x, y: y } } }, true);
        if (type === 'zoomIn') {
            parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                value: { zoomFactor: .1, zoomPoint: null } });
        }
        else if (type === 'zoomOut') {
            parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                value: { zoomFactor: -.1, zoomPoint: null } });
        }
        parent.isUndoRedo = isUndoRedo;
        if (parent.transform.zoomFactor > 0) {
            const destLeft = parent.img.destLeft;
            const destTop = parent.img.destTop;
            const activeObj = extend({}, parent.activeObj, {}, true);
            if (parent.transform.degree === 0) {
                parent.img.destLeft = x - (ratioX * parent.img.destWidth);
                parent.img.destTop = y - (ratioY * parent.img.destHeight);
                this.drawZoomPanImage(parent.img.destLeft - destLeft, parent.img.destTop - destTop);
            }
            else {
                const isCropTab = parent.isCropTab;
                parent.isCropTab = true;
                const objColl = extend([], parent.objColl, [], true);
                const pointColl = extend([], parent.pointColl, [], true);
                parent.objColl = [];
                parent.pointColl = [];
                parent.freehandCounter = 0;
                const object = { selPointColl: null };
                parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                    value: { obj: object } });
                const cropSelPointColl = object['selPointColl'];
                parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                    value: { obj: { selPointColl: [] } } });
                parent.panPoint.currentPannedPoint = { x: (x - (ratioX * parent.img.destWidth)) - destLeft,
                    y: (y - (ratioY * parent.img.destHeight)) - destTop };
                parent.notify('transform', { prop: 'rotatePan', onPropertyChange: false,
                    value: { isCropSelection: null, isDefaultZoom: null } });
                parent.isCropTab = isCropTab;
                parent.objColl = objColl;
                parent.pointColl = pointColl;
                parent.freehandCounter = parent.pointColl.length;
                parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                    value: { obj: { selPointColl: cropSelPointColl } } });
                parent.notify('shape', { prop: 'panObjColl', onPropertyChange: false,
                    value: { xDiff: parent.panPoint.currentPannedPoint.x, yDiff: parent.panPoint.currentPannedPoint.y, panRegion: '' } });
                parent.notify('freehand-draw', { prop: 'panFHDColl', onPropertyChange: false,
                    value: { xDiff: parent.panPoint.currentPannedPoint.x, yDiff: parent.panPoint.currentPannedPoint.y, panRegion: '' } });
            }
            this.adjustPanning(activeObj);
            parent.activeObj = activeObj;
            if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
                this.drawObject('duplicate', null, null, null, true);
            }
        }
    }
    adjustPanning(activeObj) {
        const parent = this.parent;
        if (activeObj.activePoint.width !== 0 && activeObj.activePoint.height !== 0) {
            const destLeft = parent.img.destLeft;
            const destTop = parent.img.destTop;
            const point = { x: 0, y: 0 };
            if (parent.img.destLeft > activeObj.activePoint.startX) {
                point.x = parent.img.destLeft - activeObj.activePoint.startX;
            }
            else if (parent.img.destLeft + parent.img.destWidth < activeObj.activePoint.startX + activeObj.activePoint.width) {
                point.x = (parent.img.destLeft + parent.img.destWidth) - (activeObj.activePoint.startX + activeObj.activePoint.width);
            }
            if (parent.img.destTop > activeObj.activePoint.startY) {
                point.y = parent.img.destTop - activeObj.activePoint.startY;
            }
            else if (parent.img.destTop + parent.img.destHeight < activeObj.activePoint.startY + activeObj.activePoint.height) {
                point.y = (parent.img.destTop + parent.img.destHeight) - (activeObj.activePoint.startY + activeObj.activePoint.height);
            }
            if (parent.transform.degree === 0) {
                parent.img.destLeft -= point.x;
                parent.img.destTop -= point.y;
                this.drawZoomPanImage(parent.img.destLeft - destLeft, parent.img.destTop - destTop);
            }
            else {
                const isCropTab = parent.isCropTab;
                parent.isCropTab = true;
                const objColl = extend([], parent.objColl, [], true);
                const pointColl = extend([], parent.pointColl, [], true);
                parent.objColl = [];
                parent.pointColl = [];
                parent.freehandCounter = 0;
                const object = { selPointColl: null };
                parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                    value: { obj: object } });
                const cropSelPointColl = object['selPointColl'];
                parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                    value: { obj: { selPointColl: [] } } });
                parent.img.destLeft -= point.x;
                parent.img.destTop -= point.y;
                parent.panPoint.currentPannedPoint = { x: parent.img.destLeft - destLeft, y: parent.img.destTop - destTop };
                parent.notify('transform', { prop: 'rotatePan', onPropertyChange: false,
                    value: { isCropSelection: null, isDefaultZoom: null } });
                parent.isCropTab = isCropTab;
                parent.objColl = objColl;
                parent.pointColl = pointColl;
                parent.freehandCounter = parent.pointColl.length;
                parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                    value: { obj: { selPointColl: cropSelPointColl } } });
                parent.notify('shape', { prop: 'panObjColl', onPropertyChange: false,
                    value: { xDiff: parent.panPoint.currentPannedPoint.x, yDiff: parent.panPoint.currentPannedPoint.y, panRegion: '' } });
                parent.notify('freehand-draw', { prop: 'panFHDColl', onPropertyChange: false,
                    value: { xDiff: parent.panPoint.currentPannedPoint.x, yDiff: parent.panPoint.currentPannedPoint.y, panRegion: '' } });
            }
        }
    }
    drawZoomPanImage(x, y) {
        const parent = this.parent;
        parent.notify('shape', { prop: 'panObjColl', onPropertyChange: false,
            value: { xDiff: x, yDiff: y, panRegion: '' } });
        parent.notify('freehand-draw', { prop: 'panFHDColl', onPropertyChange: false,
            value: { xDiff: x, yDiff: y, panRegion: '' } });
        this.renderImage(true);
        const obj = { width: 0, height: 0 };
        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: parent.img.srcWidth, height: parent.img.srcHeight, obj: obj } });
        const maxDimension = obj;
        maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
        maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
        parent.panPoint.totalPannedPoint.x += x;
        parent.panPoint.totalPannedPoint.y += y;
        parent.notify('crop', { prop: 'setTempFlipPanPoint', onPropertyChange: false, value: { point: { x: 0, y: 0 } } });
    }
    openNewImage() {
        const parent = this.parent;
        const inMemoryContext = parent.inMemoryCanvas.getContext('2d');
        showSpinner(parent.element);
        parent.element.style.opacity = '0.5';
        const toolbar = document.querySelector('#' + parent.element.id + '_currPos');
        if (toolbar) {
            toolbar.style.display = 'none';
        }
        const obj = { defToolbarItems: null };
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'getDefToolbarItems', value: { obj: obj } });
            if (obj['defToolbarItems'].length === 0 &&
                (isNullOrUndefined(document.getElementById(parent.element.id + '_toolbar')))) {
                const height = parent.element.querySelector('#' + parent.element.id + '_toolbarArea').clientHeight;
                parent.notify('toolbar', { prop: 'setToolbarHeight', value: { height: height } });
            }
        }
        else {
            if (parent.element.querySelector('#' + parent.element.id + '_toolbarArea')) {
                parent.toolbarHeight = parent.element.querySelector('#' + parent.element.id + '_toolbarArea').clientHeight;
            }
        }
        parent.reset();
        parent.update();
        parent.transform.degree = 0;
        parent.transform.zoomFactor = 0;
        parent.isImageLoaded = false;
        parent.currSelectionPoint = null;
        const type = typeof (this.openURL);
        if (type === 'string') {
            let fileName = this.openURL.split('.');
            if (fileName.length > 1) {
                fileName = fileName[fileName.length - 2].split('/');
                this.fileName = fileName[fileName.length - 1];
            }
            else {
                this.fileName = 'ImageEditor';
            }
            this.fileType = this.getFileExtensionFromURL(this.openURL);
            if (this.fileType) {
                this.fileType = parent.toPascalCase(this.fileType);
                let fileType = this.fileType.toLowerCase();
                if (fileType === 'jpg' || fileType === 'jpeg') {
                    this.fileType = 'Jpeg';
                    fileType = 'jpeg';
                }
                if (fileType !== 'jpeg' && fileType !== 'png' && fileType !== 'svg') {
                    this.fileType = null;
                }
            }
            this.imageOnLoad(this.openURL);
        }
        else {
            this.fileName = 'ImageEditor';
            this.fileType = null;
            parent.lowerCanvas = document.querySelector('#' + parent.element.id + '_lowerCanvas');
            parent.upperCanvas = document.querySelector('#' + parent.element.id + '_upperCanvas');
            this.lowerContext = parent.lowerCanvas.getContext('2d');
            this.upperContext = parent.upperCanvas.getContext('2d');
            parent.clearContext(this.lowerContext);
            parent.clearContext(this.upperContext);
            parent.clearContext(inMemoryContext);
            parent.inMemoryCanvas.width = this.openURL.width;
            parent.inMemoryCanvas.height = this.openURL.height;
            inMemoryContext.putImageData(this.openURL, 0, 0);
            parent.baseImg.src = parent.inMemoryCanvas.toDataURL();
        }
    }
    dlgBtnClick() {
        const parent = this.parent;
        parent.export();
        if (this.isFileChanged) {
            parent.isImageLoaded = this.isFileChanged = false;
            parent.reset();
            this.checkToolbarTemplate(this.inputElem, this.openURL);
        }
        else {
            this.reset();
            this.openNewImage();
        }
        if (!isBlazor()) {
            getComponent(document.getElementById(parent.element.id + '_dialog'), 'dialog').destroy();
        }
        this.isImageEdited = false;
    }
    dlgCloseBtnClick() {
        const parent = this.parent;
        this.baseImgSrc = parent.baseImg.src;
        if (this.isFileChanged) {
            parent.isImageLoaded = this.isFileChanged = false;
            parent.reset();
            this.checkToolbarTemplate(this.inputElem, this.openURL);
        }
        else {
            this.reset();
            this.openNewImage();
        }
        if (!isBlazor()) {
            getComponent(document.getElementById(parent.element.id + '_dialog'), 'dialog').destroy();
        }
        this.isImageEdited = false;
    }
    showDialogPopup() {
        this.parent.element.querySelector('#' + this.parent.element.id + '_dialog').style.display = 'block';
        const dialog = new Dialog({
            header: 'Confirm Save Changes',
            closeOnEscape: true,
            content: '<span>Do you want to save the changes you made to the image?</span>',
            target: document.getElementById('target'),
            width: '285px',
            isModal: true,
            animationSettings: { effect: 'Zoom' },
            close: this.dlgCloseBtnClick.bind(this),
            buttons: [
                { click: this.dlgCloseBtnClick.bind(this),
                    buttonModel: { content: 'No', iconCss: 'e-icons e-close' }
                },
                { click: this.dlgBtnClick.bind(this),
                    buttonModel: { content: 'Yes', isPrimary: true, iconCss: 'e-icons e-check' } }
            ]
        });
        dialog.appendTo('#' + this.parent.element.id + '_dialog');
    }
    restoreOldImage() {
        if (this.parent.isImageLoaded) {
            // if (this.isImageEdited || this.parent.pointColl.length > 0 || this.parent.objColl.length > 0) {
            //     this.showDialogPopup();
            // } else {
            // this.reset();
            // this.openNewImage();
            // }
            // const data: ImageData = this.parent.getImageData();
            // const canvas: HTMLCanvasElement = document.createElement('canvas');
            // canvas.width = data.width; canvas.height = data.height;
            // canvas.getContext('2d').putImageData(data, 0, 0);
            // this.baseImgSrc = canvas.toDataURL();
            this.reset();
            this.openNewImage();
        }
        else {
            this.openNewImage();
        }
    }
    open(data) {
        if (!this.parent.disabled) {
            this.openURL = data;
            this.restoreOldImage();
        }
    }
    getInitialLoaded(object) {
        object['isInitialLoaded'] = this.isInitialLoading;
    }
    getFileExtensionFromURL(url) {
        const lastDotIndex = url.lastIndexOf('.');
        if (lastDotIndex !== -1) {
            return url.slice(lastDotIndex + 1).toLowerCase();
        }
        return null;
    }
    fileSelect(inputElement, args) {
        const parent = this.parent;
        if (!parent.disabled) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            const filesData = args.target.files[0];
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            const fileData = filesData;
            let fileExtension = fileData.name && fileData.name.split('.')[1].toLowerCase();
            if (fileExtension && ['jpg', 'jpeg', 'png', 'svg'].indexOf(fileExtension) === -1) {
                this.errorLoading();
                return;
            }
            showSpinner(parent.element);
            parent.element.style.opacity = '0.5';
            this.inputElem = inputElement;
            fileExtension = fileData.name && fileData.name.split('.')[1];
            if (fileExtension) {
                const fileType = parent.toPascalCase(fileExtension);
                if (fileType === 'JPG' || fileType === 'Jpg') {
                    this.fileType = 'Jpeg';
                }
                else {
                    this.fileType = fileType;
                }
            }
            else {
                this.fileType = null;
            }
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            const URL = window.URL;
            const url = URL.createObjectURL(filesData);
            this.openURL = url;
            if (parent.isImageLoaded && (this.isImageEdited || parent.pointColl.length > 0 || parent.objColl.length > 0)) {
                this.isFileChanged = true;
                if (!isBlazor()) {
                    this.showDialogPopup();
                }
                else {
                    parent.dotNetRef.invokeMethodAsync('UpdateDialog');
                }
            }
            else {
                this.checkToolbarTemplate(inputElement, url);
            }
        }
    }
    checkToolbarTemplate(inputElement, url) {
        const parent = this.parent;
        if (isNullOrUndefined(parent.toolbarTemplate)) {
            parent.reset();
            parent.update();
        }
        this.fileName = inputElement.value.split('\\')[inputElement.value.split('\\').length - 1];
        this.fileName = this.fileName.split('.')[0];
        this.imageOnLoad(url.toString());
        inputElement.value = '';
    }
    moveToSelectionRange(type, activeObj) {
        const parent = this.parent;
        if (parent.activeObj.shape) {
            let isRotated = false;
            for (let i = 0; i < parent.rotateFlipColl.length; i++) {
                if (parent.rotateFlipColl[i] === 90 || parent.rotateFlipColl[i] === -90) {
                    isRotated = true;
                    break;
                }
            }
            if (isRotated) {
                let zoomFactor = parent.transform.zoomFactor;
                parent.objColl.push(parent.activeObj);
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                if (type === 'rotateleft' || type === 'rotateright') {
                    if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
                        if (parent.objColl[parent.objColl.length - 1].activePoint.width < activeObj.activePoint.height) {
                            for (let i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                                if (parent.objColl[parent.objColl.length - 1].activePoint.width >= activeObj.activePoint.height ||
                                    this.isSelectionBiggerThanCanvas(parent.objColl[parent.objColl.length - 1]) ||
                                    this.isSelectionOutsideCanvas(parent.objColl[parent.objColl.length - 1])) {
                                    if (!isNullOrUndefined(zoomFactor)) {
                                        parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                            value: { zoomFactor: -0.1, zoomPoint: null } });
                                    }
                                    break;
                                }
                                zoomFactor += 0.1;
                                parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                    value: { zoomFactor: zoomFactor, zoomPoint: null } });
                            }
                        }
                        else {
                            for (let i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                                if (parent.objColl[parent.objColl.length - 1].activePoint.width >= activeObj.activePoint.height ||
                                    this.isSelectionBiggerThanCanvas(parent.objColl[parent.objColl.length - 1]) ||
                                    this.isSelectionOutsideCanvas(parent.objColl[parent.objColl.length - 1])) {
                                    if (!isNullOrUndefined(zoomFactor)) {
                                        parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                            value: { zoomFactor: 0.1, zoomPoint: null } });
                                    }
                                    break;
                                }
                                zoomFactor -= .1;
                                parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                    value: { zoomFactor: zoomFactor, zoomPoint: null } });
                            }
                        }
                    }
                    else {
                        if (parent.objColl[parent.objColl.length - 1].activePoint.height < activeObj.activePoint.width) {
                            for (let i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                                if (parent.objColl[parent.objColl.length - 1].activePoint.height >= activeObj.activePoint.width ||
                                    this.isSelectionBiggerThanCanvas(parent.objColl[parent.objColl.length - 1]) ||
                                    this.isSelectionOutsideCanvas(parent.objColl[parent.objColl.length - 1])) {
                                    if (!isNullOrUndefined(zoomFactor)) {
                                        parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                            value: { zoomFactor: -0.1, zoomPoint: null } });
                                    }
                                    break;
                                }
                                zoomFactor += 0.1;
                                parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                    value: { zoomFactor: zoomFactor, zoomPoint: null } });
                            }
                        }
                        else {
                            for (let i = 2; i < parent.zoomSettings.maxZoomFactor; i++) {
                                if (parent.objColl[parent.objColl.length - 1].activePoint.height >= activeObj.activePoint.width ||
                                    this.isSelectionBiggerThanCanvas(parent.objColl[parent.objColl.length - 1]) ||
                                    this.isSelectionOutsideCanvas(parent.objColl[parent.objColl.length - 1])) {
                                    if (!isNullOrUndefined(zoomFactor)) {
                                        parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                            value: { zoomFactor: 0.1, zoomPoint: null } });
                                    }
                                    break;
                                }
                                zoomFactor -= .1;
                                parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                                    value: { zoomFactor: zoomFactor, zoomPoint: null } });
                            }
                        }
                    }
                }
                const panX = (parent.lowerCanvas.clientWidth / 2) - (parent.objColl[parent.objColl.length - 1].activePoint.startX +
                    (parent.objColl[parent.objColl.length - 1].activePoint.width / 2));
                const panY = (parent.lowerCanvas.clientHeight / 2) - (parent.objColl[parent.objColl.length - 1].activePoint.startY +
                    (parent.objColl[parent.objColl.length - 1].activePoint.height / 2));
                if (parent.transform.degree === 0) {
                    parent.img.destLeft += panX;
                    parent.img.destTop += panY;
                    parent.notify('transform', { prop: 'drawPannImage', value: { point: { x: panX, y: panY } } });
                }
                else {
                    parent.panPoint.currentPannedPoint = { x: panX, y: panY };
                    parent.notify('transform', { prop: 'drawPannedImage', value: { xDiff: panX, yDiff: panY } });
                    parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
                }
                parent.notify('transform', { prop: 'setTempPanMove', onPropertyChange: false,
                    value: { point: null } });
                parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1]);
                parent.objColl.pop();
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
            }
        }
    }
    isSelectionBiggerThanCanvas(obj) {
        let isBigger = false;
        if (obj.activePoint.startX <= this.parent.img.destLeft ||
            obj.activePoint.startY <= this.parent.img.destTop ||
            obj.activePoint.endX >= this.parent.img.destLeft + this.parent.img.destWidth ||
            obj.activePoint.endY >= this.parent.img.destTop + this.parent.img.destHeight) {
            isBigger = true;
        }
        return isBigger;
    }
    isSelectionOutsideCanvas(obj) {
        let isOutside = false;
        if ((obj.activePoint.height < this.parent.lowerCanvas.height - this.parent.toolbarHeight) ||
            (obj.activePoint.width < this.parent.lowerCanvas.width)) {
            isOutside = true;
        }
        return isOutside;
    }
}

class Export {
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    }
    addEventListener() {
        this.parent.on('export', this.export, this);
        this.parent.on('destroyed', this.destroy, this);
    }
    removeEventListener() {
        this.parent.off('export', this.export);
        this.parent.off('destroyed', this.destroy);
    }
    export(args) {
        if (isBlazor()) {
            const obj = { shape: '' };
            this.parent.notify('selection', { prop: 'getCurrentDrawingShape', onPropertyChange: false, value: { obj: obj } });
            if (obj['shape'] !== '') {
                this.parent.notify('selection', { prop: 'setCurrentDrawingShape', onPropertyChange: false, value: { value: '' } });
                this.parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            }
        }
        else {
            this.parent.notify('toolbar', { prop: 'refreshShapeDrawing', onPropertyChange: false });
        }
        this.updatePvtVar();
        switch (args.prop) {
            case 'export':
                this.exportImg(args.value['type'], args.value['fileName']);
                break;
            case 'exportToCanvas':
                this.exportToCanvas(args.value['object']);
                break;
        }
    }
    getModuleName() {
        return 'export';
    }
    updatePvtVar() {
        const parent = this.parent;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
    }
    exportImg(type, fileName) {
        const parent = this.parent;
        const obj = { fileName: '' };
        parent.notify('draw', { prop: 'getFileName', onPropertyChange: false, value: { obj: obj } });
        const imageName = obj['fileName'];
        if (!parent.disabled && parent.isImageLoaded) {
            const dummyObj = { bool: false };
            parent.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: dummyObj } });
            if (dummyObj['bool']) {
                parent.notify('freehand-draw', { prop: 'applyFhd', onPropertyChange: false });
            }
            if (parent.togglePen) {
                parent.currObjType.isZoomed = true;
                parent.notify('shape', { prop: 'apply', onPropertyChange: false, value: { shape: null, obj: null, canvas: null } });
            }
            if (parent.textArea.style.display === 'block') {
                parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                    value: { x: null, y: null, isMouseDown: null } });
            }
            parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: null } });
            const obj = { canvasFilter: this.parent.canvasFilter };
            this.lowerContext.filter = obj['canvasFilter'];
            type = type ? type : 'Png';
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: null } });
            const beforeSave = { cancel: false, fileName: fileName ? fileName : imageName,
                fileType: type };
            if (isBlazor() && parent.events && parent.events.saving.hasDelegate === true) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                parent.dotNetRef.invokeMethodAsync('BeforeSaveEventAsync', 'BeforeSave', beforeSave).then((beforeSave) => {
                    this.beforeSaveEvent(beforeSave, type, fileName, imageName);
                });
            }
            else {
                parent.trigger('beforeSave', beforeSave);
                this.beforeSaveEvent(beforeSave, type, fileName, imageName);
            }
        }
    }
    beforeSaveEvent(observableSaveArgs, type, fileName, imageName) {
        const parent = this.parent;
        if (!observableSaveArgs.cancel) {
            parent.currObjType.isSave = true;
            fileName = observableSaveArgs.fileName ? observableSaveArgs.fileName : fileName;
            const lowerCaseType = type.toLowerCase();
            fileName = fileName || imageName;
            if (lowerCaseType === 'svg') {
                this.toSVGImg(fileName);
            }
            else {
                this.toBlobFn(fileName, lowerCaseType);
            }
            const saved = { fileName: fileName ? fileName : imageName, fileType: type };
            parent.trigger('saved', saved);
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            }
            parent.lowerCanvas.style.left = parent.upperCanvas.style.left = '';
            parent.lowerCanvas.style.top = parent.upperCanvas.style.top = '';
            parent.lowerCanvas.style.maxWidth = parent.upperCanvas.style.maxWidth = '';
            parent.lowerCanvas.style.maxHeight = parent.upperCanvas.style.maxHeight = '';
        }
    }
    toSVGImg(fileName) {
        const parent = this.parent;
        showSpinner(parent.element);
        parent.element.style.opacity = '0.5';
        const tempCanvas = this.exportToCanvas();
        const dataUrl = tempCanvas.toDataURL();
        hideSpinner(parent.element);
        parent.element.style.opacity = '1';
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', tempCanvas.style.maxWidth);
        svg.setAttribute('height', tempCanvas.style.maxHeight);
        const XLinkNS = 'http://www.w3.org/1999/xlink';
        const img = document.createElementNS('http://www.w3.org/2000/svg', 'image');
        img.setAttributeNS(null, 'height', tempCanvas.height.toString());
        img.setAttributeNS(null, 'width', tempCanvas.width.toString());
        img.setAttributeNS(XLinkNS, 'xlink:href', dataUrl);
        svg.appendChild(img);
        const prefix = 'data:image/svg+xml;base64,';
        const header = '<svg' + ' xmlns="http://www.w3.org/2000/svg"' + ' xmlns:xlink="http://www.w3.org/1999/xlink"'
            + ` width="${tempCanvas.width}"` + ` height="${tempCanvas.height}"` + '>';
        const footer = '</svg>';
        const body = svg.innerHTML;
        const data = header + body + footer;
        const svgDataUrl = prefix + btoa(data);
        if (fileName === null) {
            return svgDataUrl;
        }
        else {
            this.downloadImg(svgDataUrl, fileName + '.' + 'svg');
            return null;
        }
    }
    toBlobFn(fileName, type) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const proxy = this;
        const parent = this.parent;
        showSpinner(parent.element);
        parent.element.style.opacity = '0.5';
        const tempCanvas = this.exportToCanvas();
        // eslint-disable-next-line @typescript-eslint/tslint/config
        tempCanvas.toBlob(function (blob) {
            const blobUrl = URL.createObjectURL(blob);
            proxy.downloadImg(blobUrl, fileName + '.' + type);
            hideSpinner(parent.element);
            parent.element.style.opacity = '1';
        }, 'image/png');
    }
    exportToCanvas(object) {
        const parent = this.parent;
        let width;
        let height;
        if (parent.currSelectionPoint) {
            width = parent.img.srcWidth;
            height = parent.img.srcHeight;
        }
        else {
            width = parent.baseImg.width;
            height = parent.baseImg.height;
        }
        const obj = { width: 0, height: 0 };
        parent.notify('crop', { prop: 'calcRatio', onPropertyChange: false,
            value: { obj: obj, dimension: { width: width, height: height } } });
        const ratio = obj;
        const tempContextFilter = this.lowerContext.filter;
        // Manipulating blur value
        if (this.lowerContext.filter !== 'none') {
            const splitWords = this.lowerContext.filter.split(' ');
            let value = parseFloat(splitWords[5].split('(')[1]);
            value *= ((ratio.width + ratio.height) / 2);
            splitWords[5] = 'blur(' + value + 'px)';
            this.lowerContext.filter = splitWords.join(' ');
        }
        const tempCanvas = parent.createElement('canvas', {
            id: parent.element.id + '_tempCanvas', attrs: { name: 'canvasImage' }
        });
        const tempContext = tempCanvas.getContext('2d');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const dimObj = { width: 0, height: 0 };
        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: width, height: height, obj: dimObj } });
        const maxDimension = dimObj;
        tempCanvas.style.maxWidth = maxDimension.width + 'px';
        tempCanvas.style.maxHeight = maxDimension.height + 'px';
        const temp = this.lowerContext.filter;
        parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        tempContext.filter = this.lowerContext.filter;
        tempContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, 0, 0, width, height);
        this.lowerContext.filter = temp;
        if (parent.transform.degree !== 0 || parent.transform.currFlipState !== '') {
            this.updateSaveContext(tempContext);
            this.exportTransformedImage(tempContext);
        }
        if (parent.objColl.length > 0) {
            const temp = tempContext.filter;
            tempContext.filter = 'none';
            const tempObjColl = extend([], parent.objColl, [], true);
            for (let i = 0, len = parent.objColl.length; i < len; i++) {
                const activePoint = parent.objColl[i].activePoint;
                // Subtracting destination left and top points
                activePoint.startX -= parent.img.destLeft;
                activePoint.startY -= parent.img.destTop;
                activePoint.endX -= parent.img.destLeft;
                activePoint.endY -= parent.img.destTop;
                activePoint.width = activePoint.endX - activePoint.startX;
                activePoint.height = activePoint.endY - activePoint.startY;
                // Manipulating points
                activePoint.startX *= ratio.width;
                activePoint.startY *= ratio.height;
                activePoint.endX *= ratio.width;
                activePoint.endY *= ratio.height;
                activePoint.width = activePoint.endX - activePoint.startX;
                activePoint.height = activePoint.endY - activePoint.startY;
                parent.objColl[i].strokeSettings.strokeWidth *= ((ratio.width + ratio.height) / 2);
                if (parent.objColl[i].shape === 'text') {
                    parent.objColl[i].textSettings.fontSize *= ((ratio.width + ratio.height) / 2);
                }
                else if (parent.objColl[i].shape === 'path') {
                    for (let l = 0; l < parent.objColl[i].pointColl.length; l++) {
                        parent.objColl[i].pointColl[l].x =
                            (parent.objColl[i].pointColl[l].x - parent.img.destLeft) * ratio.width;
                        parent.objColl[i].pointColl[l].y =
                            (parent.objColl[i].pointColl[l].y - parent.img.destTop) * ratio.height;
                    }
                }
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'saveContext', obj: parent.objColl[i], isCropRatio: null,
                        points: null, isPreventDrag: true, saveContext: tempContext, isPreventSelection: null } });
            }
            tempContext.filter = temp;
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.objColl = tempObjColl;
        }
        if (parent.freehandCounter > 0) {
            // eslint-disable-next-line
            const tempPointColl = extend({}, parent.pointColl, {}, true);
            for (let n = 0; n < parent.freehandCounter; n++) {
                parent.points = extend([], parent.pointColl[n].points, []);
                parent.notify('freehand-draw', { prop: 'setPointCounter', onPropertyChange: false, value: { value: 0 } });
                const len = parent.points.length;
                parent.pointColl[n].strokeWidth *= ((ratio.width + ratio.height) / 2);
                for (let l = 0; l < len; l++) {
                    parent.points[l].x = (parent.points[l].x - parent.img.destLeft) * ratio.width;
                    parent.points[l].y = (parent.points[l].y - parent.img.destTop) * ratio.height;
                }
            }
            parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                value: { context: tempContext, points: null } });
            parent.pointColl = tempPointColl;
        }
        if (parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: tempContext, isSave: true, isFlip: null } });
        }
        this.lowerContext.filter = tempContextFilter;
        parent.canvasFilter = tempContextFilter;
        if (object) {
            object['canvas'] = tempCanvas;
        }
        return tempCanvas;
    }
    downloadImg(blob, fileName) {
        const a = document.createElement('a');
        a.href = blob;
        a.target = '_parent';
        a.download = fileName;
        (document.body || document.documentElement).appendChild(a);
        a.click();
        a.parentNode.removeChild(a);
    }
    exportTransformedImage(tempContext) {
        const parent = this.parent;
        const degree = parent.transform.degree;
        for (let i = 0, len = parent.rotateFlipColl.length; i < len; i++) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const flip = parent.rotateFlipColl[i];
            if (typeof flip === 'number') {
                this.exportRotate(tempContext, flip);
            }
            else if (flip === 'horizontal') {
                this.exportFlip(tempContext, true, false);
            }
            else if (flip === 'vertical') {
                this.exportFlip(tempContext, false, true);
            }
        }
        parent.transform.degree = degree;
    }
    exportRotate(tempContext, degree) {
        const parent = this.parent;
        this.setMaxDim(parent.transform.degree, tempContext.canvas);
        tempContext.translate(tempContext.canvas.width / 2, tempContext.canvas.height / 2);
        tempContext.rotate(Math.PI / 180 * degree);
        tempContext.drawImage(parent.inMemoryCanvas, -tempContext.canvas.height / 2, -tempContext.canvas.width / 2, tempContext.canvas.height, tempContext.canvas.width);
        this.updateSaveContext(tempContext);
    }
    exportFlip(tempContext, flipHorizontal, flipVertical) {
        if (flipHorizontal) {
            tempContext.translate(tempContext.canvas.width, 0);
            tempContext.scale(-1, 1);
        }
        if (flipVertical) {
            tempContext.translate(0, tempContext.canvas.height);
            tempContext.scale(1, -1);
        }
        tempContext.drawImage(this.parent.inMemoryCanvas, 0, 0);
        this.updateSaveContext(tempContext);
    }
    updateSaveContext(tempContext) {
        const inMemoryContext = this.parent.inMemoryCanvas.getContext('2d');
        tempContext.setTransform(1, 0, 0, 1, 0, 0);
        const imageData = tempContext.getImageData(0, 0, tempContext.canvas.width, tempContext.canvas.height);
        this.parent.inMemoryCanvas.width = imageData.width;
        this.parent.inMemoryCanvas.height = imageData.height;
        inMemoryContext.putImageData(imageData, 0, 0);
    }
    setMaxDim(degree, tempCanvas) {
        let newWidth;
        let newHeight;
        if (degree % 90 === 0 && degree % 180 !== 0) {
            newWidth = isNullOrUndefined(this.parent.currSelectionPoint) ? this.parent.baseImg.height : this.parent.img.srcHeight;
            newHeight = isNullOrUndefined(this.parent.currSelectionPoint) ? this.parent.baseImg.width : this.parent.img.srcWidth;
        }
        else if (degree % 180 === 0 || degree === 0) {
            newWidth = isNullOrUndefined(this.parent.currSelectionPoint) ? this.parent.baseImg.width : this.parent.img.srcWidth;
            newHeight = isNullOrUndefined(this.parent.currSelectionPoint) ? this.parent.baseImg.height : this.parent.img.srcHeight;
        }
        tempCanvas.width = newWidth;
        tempCanvas.height = newHeight;
        const obj = { width: 0, height: 0 };
        this.parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: newWidth, height: newHeight, obj: obj } });
        const maxDimension = obj;
        tempCanvas.style.maxWidth = maxDimension.width + 'px';
        tempCanvas.style.maxHeight = maxDimension.height + 'px';
    }
}

class Filter {
    constructor(parent) {
        this.adjustmentLevel = { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0, blur: 0,
            exposure: 0, sharpen: false, bw: false }; // for toolbar slider value
        this.tempAdjustmentLevel = { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0, blur: 0,
            exposure: 0, sharpen: false, bw: false }; // for temp toolbar slider value
        this.adjustmentValue = ''; // for internal slider value
        this.isBrightnessAdjusted = false;
        this.appliedFilter = '';
        this.parent = parent;
        this.addEventListener();
    }
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    }
    addEventListener() {
        this.parent.on('filter', this.filter, this);
        this.parent.on('destroyed', this.destroy, this);
    }
    removeEventListener() {
        this.parent.off('filter', this.filter);
        this.parent.off('destroyed', this.destroy);
    }
    filter(args) {
        this.updatePrivateVariables();
        switch (args.prop) {
            case 'finetuneImage':
                this.finetuneImage(args.value['option'], args.value['value']);
                break;
            case 'applyImageFilter':
                this.setFilter(args.value['option']);
                break;
            case 'update-finetunes':
                this.updateFinetunes();
                break;
            case 'updateBrightFilter':
                this.updateBrightFilter();
                break;
            case 'set-adjustment':
                this.setAdjustment(args.value['operation']);
                break;
            case 'update-filter':
                this.updateFilter(args.value['operation'], args.value['filter']);
                break;
            case 'initFilter':
                this.initFilter();
                break;
            case 'setCurrAdjValue':
                this.setCurrAdjValue(args.value['type'], args.value['value']);
                break;
            case 'updateAdj':
                this.updateAdj(args.value['type'], args.value['value'], args.value['isPreview'], args.value['ctx']);
                break;
            case 'getCurrentObj':
                this.getCurrentObj(args.value['object']);
                break;
            case 'getAdjustmentLevel':
                args.value['obj']['adjustmentLevel'] = this.adjustmentLevel;
                break;
            case 'setAdjustmentLevel':
                this.adjustmentLevel = args.value['adjustmentLevel'];
                break;
            case 'getTempAdjustmentLevel':
                args.value['obj']['tempAdjustmentLevel'] = this.tempAdjustmentLevel;
                break;
            case 'setTempAdjustmentLevel':
                this.tempAdjustmentLevel = args.value['tempAdjustmentLevel'];
                break;
            case 'setAdjustmentValue':
                this.adjustmentValue = args.value['adjustmentValue'];
                break;
            case 'getBrightnessAdjusted':
                args.value['obj']['isBrightnessAdjusted'] = this.isBrightnessAdjusted;
                break;
            case 'setBrightnessAdjusted':
                this.isBrightnessAdjusted = args.value['isBrightnessAdjusted'];
                if (this.parent.currentFilter.split('_') && this.parent.currentFilter.split('_')[1] === 'cold') {
                    this.isBrightnessAdjusted = false;
                }
                break;
            case 'reset':
                this.reset();
                break;
        }
    }
    updatePrivateVariables() {
        const parent = this.parent;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
    }
    getModuleName() {
        return 'filter';
    }
    updateBrightFilter() {
        const splitWords = this.lowerContext.filter.split(' ');
        if (this.isBrightnessAdjusted && splitWords.length > 0 && !isNullOrUndefined(splitWords[4])) {
            const opacityValue = parseFloat(splitWords[4].split('(')[1]);
            splitWords[4] = 'opacity(' + (opacityValue - 0.3) + ')';
            this.lowerContext.filter = splitWords.join(' ');
        }
    }
    reset() {
        this.adjustmentLevel = { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0,
            blur: 0, exposure: 0, sharpen: false, bw: false };
        this.tempAdjustmentLevel = { brightness: 0, contrast: 0, hue: 0, opacity: 100, saturation: 0,
            blur: 0, exposure: 0, sharpen: false, bw: false };
        this.adjustmentValue = this.parent.getDefaultFilter();
        this.isBrightnessAdjusted = false;
        this.appliedFilter = '';
    }
    updateFinetunes() {
        const parent = this.parent;
        const fs = parent.finetuneSettings;
        if (fs) {
            if (fs.brightness) {
                this.adjustmentLevel.brightness = fs.brightness.defaultValue;
                this.tempAdjustmentLevel.brightness = fs.brightness.defaultValue;
            }
            if (fs.contrast) {
                this.adjustmentLevel.contrast = fs.contrast.defaultValue;
                this.tempAdjustmentLevel.contrast = fs.contrast.defaultValue;
            }
            if (fs.hue) {
                this.adjustmentLevel.hue = fs.hue.defaultValue;
                this.tempAdjustmentLevel.hue = fs.hue.defaultValue;
            }
            if (fs.saturation) {
                this.adjustmentLevel.saturation = fs.saturation.defaultValue;
                this.tempAdjustmentLevel.saturation = fs.saturation.defaultValue;
            }
            if (fs.exposure) {
                this.adjustmentLevel.exposure = fs.exposure.defaultValue;
                this.tempAdjustmentLevel.exposure = fs.exposure.defaultValue;
            }
            if (fs.opacity) {
                this.adjustmentLevel.opacity = fs.opacity.defaultValue;
                this.tempAdjustmentLevel.opacity = fs.opacity.defaultValue;
            }
            if (fs.blur) {
                this.adjustmentLevel.blur = fs.blur.defaultValue;
                this.tempAdjustmentLevel.blur = fs.blur.defaultValue;
            }
            parent.notify('draw', { prop: 'isInitialLoading', onPropertyChange: false, value: { isInitialLoading: true } });
        }
    }
    initFilter() {
        this.setFilterAdj('brightness', this.adjustmentLevel.brightness);
        this.setFilterAdj('contrast', this.adjustmentLevel.contrast);
        this.setFilterAdj('hue', this.adjustmentLevel.hue);
        this.setFilterAdj('saturation', this.adjustmentLevel.saturation);
        this.setFilterAdj('exposure', this.adjustmentLevel.exposure);
        this.setFilterAdj('opacity', this.adjustmentLevel.opacity);
        this.setFilterAdj('blur', this.adjustmentLevel.blur);
    }
    updateAdj(type, value, isPreview, ctx) {
        const parent = this.parent;
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        let splitWords = this.lowerContext.filter.split(' ');
        let values = [];
        let opacityValue;
        let brightnessValue;
        if (splitWords[4]) {
            opacityValue = parseFloat(splitWords[4].split('(')[1]);
        }
        if (splitWords[0]) {
            brightnessValue = parseFloat(splitWords[0].split('(')[1]);
        }
        const brightness = this.getFilterValue(this.adjustmentLevel.brightness);
        const saturation = this.getFilterValue(this.adjustmentLevel.saturation);
        const excludedTypes = ['brightness', 'contrast', 'hue', 'saturation', 'exposure', 'opacity', 'blur'];
        if (excludedTypes.indexOf(type) === -1) {
            if (isNullOrUndefined(isPreview) && (this.adjustmentLevel.sharpen || this.adjustmentLevel.bw)) {
                parent.isUndoRedo = true;
                const temp = this.lowerContext.filter;
                this.lowerContext.filter = 'none';
                parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
                parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                    value: { context: this.lowerContext, points: null } });
                this.lowerContext.filter = temp;
                parent.isUndoRedo = false;
            }
        }
        if (brightness !== 1) {
            splitWords[4] = 'opacity(' + (opacityValue - 0.3) + ')';
        }
        let saturate;
        let bright;
        let saturatePercent;
        let contrast;
        let saturatePercentage;
        switch (type) {
            case 'brightness':
                if (parseFloat(splitWords[3].split('(')[1]) !== 100) {
                    value += 0.1;
                }
                splitWords[0] = 'brightness(' + value + ')';
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'contrast':
                splitWords[1] = 'contrast(' + value + '%)';
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'hue':
                splitWords[2] = 'hue-rotate(' + value + 'deg)';
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'saturation':
                splitWords[3] = 'saturate(' + value + '%)';
                if (saturation !== 1) {
                    splitWords[0] = 'brightness(' + (brightnessValue + 0.09) + ')';
                }
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'opacity':
                if (parseFloat(splitWords[0].split('(')[1]) !== 1) {
                    value -= 0.2;
                }
                splitWords[4] = 'opacity(' + value + ')';
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'blur':
                splitWords[5] = 'blur(' + value + 'px)';
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'exposure':
                if (brightness !== 1) {
                    splitWords[4] = 'opacity(' + (opacityValue - 0.3) + ')';
                }
                if (value > 1) {
                    value -= 1;
                    value += brightness;
                }
                else if (value < 1) {
                    value = 1 - value;
                    value = brightness - value;
                }
                splitWords[0] = 'brightness(' + value + ')';
                this.adjustmentValue = splitWords.join(' ');
                break;
            case 'chrome':
                saturate = this.getSaturationFilterValue(this.adjustmentLevel.saturation);
                saturate *= 100;
                value = saturate + (saturate * 0.4);
                splitWords[3] = 'saturate(' + value + '%)';
                values = this.adjustmentValue.split(' ');
                splitWords[0] = values[0];
                splitWords[1] = values[1];
                splitWords[2] = values[2];
                splitWords[4] = values[4];
                splitWords[5] = values[5];
                splitWords[6] = 'sepia(0%)';
                splitWords[7] = 'grayscale(0%)';
                splitWords[8] = 'invert(0%)';
                break;
            case 'cold':
                // Adjusting Brightness
                bright = this.getFilterValue(this.adjustmentLevel.brightness);
                bright *= 100;
                value = bright * 0.9;
                value *= 0.01;
                splitWords[0] = 'brightness(' + value + ')';
                // Adjusting Contrast
                contrast = this.getFilterValue(this.adjustmentLevel.contrast);
                contrast *= 100;
                value = contrast + (contrast * 0.5);
                splitWords[1] = 'contrast(' + value + '%)';
                // Adjusting Saturation
                saturatePercentage = this.getSaturationFilterValue(this.adjustmentLevel.saturation);
                saturatePercentage *= 100;
                value = saturatePercentage;
                splitWords[3] = 'saturate(' + value + '%)';
                values = this.adjustmentValue.split(' ');
                splitWords[2] = values[2];
                splitWords[4] = values[4];
                splitWords[5] = values[5];
                splitWords[6] = 'sepia(0%)';
                splitWords[7] = 'grayscale(0%)';
                splitWords[8] = 'invert(0%)';
                break;
            case 'warm':
                saturatePercent = this.getSaturationFilterValue(this.adjustmentLevel.saturation);
                saturatePercent *= 100;
                value = saturatePercent + (saturatePercent * 0.4);
                splitWords[3] = 'saturate(' + value + '%)';
                splitWords[6] = 'sepia(25%)';
                values = this.adjustmentValue.split(' ');
                splitWords[0] = values[0];
                splitWords[1] = values[1];
                splitWords[2] = values[2];
                splitWords[4] = values[4];
                splitWords[5] = values[5];
                splitWords[7] = 'grayscale(0%)';
                splitWords[8] = 'invert(0%)';
                break;
            case 'grayscale':
                splitWords[7] = 'grayscale(100%)';
                values = this.adjustmentValue.split(' ');
                splitWords[0] = values[0];
                splitWords[1] = values[1];
                splitWords[2] = values[2];
                splitWords[3] = values[3];
                splitWords[4] = values[4];
                splitWords[5] = values[5];
                splitWords[6] = 'sepia(0%)';
                splitWords[8] = 'invert(0%)';
                break;
            case 'sepia':
                splitWords[6] = 'sepia(100%)';
                values = this.adjustmentValue.split(' ');
                splitWords[0] = values[0];
                splitWords[1] = values[1];
                splitWords[2] = values[2];
                splitWords[3] = values[3];
                splitWords[4] = values[4];
                splitWords[5] = values[5];
                splitWords[7] = 'grayscale(0%)';
                splitWords[8] = 'invert(0%)';
                break;
            case 'invert':
                splitWords[8] = 'invert(100%)';
                values = this.adjustmentValue.split(' ');
                splitWords[0] = values[0];
                splitWords[1] = values[1];
                splitWords[2] = values[2];
                splitWords[3] = values[3];
                splitWords[4] = values[4];
                splitWords[5] = values[5];
                splitWords[6] = 'sepia(0%)';
                splitWords[7] = 'grayscale(0%)';
                break;
        }
        if (type !== 'sharpen' && type !== 'blackandwhite') {
            if (isNullOrUndefined(isPreview)) {
                if (type === 'default') {
                    splitWords = this.getDefaultCurrentFilter(splitWords);
                }
                this.lowerContext.filter = splitWords.join(' ');
            }
            splitWords = this.setTempFilterValue(brightness, isPreview, splitWords, type);
            parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: true } });
            parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
            this.appliedFilter = this.lowerContext.filter;
            this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
            parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                value: { type: 'reverse', isPreventDestination: null, isRotatePan: null } });
            parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: false } });
            if (brightness !== 1) {
                splitWords[4] = 'opacity(' + opacityValue + ')';
            }
            else if (saturation !== 1) {
                splitWords[0] = 'brightness(' + brightnessValue + ')';
            }
            if ((type === 'exposure' && brightness !== 1) || (type === 'saturation' && saturation !== 1)) {
                splitWords[0] = 'brightness(' + brightnessValue + ')';
            }
            splitWords = this.setTempFilterValue(brightness, isPreview, splitWords, type);
            if (isNullOrUndefined(isPreview)) {
                this.lowerContext.filter = splitWords.join(' ');
            }
            parent.initialAdjustmentValue = splitWords.join(' ');
            const tempFilter = this.lowerContext.filter;
            this.lowerContext.filter = 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
                'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' + 'invert(0%)';
            parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
            parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                value: { context: this.lowerContext, points: null } });
            this.lowerContext.filter = tempFilter;
            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
            if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: this.lowerContext, isSave: null, isFlip: null } });
            }
            this.isBrightnessAdjusted = brightness !== 1;
        }
        const filter = splitWords.join(' ');
        if (ctx) {
            ctx.filter = filter;
        }
    }
    setTempFilterValue(brightness, isPreview, splitWords, type) {
        if (isPreview) {
            if (type === 'default') {
                splitWords = this.getDefaultCurrentFilter(splitWords);
            }
            else if (brightness !== 1) {
                const tempSplitWords = this.lowerContext.filter.split(' ');
                tempSplitWords[4] = splitWords[4];
                this.lowerContext.filter = tempSplitWords.join(' ');
            }
        }
        return splitWords;
    }
    getDefaultCurrentFilter(splitWords) {
        const values = this.adjustmentValue.split(' ');
        splitWords = [
            values[0],
            values[1],
            values[2],
            values[3],
            values[4],
            values[5],
            'sepia(0%)',
            'grayscale(0%)',
            'invert(0%)'
        ];
        return splitWords;
    }
    getFilterValue(value) {
        return (value === 0) ? 1 : 1 + ((value * 0.5) / 100);
    }
    getSaturationFilterValue(value) {
        return value === 0 ? 1 : 1 + (value / 100);
    }
    setFilterAdj(type, value) {
        const parent = this.parent;
        parent.notify('freehand-draw', { prop: 'apply-pen-draw', onPropertyChange: false });
        this.adjustmentLevel[`${type}`] = value;
        switch (type) {
            case 'brightness':
            case 'contrast':
            case 'exposure':
                value = this.getFilterValue(value);
                if (type === 'contrast') {
                    value *= 100;
                }
                break;
            case 'hue':
                value *= 3;
                break;
            case 'saturation':
                value = this.getSaturationFilterValue(value) * 100;
                break;
            case 'opacity':
                if (value >= 50) {
                    value /= 100;
                }
                else if (value === 40) {
                    value = 0.45;
                }
                else if (value === 30) {
                    value = 0.40;
                }
                else if (value === 20) {
                    value = 0.35;
                }
                else if (value === 10) {
                    value = 0.30;
                }
                else if (value === 0) {
                    value = 0.25;
                }
                break;
            case 'blur':
                if (value !== 0) {
                    value /= 20;
                    // Since 0.5 is not working in blur we consider from 1
                    value += 0.5;
                }
                break;
        }
        const prevCropObj = extend({}, parent.cropObj, {}, true);
        const prevObj = this.getCurrentObj();
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.updateAdj(type, value);
        parent.notify('undo-redo', {
            prop: 'updateUndoRedoColl',
            onPropertyChange: false,
            value: {
                operation: type,
                previousObj: prevObj,
                previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl,
                previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj,
                previousText: null,
                currentText: null,
                previousFilter: null,
                isCircleCrop: null
            }
        });
    }
    setFilter(type) {
        const parent = this.parent;
        type = type.toLowerCase();
        parent.notify('freehand-draw', { prop: 'apply-pen-draw', onPropertyChange: false });
        const obj = { currentFilter: this.parent.currentFilter };
        const prevFilter = obj['currentFilter'];
        const prevCropObj = extend({}, parent.cropObj, {}, true);
        const prevObj = this.getCurrentObj();
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.updateAdj(type, null);
        parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
            value: { operation: type, previousObj: prevObj, previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj, previousText: null,
                currentText: null, previousFilter: prevFilter, isCircleCrop: null } });
    }
    setAdjustment(type) {
        const splitWords = this.lowerContext.filter.split(' ');
        let value;
        let valueArr;
        switch (type) {
            case 'brightness':
                valueArr = splitWords[0].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                this.adjustmentLevel.brightness = this.setFilterValue(value);
                break;
            case 'contrast':
                valueArr = splitWords[1].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                value /= 100;
                this.adjustmentLevel.contrast = this.setFilterValue(value);
                break;
            case 'hue':
                valueArr = splitWords[2].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                value /= 3;
                this.adjustmentLevel.hue = value;
                break;
            case 'saturation':
                valueArr = splitWords[3].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                value /= 100;
                this.adjustmentLevel.saturation = this.setSaturationFilterValue(value);
                break;
            case 'opacity':
                valueArr = splitWords[4].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                if (value === 0.45) {
                    value = 40;
                }
                else if (value === 0.40) {
                    value = 30;
                }
                else if (value === 0.35) {
                    value = 20;
                }
                else if (value === 0.30) {
                    value = 10;
                }
                else if (value === 0.25) {
                    value = 0;
                }
                else {
                    value *= 100;
                }
                this.adjustmentLevel.opacity = value;
                break;
            case 'blur':
                valueArr = splitWords[5].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                value *= 20;
                this.adjustmentLevel.blur = value;
                break;
            case 'exposure':
                valueArr = splitWords[0].split('(');
                value = parseFloat(valueArr[1].split(')')[0]);
                this.adjustmentLevel.exposure = this.setFilterValue(value);
                break;
        }
    }
    setFilterValue(value) {
        return Math.round((value === 1) ? 0 : ((value - 1) * 100) / 0.5);
    }
    setSaturationFilterValue(value) {
        return Math.round((value === 1) ? 0 : (value - 1) * 100);
    }
    updateFilter(type, previousFilter) {
        const parent = this.parent;
        const validTypes = ['default', 'chrome', 'cold', 'warm', 'grayscale', 'blackandwhite', 'sepia', 'invert', 'sharpen'];
        if (validTypes.indexOf(type) !== -1) {
            const selEle = parent.element.querySelector('.e-contextual-toolbar-wrapper .e-toolbar-item.e-selected');
            if (selEle) {
                selEle.classList.remove('e-selected');
            }
            const filterCanvas = document.getElementById(parent.element.id + '_' + type + 'Canvas');
            if (filterCanvas) {
                filterCanvas.parentElement.classList.add('e-selected');
            }
            this.parent.currentFilter = previousFilter ? previousFilter : parent.element.id + '_' + type;
        }
    }
    finetuneImage(finetuneOption, value) {
        const parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            switch (finetuneOption.toLowerCase()) {
                case 'brightness':
                    this.setFilterAdj('brightness', value);
                    break;
                case 'contrast':
                    this.setFilterAdj('contrast', value);
                    break;
                case 'hue':
                    this.setFilterAdj('hue', value);
                    break;
                case 'saturation':
                    this.setFilterAdj('saturation', value);
                    break;
                case 'opacity':
                    this.setFilterAdj('opacity', value);
                    break;
                case 'blur':
                    this.setFilterAdj('blur', value);
                    break;
                case 'exposure':
                    this.setFilterAdj('exposure', value);
                    break;
            }
            this.parent.canvasFilter = this.lowerContext.filter;
            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
        }
    }
    setCurrAdjValue(type, value) {
        this.parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
        switch (type) {
            case 'brightness':
                this.setFilterAdj('brightness', value);
                break;
            case 'contrast':
                this.setFilterAdj('contrast', value);
                break;
            case 'hue':
                this.setFilterAdj('hue', value);
                break;
            case 'saturation':
                this.setFilterAdj('saturation', value);
                break;
            case 'opacity':
                this.setFilterAdj('opacity', value);
                break;
            case 'blur':
                this.setFilterAdj('blur', value);
                break;
            case 'exposure':
                this.setFilterAdj('exposure', value);
                break;
        }
    }
    getCurrentObj(dummyObj) {
        const parent = this.parent;
        const tempFlipPanPointObj = { point: null };
        parent.notify('crop', { prop: 'getTempFlipPanPoint', value: { obj: tempFlipPanPointObj } });
        const zoomObj = { previousZoomValue: null };
        parent.notify('transform', { prop: 'getPreviousZoomValue', value: { obj: zoomObj } });
        const obj = { cropZoom: 0, defaultZoom: 0, totalPannedPoint: { x: 0, y: 0 }, totalPannedClientPoint: { x: 0, y: 0 },
            totalPannedInternalPoint: { x: 0, y: 0 }, tempFlipPanPoint: { x: 0, y: 0 }, activeObj: {},
            rotateFlipColl: [], degree: 0, currFlipState: '', zoomFactor: 0, previousZoomValue: 0,
            destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
            srcPoints: { startX: 0, startY: 0, width: 0, height: 0 }, filter: '', isBrightAdjust: this.isBrightnessAdjusted };
        obj.cropZoom = parent.transform.cropZoomFactor;
        obj.defaultZoom = parent.transform.defaultZoomFactor;
        obj.zoomFactor = parent.zoomSettings.zoomFactor;
        obj.previousZoomValue = zoomObj['previousZoomValue'];
        obj.totalPannedPoint = extend({}, parent.panPoint.totalPannedPoint, {}, true);
        obj.totalPannedClientPoint = extend({}, parent.panPoint.totalPannedClientPoint, {}, true);
        obj.totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
        obj.tempFlipPanPoint = extend({}, tempFlipPanPointObj['point'], {}, true);
        obj.activeObj = extend({}, parent.activeObj, {}, true);
        obj.rotateFlipColl = extend([], parent.rotateFlipColl, [], true);
        obj.degree = parent.transform.degree;
        obj.currFlipState = parent.transform.currFlipState;
        obj.destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, endX: 0, endY: 0,
            width: parent.img.destWidth, height: parent.img.destHeight };
        obj.srcPoints = { startX: parent.img.srcLeft, startY: parent.img.srcTop, endX: 0, endY: 0,
            width: parent.img.srcWidth, height: parent.img.srcHeight };
        obj.filter = this.lowerContext.filter;
        if (dummyObj) {
            dummyObj['currObj'] = obj;
        }
        return obj;
    }
}

class FreehandDrawing {
    constructor(parent) {
        this.fhdObj = { lastWidth: 0, lastVelocity: 0, time: 0, pointX: 0, pointY: 0 };
        this.isFreehandDrawing = false;
        this.freehandDownPoint = { x: 0, y: 0 };
        this.isFreehandPointMoved = false;
        this.pointCounter = 0;
        // eslint-disable-next-line
        this.selPointColl = {};
        this.currFHDIdx = 0; // Specifies id for every freehand drawing - uses while deleting
        this.selPoints = [];
        this.dummyPoints = [];
        this.tempFHDStyles = { strokeColor: null, fillColor: null, strokeWidth: null };
        this.parent = parent;
        this.addEventListener();
    }
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    }
    addEventListener() {
        this.parent.on('freehand-draw', this.draw, this);
        this.parent.on('destroyed', this.destroy, this);
    }
    removeEventListener() {
        this.parent.off('freehand-draw', this.draw);
        this.parent.off('destroyed', this.destroy);
    }
    draw(args) {
        this.updateFhdPvtVar();
        switch (args.prop) {
            case 'hoverFhd': {
                this.hoverFhd(args.value['strokeColor'], args.value['strokeWidth']);
                break;
            }
            case 'freehandDownHandler':
                this.freehandDownHandler(args.value['e'], args.value['canvas']);
                break;
            case 'freehandUpHandler':
                this.freehandUpHandler(args.value['e'], args.value['canvas'], args.value['context']);
                break;
            case 'handle-freehand-draw': {
                const id = parseInt(args.value['id'].split('_')[1], 10) - 1;
                if (this.isFHDIdx(id)) {
                    this.deleteFhd(id, true);
                }
                break;
            }
            case 'freehandRedraw':
                this.freehandRedraw(args.value['context'], args.value['points']);
                break;
            case 'deleteFhd': {
                const id = parseInt(args.value['id'].split('_')[1], 10) - 1;
                this.deleteFhd(id, true);
                break;
            }
            case 'selectFhd': {
                let id = null;
                if (args.value['id']) {
                    id = parseInt(args.value['id'].split('_')[1], 10) - 1;
                }
                this.selectFhd(id);
                break;
            }
            case 'applyFhd':
                this.applyFhd();
                break;
            case 'cancelFhd':
                this.cancelFhd();
                break;
            case 'updateFHDCurPts':
                this.updateFHDCurPts();
                break;
            case 'rotateFhdColl':
                this.rotateFhdColl();
                break;
            case 'flipFHDColl':
                this.flipFHDColl(args.value['value']);
                break;
            case 'panFHDColl':
                this.panFHDColl(args.value['xDiff'], args.value['yDiff'], args.value['panRegion']);
                break;
            case 'updateFHDColl':
                this.updateFHDColl();
                break;
            case 'zoomFHDColl':
                this.zoomFHDColl(args.value['isPreventApply']);
                break;
            case 'apply-pen-draw':
                this.applyPenDraw();
                break;
            case 'freeHandDraw':
                this.freeHandDraw(args.value['value']);
                break;
            case 'isFHDIdx':
                this.isFHDIdx(args.value['index'], args.value['obj']);
                break;
            case 'getSqPtFD':
                this.getSqPtFD(args.value['idx'], args.value['obj']);
                break;
            case 'getSelPointColl':
                args.value['obj']['selPointColl'] = extend([], this.selPointColl);
                break;
            case 'setSelPointColl':
                this.selPointColl = extend([], args.value['obj']['selPointColl']);
                break;
            case 'setFreehandDrawHoveredIndex':
                this.fhdHovIdx = args.value['index'];
                break;
            case 'getFreehandDrawHoveredIndex':
                args.value['obj']['index'] = this.fhdHovIdx;
                break;
            case 'setPointCounter':
                this.pointCounter = args.value['value'];
                break;
            case 'getPenStrokeWidth':
                args.value['obj']['penStrokeWidth'] = this.penStrokeWidth;
                break;
            case 'setPenStrokeWidth':
                this.penStrokeWidth = args.value['value'];
                break;
            case 'getCurrentFreehandDrawIndex':
                args.value['obj']['currentFreehandDrawIndex'] = this.currFHDIdx;
                break;
            case 'setCurrentFreehandDrawIndex':
                this.currFHDIdx = args.value['value'];
                break;
            case 'updateCropPtsForSel':
                this.updateCropPtsForSel();
                break;
            case 'getFreehandDrawSelectedId':
                args.value['obj']['freehandDrawSelectedId'] = this.fhdSelID;
                break;
            case 'resetFreehandDrawSelectedId':
                this.fhdSelID = null;
                break;
            case 'getTempFreeHandDrawEditingStyles':
                args.value['obj']['tempFreeHandDrawEditingStyles'] = this.tempFHDStyles;
                break;
            case 'setFreehandSelectedIndex':
                this.fhdSelIdx = args.value['index'];
                break;
            case 'getFreehandSelectedIndex':
                args.value['obj']['freehandSelectedIndex'] = this.fhdSelIdx;
                break;
            case 'reset':
                this.reset();
                break;
        }
    }
    updateFhdPvtVar() {
        const parent = this.parent;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
        if (parent.upperCanvas) {
            this.upperContext = parent.upperCanvas.getContext('2d');
        }
    }
    reset() {
        this.fhdObj = { lastWidth: 0, lastVelocity: 0, time: 0, pointX: 0, pointY: 0 };
        this.isFreehandDrawing = this.isFreehandPointMoved = false;
        this.selPoints = [];
        this.dummyPoints = [];
        this.freehandDownPoint = { x: 0, y: 0 };
        this.selPointColl = {};
        this.fhdHovIdx = null;
        this.pointCounter = 0;
        this.fhdSelID = null;
        this.penStrokeWidth = undefined;
        this.currFHDIdx = 0;
        this.fhdSelIdx = null;
        this.tempFHDStyles = { strokeColor: null, fillColor: null, strokeWidth: null };
    }
    getModuleName() {
        return 'freehand-draw';
    }
    hoverFhd(fillStyle, strokeWidth) {
        const parent = this.parent;
        parent.lowerCanvas = document.querySelector('#' + parent.element.id + '_lowerCanvas');
        this.lowerContext = parent.lowerCanvas.getContext('2d');
        parent.upperCanvas = document.querySelector('#' + parent.element.id + '_upperCanvas');
        this.upperContext = parent.upperCanvas.getContext('2d');
        const context = this.upperContext;
        let idx = -1;
        if (this.fhdHovIdx > -1) {
            idx = this.fhdHovIdx;
        }
        else {
            idx = this.fhdSelIdx;
        }
        parent.points = extend([], parent.pointColl[idx].points);
        this.pointCounter = 0;
        const len = parent.points.length;
        let controlPoint1;
        let controlPoint2;
        let startPoint;
        let endPoint;
        let minStrokeWidth = 0;
        let maxStrokeWidth = 0;
        context.fillStyle = fillStyle ? fillStyle : parent.pointColl[idx].strokeColor;
        context.strokeStyle = context.fillStyle;
        minStrokeWidth = maxStrokeWidth = this.penStrokeWidth = strokeWidth ?
            strokeWidth : parent.pointColl[idx].strokeWidth;
        if (len === 1) {
            controlPoint1 = controlPoint2 = startPoint = endPoint = parent.points[0];
            this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
        }
        for (let l = 0; l < len - 3; l++) {
            if (parent.points[l + 1] && parent.points[l + 2] && parent.points[l + 2]) {
                controlPoint1 = (this.calcCurveCP(parent.points[l + 0], parent.points[l + 1], parent.points[l + 2])).controlPoint2;
                controlPoint2 = (this.calcCurveCP(parent.points[l + 1], parent.points[l + 2], parent.points[l + 3])).controlPoint1;
                if (l === 0) {
                    startPoint = parent.points[l];
                }
                else {
                    startPoint = parent.points[l + 1];
                }
                endPoint = parent.points[l + 2];
                this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
            }
        }
        context.closePath();
        // Outer selection
        const point = this.getSqPtFD(idx);
        const tempLineWidth = context.lineWidth;
        context.lineWidth = 2;
        context.strokeStyle = parent.themeColl[parent.theme]['primaryColor'];
        context.beginPath();
        context.rect(point.startX, point.startY, point.width, point.height);
        context.stroke();
        context.closePath();
        context.lineWidth = tempLineWidth;
    }
    freehandDownHandler(e, canvas) {
        this.parent.lowerCanvas = document.querySelector('#' + this.parent.element.id + '_lowerCanvas');
        this.lowerContext = this.parent.lowerCanvas.getContext('2d');
        this.parent.upperCanvas = document.querySelector('#' + this.parent.element.id + '_upperCanvas');
        this.upperContext = this.parent.upperCanvas.getContext('2d');
        this.fhdObj.time = new Date().getTime();
        this.isFreehandDrawing = true;
        if (e.type === 'mousedown') {
            this.freehandDownPoint = { x: e.clientX, y: e.clientY };
        }
        else {
            this.freehandDownPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
        this.isFreehandPointMoved = false;
        EventHandler.add(canvas, 'mousemove touchmove', this.freehandMoveHandler, this);
    }
    freehandUpHandler(e, canvas, context) {
        const rect = canvas.getBoundingClientRect();
        const parent = this.parent;
        EventHandler.remove(canvas, 'mousemove touchmove', this.freehandMoveHandler);
        if (parent.points.length === 0) {
            if (e.type === 'mouseup') {
                this.processPoint(e.clientX - rect.left, e.clientY - rect.top, true, context);
            }
            else {
                if (!this.isFreehandPointMoved) {
                    this.processPoint(this.freehandDownPoint.x - rect.left, this.freehandDownPoint.y - rect.top, true, context);
                }
            }
        }
        context.closePath();
        const prevCropObj = extend({}, parent.cropObj, {}, true);
        const object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        const fhCnt = parent.freehandCounter;
        parent.pointColl[fhCnt] = {};
        parent.pointColl[fhCnt].points = extend([], parent.points);
        parent.pointColl[fhCnt].strokeColor = parent.activeObj.strokeSettings.strokeColor;
        parent.pointColl[fhCnt].strokeWidth = this.penStrokeWidth;
        parent.pointColl[fhCnt].flipState = parent.transform.currFlipState;
        parent.pointColl[fhCnt].id = 'pen_' + (this.currFHDIdx + 1);
        parent.points = [];
        this.dummyPoints = [];
        this.selPointColl[fhCnt] = {};
        this.selPointColl[fhCnt].points = extend([], this.selPoints);
        this.selPoints = [];
        this.pointCounter = 0;
        parent.freehandCounter++;
        this.currFHDIdx++;
        this.isFreehandDrawing = false;
        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
            value: { operation: 'freehand-draw', previousObj: prevObj, previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj, previousText: null,
                currentText: null, previousFilter: null, isCircleCrop: null } });
    }
    freehandMoveHandler(e) {
        this.isFreehandPointMoved = true;
        const rect = this.parent.upperCanvas.getBoundingClientRect();
        let x;
        let y;
        if (e.type === 'mousemove') {
            x = e.clientX - rect.left;
            y = e.clientY - rect.top;
        }
        else {
            x = e.touches[0].clientX - rect.left;
            y = e.touches[0].clientY - rect.top;
        }
        if (this.isFreehandDrawing) {
            this.processPoint(x, y, false, this.upperContext);
        }
    }
    processPoint(x, y, mouseDown, context) {
        const parent = this.parent;
        let lastPoint = this.point(x, y, new Date().getTime());
        lastPoint = parent.points.length > 0 && parent.points[parent.points.length - 1];
        const isLastPointTooClose = lastPoint ? this.distanceTo(lastPoint) <= 5 : false;
        let controlPoint1;
        let controlPoint2;
        let startPoint;
        let endPoint;
        this.selPoints.push({ x: x, y: y, ratioX: (x - parent.img.destLeft) / parent.img.destWidth,
            ratioY: (y - parent.img.destTop) / parent.img.destHeight,
            time: this.fhdObj.time });
        if (!lastPoint || !(lastPoint && isLastPointTooClose) || mouseDown) {
            this.fhdObj.time = new Date().getTime();
            parent.points.push({ x: x, y: y, ratioX: (x - parent.img.destLeft) / parent.img.destWidth,
                ratioY: (y - parent.img.destTop) / parent.img.destHeight,
                time: this.fhdObj.time });
            this.dummyPoints.push({ x: x, y: y, ratioX: (x - parent.img.destLeft) / parent.img.destWidth,
                ratioY: (y - parent.img.destTop) / parent.img.destHeight,
                time: this.fhdObj.time });
            if (this.dummyPoints.length > 2) {
                if (this.dummyPoints.length === 3) {
                    this.dummyPoints.unshift(this.dummyPoints[0]);
                }
                const p0 = this.dummyPoints[0];
                const p1 = this.dummyPoints[1];
                const p2 = this.dummyPoints[2];
                const p3 = this.dummyPoints[3];
                controlPoint1 = this.calcCurveCP(p0, p1, p2).controlPoint2;
                controlPoint2 = this.calcCurveCP(p1, p2, p3).controlPoint1;
                startPoint = this.dummyPoints[1];
                endPoint = this.dummyPoints[2];
                let minStrokeWidth = 0.5;
                let maxStrokeWidth = 5;
                if (!isNullOrUndefined(this.penStrokeWidth)) {
                    minStrokeWidth = maxStrokeWidth = this.penStrokeWidth;
                }
                this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
                this.pointCounter++;
                this.dummyPoints.shift();
            }
            if (mouseDown) {
                controlPoint1 = controlPoint2 = startPoint = endPoint = { x: x, y: y, time: new Date().getTime() };
                let minStrokeWidth = 0.5;
                let maxStrokeWidth = 5;
                if (!isNullOrUndefined(this.penStrokeWidth)) {
                    minStrokeWidth = maxStrokeWidth = this.penStrokeWidth;
                }
                this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
            }
        }
    }
    calcCurveCP(p1, p2, p3) {
        if (!p2) {
            p2 = p1;
        }
        if (!p3) {
            p3 = p2;
        }
        const dx1 = p1.x - p2.x;
        const dy1 = p1.y - p2.y;
        const dx2 = p2.x - p3.x;
        const dy2 = p2.y - p3.y;
        const m1 = { x: (p1.x + p2.x) / 2.0, y: (p1.y + p2.y) / 2.0 };
        const m2 = { x: (p2.x + p3.x) / 2.0, y: (p2.y + p3.y) / 2.0 };
        const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
        const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
        const dxm = (m1.x - m2.x);
        const dym = (m1.y - m2.y);
        const k = l2 / (l1 + l2);
        const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };
        const tx = p2.x - cm.x;
        const ty = p2.y - cm.y;
        return {
            controlPoint1: this.point(m1.x + tx, m1.y + ty, 0),
            controlPoint2: this.point(m2.x + tx, m2.y + ty, 0)
        };
    }
    point(x, y, time) {
        this.fhdObj.pointX = x;
        this.fhdObj.pointY = y;
        return { x: this.fhdObj.pointX, y: this.fhdObj.pointY, time: time };
    }
    startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth) {
        let tempVelocity;
        tempVelocity = this.pointVelocity(startPoint);
        tempVelocity = 0.7 * tempVelocity + (1 - 0.7) * this.fhdObj.lastVelocity;
        const newWidth = Math.max(maxStrokeWidth / (0.7 + 1), minStrokeWidth);
        this.drawCurve(this.fhdObj.time, newWidth, context, controlPoint1, controlPoint2, startPoint, endPoint, maxStrokeWidth);
        this.fhdObj.lastVelocity = tempVelocity;
        this.fhdObj.time = newWidth;
    }
    pointVelocity(startPoint) {
        return (this.fhdObj.time !== startPoint.time) ? this.distanceTo(startPoint) /
            (this.fhdObj.time - startPoint.time) : 0;
    }
    distanceTo(start) {
        return Math.sqrt(Math.pow(this.fhdObj.pointX - start.x, 2) + Math.pow(this.fhdObj.pointY - start.y, 2));
    }
    drawCurve(startWidth, endWidth, context, controlPoint1, controlPoint2, startPoint, endPoint, maxStrokeWidth) {
        let width;
        let i;
        let t1;
        let t2;
        let t3;
        let u1;
        let u2;
        let u3;
        let x;
        let y;
        const widthValue = endWidth - startWidth;
        const bezierLength = this.bezierLength(controlPoint1, controlPoint2, startPoint, endPoint);
        const drawSteps = Math.ceil(bezierLength) * 2;
        context.beginPath();
        for (i = 0; i < drawSteps; i++) {
            t1 = i / drawSteps;
            t2 = t1 * t1;
            t3 = t2 * t1;
            u1 = 1 - t1;
            u2 = u1 * u1;
            u3 = u2 * u1;
            x = u3 * startPoint.x;
            x += 3 * u2 * t1 * controlPoint1.x;
            x += 3 * u1 * t2 * controlPoint2.x;
            x += t3 * endPoint.x;
            y = u3 * startPoint.y;
            y += 3 * u2 * t1 * controlPoint1.y;
            y += 3 * u1 * t2 * controlPoint2.y;
            y += t3 * endPoint.y;
            width = Math.min(startWidth + t3 * widthValue, maxStrokeWidth);
            this.drawArc(x, y, width, context);
        }
        context.closePath();
        context.fill();
    }
    bezierLength(controlPoint1, controlPoint2, startPoint, endPoint) {
        const steps = 10;
        let length = 0;
        let i;
        let t;
        let pointX1;
        let pointY1;
        let pointX2;
        let pointY2;
        let pointX3;
        let pointY3;
        for (i = 0; i <= steps; i++) {
            t = i / steps;
            pointX1 = this.bezierPoint(t, startPoint.x, controlPoint1.x, controlPoint2.x, endPoint.x);
            pointY1 = this.bezierPoint(t, startPoint.y, controlPoint1.y, controlPoint2.y, endPoint.y);
            if (i > 0) {
                pointX3 = pointX1 - pointX2;
                pointY3 = pointY1 - pointY2;
                length += Math.sqrt(pointX3 * pointX3 + pointY3 * pointY3);
            }
            pointX2 = pointX1;
            pointY2 = pointY1;
        }
        return length;
    }
    bezierPoint(t, startPoint, cp1, cp2, endPoint) {
        return startPoint * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * cp1 * (1.0 - t) * (1.0 - t) * t + 3.0 *
            cp2 * (1.0 - t) * t * t + endPoint * t * t * t;
    }
    drawArc(x, y, size, context) {
        if ((x > this.parent.img.destLeft && y > this.parent.img.destTop && x < (this.parent.img.destLeft + this.parent.img.destWidth) &&
            y < (this.parent.img.destTop + this.parent.img.destHeight) ||
            (context !== this.lowerContext && context !== this.upperContext))) {
            context.moveTo(x, y);
            context.arc(x, y, size, 0, 2 * Math.PI, false);
        }
    }
    freehandRedraw(context, points) {
        const parent = this.parent;
        parent.lowerCanvas = document.querySelector('#' + parent.element.id + '_lowerCanvas');
        this.lowerContext = parent.lowerCanvas.getContext('2d');
        parent.upperCanvas = document.querySelector('#' + parent.element.id + '_upperCanvas');
        this.upperContext = parent.upperCanvas.getContext('2d');
        const temp = context.filter;
        context.filter = 'none';
        if (points) {
            parent.pointColl[parent.freehandCounter] = {};
            parent.pointColl[parent.freehandCounter].points = points;
            parent.pointColl[parent.freehandCounter].strokeColor = parent.activeObj.strokeSettings.strokeColor;
            parent.pointColl[parent.freehandCounter].strokeWidth = this.penStrokeWidth;
            parent.pointColl[parent.freehandCounter].flipState = parent.transform.currFlipState;
            parent.freehandCounter++;
        }
        for (let n = 0; n < parent.freehandCounter; n++) {
            parent.points = extend([], parent.pointColl[n].points);
            this.pointCounter = 0;
            const len = parent.points.length;
            let controlPoint1;
            let controlPoint2;
            let startPoint;
            let endPoint;
            let minStrokeWidth;
            let maxStrokeWidth;
            if (len > 0) {
                context.fillStyle = parent.pointColl[n].strokeColor;
                minStrokeWidth = maxStrokeWidth = this.penStrokeWidth = parent.pointColl[n].strokeWidth;
            }
            if (len === 1) {
                controlPoint1 = controlPoint2 = startPoint = endPoint = parent.points[0];
                this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
            }
            for (let l = 0; l < len - 3; l++) {
                if (parent.points[l + 1] && parent.points[l + 2] && parent.points[l + 2]) {
                    controlPoint1 = (this.calcCurveCP(parent.points[l + 0], parent.points[l + 1], parent.points[l + 2])).controlPoint2;
                    controlPoint2 = (this.calcCurveCP(parent.points[l + 1], parent.points[l + 2], parent.points[l + 3])).controlPoint1;
                    if (l === 0) {
                        startPoint = parent.points[l];
                    }
                    else {
                        startPoint = parent.points[l + 1];
                    }
                    endPoint = parent.points[l + 2];
                    this.startDraw(context, controlPoint1, controlPoint2, startPoint, endPoint, minStrokeWidth, maxStrokeWidth);
                }
            }
            context.closePath();
        }
        context.filter = temp;
    }
    getSqPtFD(idx, obj) {
        const activePoint = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
        const sPoints = extend([], this.selPointColl[idx].points, []);
        this.parent.points = extend([], this.parent.pointColl[idx].points);
        this.pointCounter = 0;
        const len = sPoints.length;
        for (let l = 0; l < len; l++) {
            if (activePoint.startX === 0 && activePoint.startY === 0 && activePoint.endX === 0 && activePoint.endY === 0) {
                activePoint.startX = sPoints[l].x;
                activePoint.startY = sPoints[l].y;
                activePoint.endX = sPoints[l].x;
                activePoint.endY = sPoints[l].y;
            }
            else {
                activePoint.startX = Math.min(activePoint.startX, sPoints[l].x);
                activePoint.startY = Math.min(activePoint.startY, sPoints[l].y);
                activePoint.endX = Math.max(activePoint.endX, sPoints[l].x);
                activePoint.endY = Math.max(activePoint.endY, sPoints[l].y);
            }
        }
        activePoint.startX -= this.penStrokeWidth;
        activePoint.startY -= this.penStrokeWidth;
        activePoint.endX += this.penStrokeWidth;
        activePoint.endY += this.penStrokeWidth;
        activePoint.width = activePoint.endX - activePoint.startX;
        activePoint.height = activePoint.endY - activePoint.startY;
        if (obj) {
            obj['activePoint'] = activePoint;
        }
        return activePoint;
    }
    applyPenDraw() {
        const parent = this.parent;
        if (parent.currObjType.shape === 'freehanddraw') {
            parent.notify('shape', { prop: 'apply', onPropertyChange: false, value: { shape: null, obj: null, canvas: null } });
            parent.upperCanvas.style.cursor = parent.cursor = 'default';
            parent.currObjType.shape = '';
        }
        parent.notify('shape', { prop: 'clearActObj' });
    }
    applyFhd() {
        const parent = this.parent;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const selectedPoint = parent.pointColl[this.fhdSelIdx];
        if (selectedPoint.strokeColor === '#42a5f5') {
            selectedPoint.strokeColor = this.tempFHDStyles.strokeColor;
        }
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'setSelectedFreehandColor', value: { color: '#42a5f5' } });
        }
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
        }
        if (selectedPoint) {
            selectedPoint.isSelected = false;
        }
        parent.notify('selection', { prop: 'resetFreehandDrawVariables' });
        this.fhdHovIdx = this.fhdSelIdx = null;
    }
    cancelFhd() {
        const parent = this.parent;
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'setSelectedFreehandColor', value: { color: '#42a5f5' } });
        }
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.pointCounter = 0;
        if (parent.pointColl[this.fhdSelIdx]) {
            parent.pointColl[this.fhdSelIdx].strokeColor = this.tempFHDStyles.strokeColor;
            parent.pointColl[this.fhdSelIdx].strokeWidth = this.tempFHDStyles.strokeWidth;
            parent.pointColl[this.fhdSelIdx].isSelected = false;
        }
        this.fhdHovIdx = this.fhdSelIdx = this.fhdSelID = null;
        parent.notify('selection', { prop: 'resetFreehandDrawVariables' });
        parent.activeObj.strokeSettings.strokeColor = this.tempFHDStyles.strokeColor;
        parent.activeObj.strokeSettings.strokeWidth = this.penStrokeWidth = this.tempFHDStyles.strokeWidth;
        this.tempFHDStyles = { strokeColor: null, strokeWidth: null, fillColor: null };
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
        }
    }
    selectFhd(index) {
        const parent = this.parent;
        parent.notify('selection', { prop: 'setFreehandDrawEditing', onPropertyChange: false, value: { bool: true } });
        if (index || index === 0) {
            if (this.isFHDIdx(index)) {
                this.fhdSelIdx = this.fhdHovIdx = index;
                this.hoverFhd();
                parent.upperCanvas.style.cursor = parent.cursor = 'pointer';
            }
            else {
                return;
            }
        }
        this.fhdSelIdx = this.fhdHovIdx;
        parent.pointColl[this.fhdSelIdx].isSelected = true;
        this.fhdSelID = parent.pointColl[this.fhdSelIdx].id;
        if (parent.pointColl[this.fhdHovIdx].strokeColor !== '#42a5f5') {
            parent.activeObj.strokeSettings.strokeColor = this.tempFHDStyles.strokeColor =
                parent.pointColl[this.fhdHovIdx].strokeColor;
        }
        parent.activeObj.strokeSettings.strokeWidth = this.tempFHDStyles.strokeWidth =
            parent.pointColl[this.fhdHovIdx].strokeWidth;
        const obj = { bool: false };
        parent.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
        if (obj['bool']) {
            const shapeSettings = { id: 'pen_' + (this.fhdSelIdx + 1), type: ShapeType.FreehandDraw,
                startX: parent.pointColl[this.fhdSelIdx].points[0].x, startY: parent.pointColl[this.fhdSelIdx].points[0].y,
                strokeColor: parent.pointColl[this.fhdSelIdx].strokeColor, strokeWidth: parent.pointColl[this.fhdSelIdx].strokeWidth,
                points: parent.pointColl[this.fhdSelIdx].points };
            const shapeChangingArgs = { action: 'select', previousShapeSettings: shapeSettings,
                currentShapeSettings: shapeSettings };
            if (isBlazor() && parent.events && parent.events.shapeChanging.hasDelegate === true) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                parent.dotNetRef.invokeMethodAsync('ShapeEventAsync', 'OnShape', shapeChangingArgs).then((shapeChangingArgs) => {
                    parent.activeObj.strokeSettings.strokeColor = parent.pointColl[this.fhdSelIdx].strokeColor =
                        shapeChangingArgs.currentShapeSettings.strokeColor;
                    parent.activeObj.strokeSettings.strokeWidth = parent.pointColl[this.fhdSelIdx].strokeWidth =
                        shapeChangingArgs.currentShapeSettings.strokeWidth;
                    parent.pointColl[this.fhdSelIdx].points = shapeChangingArgs.currentShapeSettings.points;
                    this.freehandRedraw(this.upperContext);
                    parent.updateToolbar(parent.element, 'colorToolbar');
                });
            }
            else {
                parent.trigger('shapeChanging', shapeChangingArgs);
                parent.activeObj.strokeSettings.strokeColor = parent.pointColl[this.fhdSelIdx].strokeColor =
                    shapeChangingArgs.currentShapeSettings.strokeColor;
                parent.activeObj.strokeSettings.strokeWidth = parent.pointColl[this.fhdSelIdx].strokeWidth =
                    shapeChangingArgs.currentShapeSettings.strokeWidth;
                parent.pointColl[this.fhdSelIdx].points = shapeChangingArgs.currentShapeSettings.points;
                this.freehandRedraw(this.upperContext);
                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'pen',
                        isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
            }
        }
        else {
            parent.okBtn();
        }
    }
    deleteFhd(index, isId) {
        const parent = this.parent;
        if (this.isFHDIdx(index)) {
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            // eslint-disable-next-line
            const tempPointColl = extend({}, parent.pointColl, {}, true);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const tempSelPointColl = extend({}, this.selPointColl, {}, true);
            parent.pointColl = {};
            this.selPointColl = {};
            let count = 0;
            if (isNullOrUndefined(isId)) {
                for (let i = 0; i < parent.freehandCounter; i++) {
                    if (i !== index) {
                        parent.pointColl[count] = tempPointColl[i];
                        this.selPointColl[count] = tempSelPointColl[i];
                        count++;
                    }
                }
            }
            else {
                for (let i = 0; i < parent.freehandCounter; i++) {
                    if (parseInt(tempPointColl[i].id.split('_')[1], 10) - 1 !== index) {
                        parent.pointColl[count] = tempPointColl[i];
                        this.selPointColl[count] = tempSelPointColl[i];
                        count++;
                    }
                }
            }
            parent.freehandCounter -= 1;
            this.fhdHovIdx = this.fhdSelIdx = null;
            parent.notify('selection', { prop: 'resetFreehandDrawVariables' });
            parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: true } });
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            }
        }
    }
    zoomX(x) {
        return (x * this.parent.img.destWidth) + this.parent.img.destLeft;
    }
    zoomY(y) {
        return (y * this.parent.img.destHeight) + this.parent.img.destTop;
    }
    zoomFHDColl(isPreventApply) {
        const parent = this.parent;
        // Updating point collection for zoom
        for (let n = 0; n < parent.freehandCounter; n++) {
            parent.points = extend([], parent.pointColl[n].points, []);
            this.pointCounter = 0;
            const len = parent.points.length;
            for (let l = 0; l < len; l++) {
                parent.points[l].x = this.zoomX(parent.points[l].ratioX);
                parent.points[l].y = this.zoomY(parent.points[l].ratioY);
            }
        }
        // Updating each points for cursor styles for zoom
        this.updateFHDCurPts();
        if (isNullOrUndefined(isPreventApply)) {
            this.freehandRedraw(this.lowerContext, null);
        }
    }
    updateFHDCurPts() {
        const parent = this.parent;
        for (let n = 0; n < parent.freehandCounter; n++) {
            if (this.selPointColl[n]) {
                this.selPoints = extend([], this.selPointColl[n].points, []);
                this.pointCounter = 0;
                const len = this.selPoints.length;
                for (let l = 0; l < len; l++) {
                    this.selPoints[l].x = this.zoomX(this.selPoints[l].ratioX);
                    this.selPoints[l].y = this.zoomY(this.selPoints[l].ratioY);
                }
            }
        }
    }
    rotateFhdColl() {
        const parent = this.parent;
        // Update rotation points for point collection
        for (let n = 0; n < parent.freehandCounter; n++) {
            parent.points = extend([], parent.pointColl[n].points, []);
            this.pointCounter = 0;
            const len = parent.points.length;
            for (let l = 0; l < len; l++) {
                parent.points[l].y = parent.img.destTop + (parent.img.destHeight * parent.points[l].ratioX);
                parent.points[l].x = (parent.img.destLeft + parent.img.destWidth) - (parent.img.destWidth *
                    parent.points[l].ratioY);
                parent.points[l].ratioX = (parent.points[l].x - parent.img.destLeft) / parent.img.destWidth;
                parent.points[l].ratioY = (parent.points[l].y - parent.img.destTop) / parent.img.destHeight;
            }
        }
        // Update rotation points for each point for cursor styles
        for (let n = 0; n < parent.freehandCounter; n++) {
            if (this.selPointColl[n]) {
                this.selPoints = extend([], this.selPointColl[n].points, []);
                this.pointCounter = 0;
                const len = this.selPoints.length;
                for (let l = 0; l < len; l++) {
                    this.selPoints[l].y = parent.img.destTop + (parent.img.destHeight * this.selPoints[l].ratioX);
                    this.selPoints[l].x = (parent.img.destLeft + parent.img.destWidth) - (parent.img.destWidth *
                        this.selPoints[l].ratioY);
                    this.selPoints[l].ratioX = (this.selPoints[l].x - parent.img.destLeft) / parent.img.destWidth;
                    this.selPoints[l].ratioY = (this.selPoints[l].y - parent.img.destTop) / parent.img.destHeight;
                }
            }
        }
        this.updateFHDCurPts();
    }
    flipFHDColl(value) {
        const lowercaseValue = value.toLowerCase();
        if (lowercaseValue === 'horizontal') {
            this.pointsHorizontalFlip();
        }
        else if (lowercaseValue === 'vertical') {
            this.pointsVerticalFlip();
        }
        else {
            this.pointsHorizontalFlip();
            for (let i = 0; i < this.parent.freehandCounter; i++) {
                this.parent.pointColl[i].shapeFlip = '';
            }
            this.pointsVerticalFlip();
        }
    }
    pointsHorizontalFlip() {
        const parent = this.parent;
        // Update flip value for point collection
        for (let n = 0; n < parent.freehandCounter; n++) {
            if (parent.pointColl[n].shapeFlip !== parent.transform.currFlipState) {
                parent.points = extend([], parent.pointColl[n].points, []);
                this.pointCounter = 0;
                const len = parent.points.length;
                for (let l = 0; l < len; l++) {
                    if (parent.points[l].x <= parent.img.destLeft + (parent.img.destWidth / 2)) {
                        parent.points[l].x = (parent.img.destLeft + parent.img.destWidth) - (parent.points[l].x
                            - parent.img.destLeft);
                    }
                    else if (parent.points[l].x >= parent.img.destLeft + (parent.img.destWidth / 2)) {
                        parent.points[l].x = parent.img.destLeft + (parent.img.destLeft + parent.img.destWidth -
                            parent.points[l].x);
                    }
                    parent.points[l].ratioX = (parent.points[l].x - parent.img.destLeft) / parent.img.destWidth;
                    parent.points[l].ratioY = (parent.points[l].y - parent.img.destTop) / parent.img.destHeight;
                }
                parent.pointColl[n].shapeFlip = parent.transform.currFlipState;
            }
        }
        // Update flip value for each points for cursor styles
        for (let n = 0; n < parent.freehandCounter; n++) {
            if (this.selPointColl[n]) {
                if (this.selPointColl[n].shapeFlip !== parent.transform.currFlipState) {
                    this.selPoints = extend([], this.selPointColl[n].points, []);
                    this.pointCounter = 0;
                    const len = this.selPoints.length;
                    for (let l = 0; l < len; l++) {
                        if (this.selPoints[l].x <= parent.img.destLeft + (parent.img.destWidth / 2)) {
                            this.selPoints[l].x = (parent.img.destLeft + parent.img.destWidth) - (this.selPoints[l].x -
                                parent.img.destLeft);
                        }
                        else if (this.selPoints[l].x >= parent.img.destLeft + (parent.img.destWidth / 2)) {
                            this.selPoints[l].x = parent.img.destLeft + (parent.img.destLeft + parent.img.destWidth -
                                this.selPoints[l].x);
                        }
                        this.selPoints[l].ratioX = (this.selPoints[l].x - parent.img.destLeft) / parent.img.destWidth;
                        this.selPoints[l].ratioY = (this.selPoints[l].y - parent.img.destTop) / parent.img.destHeight;
                    }
                }
            }
        }
        this.updateFHDCurPts();
    }
    pointsVerticalFlip() {
        const parent = this.parent;
        // Update flip value for point collection
        for (let n = 0; n < parent.freehandCounter; n++) {
            if (parent.pointColl[n].shapeFlip !== parent.transform.currFlipState) {
                parent.points = extend([], parent.pointColl[n].points, []);
                this.pointCounter = 0;
                const len = parent.points.length;
                for (let l = 0; l < len; l++) {
                    if (parent.points[l].y <= parent.img.destTop + (parent.img.destHeight / 2)) {
                        parent.points[l].y = (parent.img.destTop + parent.img.destHeight) -
                            (parent.points[l].y - parent.img.destTop);
                    }
                    else if (parent.points[l].y >= parent.img.destTop + (parent.img.destHeight / 2)) {
                        parent.points[l].y = parent.img.destTop + (parent.img.destTop + parent.img.destHeight -
                            parent.points[l].y);
                    }
                    parent.points[l].ratioX = (parent.points[l].x - parent.img.destLeft) / parent.img.destWidth;
                    parent.points[l].ratioY = (parent.points[l].y - parent.img.destTop) / parent.img.destHeight;
                }
                parent.pointColl[n].shapeFlip = parent.transform.currFlipState;
            }
        }
        // Update flip value for each points for cursor styles
        for (let n = 0; n < parent.freehandCounter; n++) {
            if (this.selPointColl[n]) {
                if (this.selPointColl[n].shapeFlip !== parent.transform.currFlipState) {
                    this.selPoints = extend([], this.selPointColl[n].points, []);
                    this.pointCounter = 0;
                    const len = this.selPoints.length;
                    for (let l = 0; l < len; l++) {
                        if (this.selPoints[l].y <= parent.img.destTop + (parent.img.destHeight / 2)) {
                            this.selPoints[l].y = (parent.img.destTop + parent.img.destHeight) - (this.selPoints[l].y -
                                parent.img.destTop);
                        }
                        else if (this.selPoints[l].y >= parent.img.destTop + (parent.img.destHeight / 2)) {
                            this.selPoints[l].y = parent.img.destTop + (parent.img.destTop + parent.img.destHeight -
                                this.selPoints[l].y);
                        }
                        this.selPoints[l].ratioX = (this.selPoints[l].x - parent.img.destLeft) / parent.img.destWidth;
                        this.selPoints[l].ratioY = (this.selPoints[l].y - parent.img.destTop) / parent.img.destHeight;
                    }
                }
            }
        }
        this.updateFHDCurPts();
    }
    updateFHDColl() {
        const parent = this.parent;
        for (let i = 0; i < parent.objColl.length; i++) {
            parent.objColl[i].imageRatio = { startX: ((parent.objColl[i].activePoint.startX - parent.img.destLeft) /
                    parent.img.destWidth), startY: ((parent.objColl[i].activePoint.startY - parent.img.destTop) / parent.img.destHeight),
                endX: ((parent.objColl[i].activePoint.endX - parent.img.destLeft) / parent.img.destWidth),
                endY: ((parent.objColl[i].activePoint.endY - parent.img.destTop) / parent.img.destHeight),
                width: parent.img.destWidth / parent.objColl[i].activePoint.width, height: parent.img.destHeight /
                    parent.objColl[i].activePoint.height };
            if (parent.objColl[i].shape === 'path') {
                for (let j = 0; j < parent.objColl[i].pointColl.length; j++) {
                    parent.objColl[i].pointColl[j].ratioX =
                        (parent.objColl[i].pointColl[j].x - parent.img.destLeft) / parent.img.destWidth;
                    parent.objColl[i].pointColl[j].ratioY =
                        (parent.objColl[i].pointColl[j].y - parent.img.destTop) / parent.img.destHeight;
                }
            }
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        }
        for (let n = 0; n < parent.freehandCounter; n++) {
            parent.points = extend([], parent.pointColl[n].points, []);
            this.pointCounter = 0;
            const len = parent.points.length;
            for (let l = 0; l < len; l++) {
                parent.points[l].ratioX = (parent.points[l].x - parent.img.destLeft) / parent.img.destWidth;
                parent.points[l].ratioY = (parent.points[l].y - parent.img.destTop) / parent.img.destHeight;
            }
        }
        for (let n = 0; n < parent.freehandCounter; n++) {
            if (this.selPointColl[n]) {
                this.selPoints = extend([], this.selPointColl[n].points, []);
                this.pointCounter = 0;
                const len = this.selPoints.length;
                for (let l = 0; l < len; l++) {
                    this.selPoints[l].ratioX = (this.selPoints[l].x - parent.img.destLeft) / parent.img.destWidth;
                    this.selPoints[l].ratioY = (this.selPoints[l].y - parent.img.destTop) / parent.img.destHeight;
                }
            }
        }
    }
    panFHDColl(xDiff, yDiff, panRegion) {
        const parent = this.parent;
        // Updating point collection for panning
        for (let n = 0; n < parent.freehandCounter; n++) {
            parent.points = extend([], parent.pointColl[n].points, []);
            this.pointCounter = 0;
            const len = parent.points.length;
            for (let l = 0; l < len; l++) {
                if (panRegion === '' || panRegion === 'vertical') {
                    parent.points[l].x += xDiff;
                }
                else {
                    parent.points[l].x -= xDiff;
                }
                if (panRegion === '' || panRegion === 'horizontal') {
                    parent.points[l].y += yDiff;
                }
                else {
                    parent.points[l].y -= yDiff;
                }
            }
        }
        // Updating each points for cursor styles for panning
        for (let n = 0; n < parent.freehandCounter; n++) {
            if (this.selPointColl[n]) {
                this.selPoints = extend([], this.selPointColl[n].points, []);
                this.pointCounter = 0;
                const len = this.selPoints.length;
                for (let l = 0; l < len; l++) {
                    if (panRegion === '' || panRegion === 'vertical') {
                        this.selPoints[l].x += xDiff;
                    }
                    else {
                        this.selPoints[l].x -= xDiff;
                    }
                    if (panRegion === '' || panRegion === 'horizontal') {
                        this.selPoints[l].y += yDiff;
                    }
                    else {
                        this.selPoints[l].y -= yDiff;
                    }
                }
            }
        }
        this.freehandRedraw(this.lowerContext, null);
    }
    freeHandDraw(value) {
        const parent = this.parent;
        if (value) {
            parent.points = [];
            this.dummyPoints = [];
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.togglePen = true;
            parent.upperCanvas.style.cursor = parent.cursor = 'crosshair';
            parent.upperCanvas.style.display = 'block';
            if (isNullOrUndefined(parent.activeObj.strokeSettings)) {
                const obj = { strokeSettings: {} };
                parent.notify('shape', { prop: 'getStrokeSettings', onPropertyChange: false,
                    value: { obj: obj } });
                parent.activeObj.strokeSettings = obj['strokeSettings'];
            }
            if (isNullOrUndefined(parent.activeObj.strokeSettings.strokeWidth)) {
                parent.activeObj.strokeSettings.strokeWidth = 4;
            }
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'pen',
                        isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
            }
            else {
                parent.updateToolbar(parent.element, 'pen');
            }
        }
        else {
            parent.upperCanvas.style.cursor = parent.cursor = 'default';
            parent.notify('shape', { prop: 'apply', onPropertyChange: false, value: { shape: null, obj: null, canvas: null } });
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
                parent.notify('toolbar', { prop: 'setCurrentToolbar', value: { type: 'main' } });
            }
            else {
                parent.updateToolbar(parent.element, 'imageLoaded');
            }
            parent.notify('selection', { prop: 'setFreehandDrawCustomized', value: { isFreehandDrawCustomized: false } });
        }
    }
    isFHDIdx(index, obj) {
        let isIndex = false;
        for (let i = 0; i < this.parent.freehandCounter; i++) {
            if (this.parent.pointColl[i].id &&
                parseInt(this.parent.pointColl[i].id.split('_')[1], 10) - 1 === index) {
                isIndex = true;
                break;
            }
        }
        if (obj) {
            obj['isIndex'] = isIndex;
        }
        return isIndex;
    }
    updateCropPtsForSel() {
        const parent = this.parent;
        for (let n = 0; n < parent.freehandCounter; n++) {
            const obj = { selPointColl: extend([], this.selPointColl) };
            if (obj['selPointColl'][n]) {
                this.selPoints = extend([], obj['selPointColl'][n].points, []);
                this.pointCounter = 0;
                const len = this.selPoints.length;
                for (let l = 0; l < len; l++) {
                    this.selPoints[l].ratioX = (this.selPoints[l].x -
                        parent.activeObj.activePoint.startX) / parent.activeObj.activePoint.width;
                    this.selPoints[l].ratioY = (this.selPoints[l].y -
                        parent.activeObj.activePoint.startY) / parent.activeObj.activePoint.height;
                }
            }
        }
    }
}

class Selection {
    constructor(parent) {
        this.diffPoint = { x: 0, y: 0 }; // updates resize points
        this.oldPoint = {};
        this.isTouch = false;
        this.isObjSelected = false;
        this.isFhdPoint = false; // Specifies whether mouse cursor is on freehand drawing point or not
        this.dragPoint = { startX: 0, startY: 0, endX: 0, endY: 0 }; // updates drag start and end points in mousedown and mousemove
        this.isShapeInserted = false;
        this.tempActiveObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
            flipObjColl: [], triangle: [], triangleRatio: [] }; // for undo redo
        this.isFirstMove = false; // for pinch zoom
        this.startTouches = []; // for pinch zoom
        this.tempTouches = []; // for pinch zoom
        this.currMousePoint = { x: 0, y: 0 }; // To prevent mouse move event on pinch zoom
        this.cursorTargetId = '';
        this.isPreventDragging = false; // Shapes dragging is prevented when crop region is inside shape points
        this.dragElement = '';
        this.textRow = 1; // text area row count
        this.mouseDownPoint = { x: 0, y: 0 };
        this.previousPoint = { x: 0, y: 0 }; // updates prev x and y points in mouseMove
        this.zoomType = 'Toolbar';
        this.isInitialTextEdited = false;
        this.dragCanvas = false;
        this.isFhdCustomized = false;
        this.touchEndPoint = {};
        this.isFhdEditing = false; // Specifies whether freehand drawing is in editing mode or not
        this.currentDrawingShape = '';
        this.initialPrevObj = {};
        this.touchTime = 0;
        this.resizedElement = '';
        this.parent = parent;
        this.addEventListener();
    }
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    }
    addEventListener() {
        this.parent.on('selection', this.selection, this);
        this.parent.on('destroyed', this.destroy, this);
    }
    removeEventListener() {
        this.parent.off('selection', this.selection);
        this.parent.off('destroyed', this.destroy);
    }
    selection(args) {
        this.updatePrivateVariables();
        switch (args.prop) {
            case 'mouse-up':
                this.selMouseUpEvent();
                break;
            case 'setCursor':
                this.setCursor(args.value['x'], args.value['y']);
                break;
            case 'updateActivePoint':
                this.updateActivePoint(args.value['x'], args.value['y'], args.value['isCropSelection']);
                break;
            case 'updateCursorStyles':
                this.updateCursorStyles(args.value['x'], args.value['y'], args.value['type']);
                break;
            case 'setTextSelection':
                this.setTextSelection(args.value['width'], args.value['height']);
                break;
            case 'setActivePoint':
                this.setActivePoint(args.value['startX'], args.value['startY']);
                break;
            case 'clearSelection':
                this.clearSelection();
                break;
            case 'calcShapeRatio':
                this.calcShapeRatio(args.value['x'], args.value['y'], args.value['imgWidth'], args.value['imgHeight']);
                break;
            case 'applyCurrShape':
                this.applyCurrShape(args.value['isShapeClick']);
                break;
            case 'tab':
                this.performTabAction();
                break;
            case 'setDragDirection':
                this.setDragDirection(args.value['width'], args.value['height']);
                break;
            case 'clearUpperCanvas':
                if (this.isTouch) {
                    setTimeout(() => {
                        this.parent.upperCanvas.getContext('2d').clearRect(0, 0, this.parent.upperCanvas.width, this.parent.upperCanvas.height);
                    }, 550);
                }
                break;
            case 'resetFreehandDrawVariables':
                this.isFhdEditing = this.isFhdPoint = false;
                break;
            case 'isShapeInserted':
                this.isShapeInserted = args.value['bool'];
                break;
            case 'redrawShape':
                this.redrawShape(args.value['obj']);
                break;
            case 'setTextBoxStylesToActObj':
                this.setTextBoxStylesToActObj();
                break;
            case 'mouseDownEventHandler':
                this.mouseDownEventHandler(args.value['e']);
                break;
            case 'mouseMoveEventHandler':
                this.mouseMoveEventHandler(args.value['e']);
                break;
            case 'mouseUpEventHandler':
                this.mouseUpEventHandler(args.value['e']);
                break;
            case 'canvasMouseDownHandler':
                this.canvasMouseDownHandler(args.value['e']);
                break;
            case 'canvasMouseMoveHandler':
                this.canvasMouseMoveHandler(args.value['e']);
                break;
            case 'canvasMouseUpHandler':
                this.canvasMouseUpHandler(args.value['e']);
                break;
            case 'touchStartHandler':
                this.touchStartHandler(args.value['e']);
                break;
            case 'keyDownEventHandler':
                this.keyDownEventHandler(args.value['e']);
                break;
            case 'handleScroll':
                this.handleScroll(args.value['e']);
                break;
            case 'textKeyDown':
                setTimeout(this.textKeyDown.bind(this), 1, args.value['e']);
                break;
            case 'deleteItem':
                this.deleteItem();
                break;
            case 'updatePrevShapeSettings':
                this.updatePrevShapeSettings(args.value['obj']);
                break;
            case 'getZoomType':
                args.value['obj']['zoomType'] = this.zoomType;
                break;
            case 'setZoomType':
                this.zoomType = args.value['zoomType'];
                break;
            case 'setInitialTextEdit':
                this.isInitialTextEdited = args.value['bool'];
                break;
            case 'setDragCanvas':
                this.dragCanvas = args.value['bool'];
                break;
            case 'setFreehandDrawCustomized':
                this.isFhdCustomized = args.value['isFreehandDrawCustomized'];
                break;
            case 'setTouchEndPoint':
                this.touchEndPoint.x = args.value['x'];
                this.touchEndPoint.y = args.value['y'];
                break;
            case 'getPanDown':
                args.value['obj']['panDown'] = this.panDown;
                break;
            case 'setPanDown':
                this.panDown = args.value['panDown'];
                break;
            case 'getFreehandDrawEditing':
                args.value['obj']['bool'] = this.isFhdEditing;
                break;
            case 'setFreehandDrawEditing':
                this.isFhdEditing = args.value['bool'];
                break;
            case 'getTempActObj':
                args.value['obj']['tempObj'] = this.tempActiveObj;
                break;
            case 'setTempActObj':
                this.tempActiveObj = args.value['obj'];
                break;
            case 'isInside':
                this.isInside(args.value['x'], args.value['y'], args.value['z1'], args.value['z2'], args.value['z3'], args.value['z4']);
                break;
            case 'setDragElement':
                this.dragElement = args.value['value'];
                break;
            case 'setObjSelected':
                this.isObjSelected = args.value['bool'];
                break;
            case 'adjustActObjForLineArrow':
                this.adjustActObjForLineArrow(args.value['obj']);
                break;
            case 'findTarget':
                this.findTarget(args.value['x'], args.value['y'], args.value['type']);
                break;
            case 'getCurrentFlipState':
                this.getCurrentFlipState();
                break;
            case 'setDragWidth':
                this.setDragWidth(args.value['width']);
                break;
            case 'setDragHeight':
                this.setDragHeight(args.value['setDragHeight']);
                break;
            case 'annotate':
                this.currentDrawingShape = args.value['shape'];
                if (args.value['shape'] === 'text') {
                    this.parent.activeObj.textSettings.fontSize = 100;
                    this.parent.activeObj.keyHistory = 'Enter Text';
                    this.parent.notify('shape', { prop: 'initializeTextShape', onPropertyChange: false,
                        value: { text: null, fontFamily: null, fontSize: null, bold: null, italic: null, strokeColor: null } });
                }
                else if (args.value['shape'] === 'path') {
                    this.parent.activeObj.pointColl = [];
                }
                break;
            case 'getCurrentDrawingShape':
                args.value['obj']['shape'] = this.currentDrawingShape;
                break;
            case 'setCurrentDrawingShape':
                this.currentDrawingShape = args.value['value'];
                break;
            case 'getTransRotationPoint':
                this.getTransRotationPoint(args.value['obj'], args.value['object']);
                break;
            case 'adjustNEPoints':
                this.adjustNEPoints(args.value['rectangle'], args.value['x'], args.value['y'], args.value['angle']);
                break;
            case 'adjustRotationPoints':
                this.adjustRotationPoints(args.value['rectangle'], args.value['x'], args.value['y'], args.value['angle']);
                break;
            case 'getResizeDirection':
                this.getResizeDirection(args.value['rectangle'], args.value['x'], args.value['y'], args.value['angle']);
                break;
            case 'setResizedElement':
                this.resizedElement = args.value['value'];
                break;
            case 'reset':
                this.reset();
                break;
            case 'unWireEvent':
                this.unwireEvent();
                break;
            case 'updPtCollForShpRot':
                this.updPtCollForShpRot(args.value['obj']);
                break;
        }
    }
    getModuleName() {
        return 'selection';
    }
    updatePrivateVariables() {
        const parent = this.parent;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
        if (parent.upperCanvas) {
            this.upperContext = parent.upperCanvas.getContext('2d');
        }
    }
    reset() {
        this.diffPoint = { x: 0, y: 0 };
        this.oldPoint = {};
        this.isTouch = this.isObjSelected = this.isFhdPoint = this.isShapeInserted = false;
        this.dragPoint = { startX: 0, startY: 0, endX: 0, endY: 0 };
        this.tempActiveObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
            flipObjColl: [], triangle: [], triangleRatio: [] };
        this.isFirstMove = false;
        this.cursorTargetId = this.dragElement = '';
        this.startTouches = [];
        this.tempTouches = [];
        this.currMousePoint = { x: 0, y: 0 };
        this.isPreventDragging = false;
        this.timer = undefined;
        this.tempObjColl = undefined;
        this.textRow = 1;
        this.mouseDownPoint = { x: 0, y: 0 };
        this.previousPoint = { x: 0, y: 0 };
        this.zoomType = 'Toolbar';
        this.isInitialTextEdited = false;
        this.dragCanvas = false;
        this.isFhdCustomized = false;
        this.touchEndPoint = {};
        this.panDown = null;
        this.isFhdEditing = false;
        this.pathAdjustedIndex = null;
        this.touchTime = 0;
        this.currentDrawingShape = '';
        this.initialPrevObj = {};
        this.resizedElement = '';
    }
    performTabAction() {
        if (this.parent.textArea.style.display === 'block') {
            const allowUndoRedoPush = this.applyCurrShape(false);
            this.parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: null } });
            if (allowUndoRedoPush) {
                this.parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            }
        }
    }
    selMouseUpEvent() {
        this.oldPoint.x = undefined;
        this.oldPoint.y = undefined;
    }
    getMouseCursor(actObj, x, y, isCropSelection, isApply) {
        const rotationCirclePoint = this.getTransRotationPoint(actObj);
        let cursor = 'default';
        const ratio = isApply ? 0 : ((actObj.topLeftCircle.radius * 2));
        if (x >= (actObj.topLeftCircle.startX - ratio) &&
            x <= (actObj.topLeftCircle.startX + ratio) &&
            y >= (actObj.topLeftCircle.startY - ratio) &&
            y <= (actObj.topLeftCircle.startY + ratio)) {
            cursor = 'nw-resize';
        }
        else if (x >= (actObj.topLeftCircle.startX - ratio) &&
            x <= (actObj.topRightCircle.startX - ratio) &&
            y >= (actObj.topCenterCircle.startY - ratio) &&
            y <= (actObj.topCenterCircle.startY + ratio)) {
            cursor = 'n-resize';
        }
        else if (x >= (actObj.topRightCircle.startX - ratio) &&
            x <= (actObj.topRightCircle.startX + ratio) &&
            y >= (actObj.topRightCircle.startY - ratio) &&
            y <= (actObj.topRightCircle.startY + ratio)) {
            cursor = 'ne-resize';
        }
        else if (x >= (actObj.centerLeftCircle.startX - ratio) &&
            x <= (actObj.centerLeftCircle.startX + ratio) &&
            y >= (actObj.topLeftCircle.startY - ratio) &&
            y <= (actObj.bottomLeftCircle.startY - ratio)) {
            cursor = 'w-resize';
        }
        else if (x >= (actObj.centerRightCircle.startX - ratio) &&
            x <= (actObj.centerRightCircle.startX + ratio) &&
            y >= (actObj.topRightCircle.startY - ratio) &&
            y <= (actObj.bottomRightCircle.startY - ratio)) {
            cursor = 'e-resize';
        }
        else if (x >= (actObj.bottomLeftCircle.startX - ratio) &&
            x <= (actObj.bottomLeftCircle.startX + ratio) &&
            y >= (actObj.bottomLeftCircle.startY - ratio) &&
            y <= (actObj.bottomLeftCircle.startY + ratio)) {
            cursor = 'sw-resize';
        }
        else if (x >= (actObj.bottomLeftCircle.startX - ratio) &&
            x <= (actObj.bottomRightCircle.startX - ratio) &&
            y >= (actObj.bottomCenterCircle.startY - ratio) &&
            y <= (actObj.bottomCenterCircle.startY + ratio)) {
            cursor = 's-resize';
        }
        else if (x >= (actObj.bottomRightCircle.startX - ratio) &&
            x <= (actObj.bottomRightCircle.startX + ratio) &&
            y >= (actObj.bottomRightCircle.startY - ratio) &&
            y <= (actObj.bottomRightCircle.startY + ratio)) {
            cursor = 'se-resize';
        }
        else if ((x >= actObj.activePoint.startX &&
            x <= actObj.activePoint.endX) && (y >= actObj.activePoint.startY &&
            y <= actObj.activePoint.endY)) {
            if (isCropSelection) {
                cursor = 'grab';
            }
            else {
                cursor = 'move';
            }
        }
        else if (rotationCirclePoint && !isApply &&
            x >= (rotationCirclePoint.x - (actObj.bottomCenterCircle.radius + 2)) &&
            x <= rotationCirclePoint.x + (actObj.bottomCenterCircle.radius + 2) &&
            y >= rotationCirclePoint.y - (actObj.bottomCenterCircle.radius + 2) &&
            y <= rotationCirclePoint.y + (actObj.bottomCenterCircle.radius + 2)) {
            cursor = 'grabbing';
        }
        else {
            cursor = 'default';
        }
        return cursor;
    }
    setCursor(x, y) {
        const parent = this.parent;
        const lowerCanvas = document.querySelector('#' + parent.element.id + '_lowerCanvas');
        const upperCanvas = document.querySelector('#' + parent.element.id + '_upperCanvas');
        let isCropSelection = false;
        let splitWords;
        if (this.currentDrawingShape !== '') {
            upperCanvas.style.cursor = parent.cursor = 'crosshair';
            return;
        }
        if (parent.currObjType.isDragging) {
            if (this.dragElement === '') {
                upperCanvas.style.cursor = parent.cursor = 'move';
            }
            else {
                upperCanvas.style.cursor = parent.cursor = this.dragElement;
            }
            return;
        }
        if (parent.activeObj.horTopLine !== undefined) {
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (splitWords === undefined && parent.currObjType.isCustomCrop) {
                isCropSelection = true;
            }
            else if (splitWords !== undefined && splitWords[0] === 'crop') {
                isCropSelection = true;
            }
            if (!isCropSelection && parent.togglePan) {
                lowerCanvas.style.cursor = upperCanvas.style.cursor = parent.cursor = 'grab';
            }
            const cursor = upperCanvas.style.cursor;
            const actObj = extend({}, parent.activeObj, {}, true);
            this.cursorTargetId = actObj.currIndex;
            let degree;
            if (actObj.shapeDegree === 0) {
                degree = parent.transform.degree;
            }
            else {
                degree = parent.transform.degree - actObj.shapeDegree;
            }
            if (degree < 0) {
                degree = 360 + degree;
            }
            if (actObj.shape === 'line' || actObj.shape === 'arrow') {
                this.setCursorForLineArrow(actObj, x, y, upperCanvas);
            }
            else if (actObj.shape === 'path') {
                this.setCursorForPath(actObj, x, y, upperCanvas);
            }
            else if (!isNullOrUndefined(actObj.rotatedAngle) && actObj.rotatedAngle !== 0) {
                this.setCursorForRotatedObject(actObj, x, y, upperCanvas);
            }
            else {
                upperCanvas.style.cursor = parent.cursor = this.getMouseCursor(actObj, x, y, isCropSelection, false);
                if ((actObj.shape === 'text') && (parent.cursor === 'n-resize' ||
                    parent.cursor === 's-resize' || parent.cursor === 'e-resize' ||
                    parent.cursor === 'w-resize')) {
                    upperCanvas.style.cursor = parent.cursor = 'move';
                }
            }
            if (cursor === 'default' && parent.cursor === 'default' && isCropSelection) {
                upperCanvas.style.cursor = parent.cursor = 'grab';
            }
            if (cursor === 'grab' && parent.cursor === 'default') {
                upperCanvas.style.cursor = parent.cursor = 'grab';
            }
        }
        else if (parent.togglePan && !parent.togglePen) {
            lowerCanvas.style.cursor = upperCanvas.style.cursor = parent.cursor = 'grab';
        }
        else {
            if (parent.currObjType.isCustomCrop || parent.togglePen) {
                upperCanvas.style.cursor = parent.cursor = 'crosshair';
            }
            else {
                upperCanvas.style.cursor = parent.cursor = 'default';
            }
        }
        if (parent.cursor === 'default' || parent.cursor === 'grab') {
            const cursor = upperCanvas.style.cursor;
            if (parent.objColl.length > 0 && (parent.cursor !== 'grab' || !isCropSelection)) {
                this.setCursorFromObj(x, y, parent.objColl, upperCanvas, isCropSelection);
            }
            if (cursor === 'grab' && parent.cursor === 'default') {
                upperCanvas.style.cursor = parent.cursor = 'grab';
            }
        }
        if ((parent.cursor === 'default' || parent.cursor === 'grab')
            && parent.pointColl[0] && (parent.cursor !== 'grab' || !isCropSelection)
            && !parent.currObjType.isDragging && !parent.currObjType.isResize) {
            this.setCursorForFreehandDrawing(x, y, upperCanvas);
        }
    }
    setCursorForPath(actObj, x, y, upperCanvas) {
        this.setCursorForLineArrow(actObj, x, y, upperCanvas);
        const parent = this.parent;
        if (parent.cursor === 'default') {
            const obj = extend({}, actObj, null, true);
            let isMove = false;
            for (let i = 1; i < actObj.pointColl.length; i++) {
                if (isMove) {
                    break;
                }
                obj.activePoint.startX = actObj.pointColl[i - 1].x;
                obj.activePoint.startY = actObj.pointColl[i - 1].y;
                obj.activePoint.endX = actObj.pointColl[i].x;
                obj.activePoint.endY = actObj.pointColl[i].y;
                parent.notify('shape', { prop: 'setPointCollForLineArrow', onPropertyChange: false,
                    value: { obj: obj } });
                for (let j = 0; j < obj.pointColl.length; j++) {
                    const point = obj.pointColl[j];
                    if (!isNullOrUndefined(point.x - (actObj.topLeftCircle.radius * 2)) &&
                        !isNullOrUndefined(point.x + (actObj.topLeftCircle.radius * 2)) &&
                        !isNullOrUndefined(point.y - (actObj.topLeftCircle.radius * 2)) &&
                        !isNullOrUndefined(point.y + (actObj.topLeftCircle.radius * 2)) &&
                        x >= (point.x - (actObj.topLeftCircle.radius * 2)) &&
                        x <= (point.x + (actObj.topLeftCircle.radius * 2)) &&
                        y >= (point.y - (actObj.topLeftCircle.radius * 2)) &&
                        y <= (point.y + (actObj.topLeftCircle.radius * 2))) {
                        upperCanvas.style.cursor = parent.cursor = 'move';
                        isMove = true;
                        break;
                    }
                    else {
                        upperCanvas.style.cursor = parent.cursor = 'default';
                    }
                }
            }
        }
        return parent.cursor;
    }
    setCursorForLineArrow(actObj, x, y, upperCanvas) {
        let index;
        for (let i = 0; i < actObj.pointColl.length; i++) {
            const point = actObj.pointColl[i];
            if (x >= (point.x - (actObj.topLeftCircle.radius * 2)) && x <= (point.x + (actObj.topLeftCircle.radius * 2)) &&
                y >= (point.y - (actObj.topLeftCircle.radius * 2)) && y <= (point.y + (actObj.topLeftCircle.radius * 2))) {
                upperCanvas.style.cursor = this.parent.cursor = 'move';
                index = i;
                break;
            }
            else {
                upperCanvas.style.cursor = this.parent.cursor = 'default';
            }
        }
        return index;
    }
    setCursorForRotatedObject(actObj, x, y, upperCanvas) {
        this.resizedElement = '';
        const parent = this.parent;
        if (x >= (actObj.horTopLinePointColl[0].x - (actObj.bottomCenterCircle.radius + 2)) &&
            x <= (actObj.horTopLinePointColl[0].x + (actObj.bottomCenterCircle.radius + 2)) &&
            y >= (actObj.horTopLinePointColl[0].y - (actObj.bottomCenterCircle.radius + 2)) &&
            y <= (actObj.horTopLinePointColl[0].y + (actObj.bottomCenterCircle.radius + 2))) {
            upperCanvas.style.cursor = parent.cursor = 'nw-resize';
        }
        else if (x >= (actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length / 2)].x - 5) &&
            x <= (actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length / 2)].x + 5) &&
            y >= (actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length / 2)].y - 5) &&
            y <= (actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length / 2)].y + 5)) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'n-resize';
        }
        else if (x >= (actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length - 1)].x -
            (actObj.bottomCenterCircle.radius + 2)) &&
            x <= (actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length - 1)].x +
                (actObj.bottomCenterCircle.radius + 2)) &&
            y >= (actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length - 1)].y -
                (actObj.bottomCenterCircle.radius + 2)) &&
            y <= (actObj.horTopLinePointColl[Math.round(actObj.horTopLinePointColl.length - 1)].y +
                (actObj.bottomCenterCircle.radius + 2))) {
            upperCanvas.style.cursor = parent.cursor = 'ne-resize';
        }
        else if (x >= (actObj.verLeftLinePointColl[Math.round(actObj.verLeftLinePointColl.length / 2)].x - 5) &&
            x <= (actObj.verLeftLinePointColl[Math.round(actObj.verLeftLinePointColl.length / 2)].x + 5) &&
            y >= (actObj.verLeftLinePointColl[Math.round(actObj.verLeftLinePointColl.length / 2)].y - 5)
            && y <= (actObj.verLeftLinePointColl[Math.round(actObj.verLeftLinePointColl.length / 2)].y + 5)) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'w-resize';
        }
        else if (x >= (actObj.verRightLinePointColl[Math.round(actObj.verRightLinePointColl.length / 2)].x - 5) &&
            x <= (actObj.verRightLinePointColl[Math.round(actObj.verRightLinePointColl.length / 2)].x + 5)
            && y >= (actObj.verRightLinePointColl[Math.round(actObj.verRightLinePointColl.length / 2)].y - 5) &&
            y <= (actObj.verRightLinePointColl[Math.round(actObj.verRightLinePointColl.length / 2)].y + 5)) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'e-resize';
        }
        else if (x >= (actObj.horBottomLinePointColl[0].x - (actObj.bottomCenterCircle.radius + 2)) &&
            x <= (actObj.horBottomLinePointColl[0].x + (actObj.bottomCenterCircle.radius + 2)) &&
            y >= (actObj.horBottomLinePointColl[0].y - (actObj.bottomCenterCircle.radius + 2)) &&
            y <= (actObj.horBottomLinePointColl[0].y + (actObj.bottomCenterCircle.radius + 2))) {
            upperCanvas.style.cursor = parent.cursor = 'sw-resize';
        }
        else if (x >= (actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length / 2)].x - 5) &&
            x <= (actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length / 2)].x + 5) &&
            y >= (actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length / 2)].y - 5) &&
            y <= (actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length / 2)].y + 5)) {
            upperCanvas.style.cursor = parent.cursor = this.resizedElement = 's-resize';
        }
        else if (x >= (actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length - 1)].x -
            (actObj.bottomCenterCircle.radius + 2)) &&
            x <= (actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length - 1)].x +
                (actObj.bottomCenterCircle.radius + 2)) &&
            y >= (actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length - 1)].y -
                (actObj.bottomCenterCircle.radius + 2)) &&
            y <= (actObj.horBottomLinePointColl[Math.round(actObj.horBottomLinePointColl.length - 1)].y +
                (actObj.bottomCenterCircle.radius + 2))) {
            upperCanvas.style.cursor = parent.cursor = 'se-resize';
        }
        else if (actObj.rotationCirclePointColl &&
            x >= (actObj.rotationCirclePointColl.x - (actObj.bottomCenterCircle.radius + 2)) &&
            x <= actObj.rotationCirclePointColl.x + (actObj.bottomCenterCircle.radius + 2) &&
            y >= actObj.rotationCirclePointColl.y - (actObj.bottomCenterCircle.radius + 2) &&
            y <= actObj.rotationCirclePointColl.y + (actObj.bottomCenterCircle.radius + 2)) {
            upperCanvas.style.cursor = parent.cursor = 'grabbing';
        }
        else {
            upperCanvas.style.cursor = parent.cursor = 'default';
            const isPointsInsideRectangle = this.getRectanglePoints(actObj.activePoint.startX, actObj.activePoint.startY, actObj.activePoint.width, actObj.activePoint.height, actObj.rotatedAngle * (180 / Math.PI), x, y);
            if (isPointsInsideRectangle) {
                upperCanvas.style.cursor = parent.cursor = 'move';
            }
        }
        if (parent.cursor === 'default') {
            for (let i = 0, len = actObj.horTopLinePointColl.length; i < len; i++) {
                if (x >= (actObj.horTopLinePointColl[i].x - 5) &&
                    x <= (actObj.horTopLinePointColl[i].x + 5) &&
                    y >= (actObj.horTopLinePointColl[i].y - 5) &&
                    y <= (actObj.horTopLinePointColl[i].y + 5)) {
                    upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'n-resize';
                    break;
                }
            }
        }
        if (parent.cursor === 'default') {
            for (let i = 0, len = actObj.horBottomLinePointColl.length; i < len; i++) {
                if (x >= (actObj.horBottomLinePointColl[i].x - 5) &&
                    x <= (actObj.horBottomLinePointColl[i].x + 5) &&
                    y >= (actObj.horBottomLinePointColl[i].y - 5) &&
                    y <= (actObj.horBottomLinePointColl[i].y + 5)) {
                    upperCanvas.style.cursor = parent.cursor = this.resizedElement = 's-resize';
                    break;
                }
            }
        }
        if (parent.cursor === 'default') {
            for (let i = 0, len = actObj.verLeftLinePointColl.length; i < len; i++) {
                if (x >= (actObj.verLeftLinePointColl[i].x - 5) &&
                    x <= (actObj.verLeftLinePointColl[i].x + 5) &&
                    y >= (actObj.verLeftLinePointColl[i].y - 5) &&
                    y <= (actObj.verLeftLinePointColl[i].y + 5)) {
                    upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'w-resize';
                    break;
                }
            }
        }
        if (parent.cursor === 'default') {
            for (let i = 0, len = actObj.verRightLinePointColl.length; i < len; i++) {
                if (x >= (actObj.verRightLinePointColl[i].x - 5) &&
                    x <= (actObj.verRightLinePointColl[i].x + 5) &&
                    y >= (actObj.verRightLinePointColl[i].y - 5) &&
                    y <= (actObj.verRightLinePointColl[i].y + 5)) {
                    upperCanvas.style.cursor = parent.cursor = this.resizedElement = 'e-resize';
                    break;
                }
            }
        }
        this.adjustCursorStylesForRotatedState(actObj);
        return parent.cursor;
    }
    adjustCursorStylesForRotatedState(actObj) {
        const parent = this.parent;
        let length = actObj.rotatedAngle * (180 / Math.PI);
        length = length > 0 ? Math.floor(length) : Math.ceil(length);
        if ((length >= 92 && length <= 182) || (length >= -178 && length <= -88)) {
            const cursorMap = { 'nw-resize': 'ne-resize', 'n-resize': 's-resize',
                'ne-resize': 'nw-resize', 'w-resize': 'e-resize', 'e-resize': 'w-resize',
                'sw-resize': 'se-resize', 's-resize': 'n-resize', 'se-resize': 'sw-resize'
            };
            if (parent.cursor in cursorMap) {
                parent.cursor = cursorMap[parent.cursor];
            }
        }
        parent.upperCanvas.style.cursor = this.getResizeElement((actObj.rotatedAngle * (180 / Math.PI)), parent.cursor);
        return parent.cursor;
    }
    getResizeElement(degree, element) {
        let resizeMappings = [];
        if (element === 'nw-resize') {
            resizeMappings = [
                [337.5, 22.5, 'nw-resize'], [22.5, 67.5, 'n-resize'], [67.5, 112.5, 'ne-resize'],
                [112.5, 157.5, 'e-resize'], [157.5, 202.5, 'se-resize'],
                [202.5, 247.5, 's-resize'], [247.5, 292.5, 'sw-resize'],
                [292.5, 337.5, 'w-resize']
            ];
        }
        else if (element === 'n-resize') {
            resizeMappings = [
                [337.5, 22.5, 'n-resize'], [22.5, 67.5, 'ne-resize'], [67.5, 112.5, 'e-resize'],
                [112.5, 157.5, 'se-resize'], [157.5, 202.5, 's-resize'], [202.5, 247.5, 'sw-resize'],
                [247.5, 292.5, 'w-resize'], [292.5, 337.5, 'nw-resize']
            ];
        }
        else if (element === 'ne-resize') {
            resizeMappings = [
                [337.5, 22.5, 'ne-resize'], [22.5, 67.5, 'e-resize'],
                [67.5, 112.5, 'se-resize'], [112.5, 157.5, 's-resize'], [157.5, 202.5, 'sw-resize'],
                [202.5, 247.5, 'w-resize'], [247.5, 292.5, 'nw-resize'], [292.5, 337.5, 'n-resize']
            ];
        }
        else if (element === 'e-resize') {
            resizeMappings = [
                [337.5, 22.5, 'e-resize'], [22.5, 67.5, 'se-resize'], [67.5, 112.5, 's-resize'],
                [112.5, 157.5, 'sw-resize'], [157.5, 202.5, 'w-resize'], [202.5, 247.5, 'nw-resize'],
                [247.5, 292.5, 'n-resize'], [292.5, 337.5, 'ne-resize']
            ];
        }
        else if (element === 'se-resize') {
            resizeMappings = [
                [337.5, 22.5, 'se-resize'], [22.5, 67.5, 's-resize'], [67.5, 112.5, 'sw-resize'],
                [112.5, 157.5, 'w-resize'], [157.5, 202.5, 'nw-resize'], [202.5, 247.5, 'n-resize'],
                [247.5, 292.5, 'ne-resize'], [292.5, 337.5, 'e-resize']
            ];
        }
        else if (element === 's-resize') {
            resizeMappings = [
                [337.5, 22.5, 's-resize'], [22.5, 67.5, 'sw-resize'], [67.5, 112.5, 'w-resize'],
                [112.5, 157.5, 'nw-resize'], [157.5, 202.5, 'n-resize'], [202.5, 247.5, 'ne-resize'],
                [247.5, 292.5, 'e-resize'], [292.5, 337.5, 'se-resize']
            ];
        }
        else if (element === 'sw-resize') {
            resizeMappings = [
                [337.5, 22.5, 'sw-resize'], [22.5, 67.5, 'w-resize'], [67.5, 112.5, 'nw-resize'],
                [112.5, 157.5, 'n-resize'], [157.5, 202.5, 'ne-resize'], [202.5, 247.5, 'e-resize'],
                [247.5, 292.5, 'se-resize'], [292.5, 337.5, 's-resize']
            ];
        }
        else if (element === 'w-resize') {
            resizeMappings = [
                [337.5, 22.5, 'w-resize'], [22.5, 67.5, 'nw-resize'], [67.5, 112.5, 'n-resize'],
                [112.5, 157.5, 'ne-resize'], [157.5, 202.5, 'e-resize'], [202.5, 247.5, 'se-resize'],
                [247.5, 292.5, 's-resize'], [292.5, 337.5, 'sw-resize']
            ];
        }
        const positiveDegree = degree < 0 ? 360 - Math.abs(degree) : degree;
        for (const [startDegree, endDegree, resizeElement] of resizeMappings) {
            if ((positiveDegree > startDegree && positiveDegree <= endDegree) ||
                (positiveDegree + 360 > startDegree && positiveDegree + 360 <= endDegree)) {
                return resizeElement;
            }
        }
        return element;
    }
    setCursorForFreehandDrawing(x, y, upperCanvas) {
        const upperContext = upperCanvas.getContext('2d');
        const parent = this.parent;
        const textArea = document.querySelector('#' + parent.element.id + '_textArea');
        let isEntered = false;
        parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false,
            value: { index: -1 } });
        let sPoints;
        for (let n = 0; n < parent.freehandCounter; n++) {
            const obj = { selPointColl: {} };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false, value: { obj: obj } });
            sPoints = extend([], obj['selPointColl'][n].points, []);
            parent.points = extend([], parent.pointColl[n].points, []);
            parent.notify('freehand-draw', { prop: 'setPointCounter', onPropertyChange: false, value: { value: 0 } });
            const len = sPoints.length;
            for (let l = 0; l < len; l++) {
                if (l !== 0) {
                    let isInside = false;
                    if (sPoints[l - 1] && sPoints[l]) {
                        isInside = this.isInside(x, y, sPoints[l - 1].x, sPoints[l - 1].y, sPoints[l].x, sPoints[l].y);
                    }
                    if (isInside) {
                        this.isFhdPoint = true;
                        parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false,
                            value: { index: n } });
                        parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                            value: { strokeColor: null, strokeWidth: null } });
                        upperCanvas.style.cursor = parent.cursor = 'pointer';
                        isEntered = true;
                        break;
                    }
                    else if (!this.isFhdEditing || parent.pointColl[n].isSelected) {
                        if (this.isFhdPoint || this.isFhdEditing) {
                            upperContext.clearRect(0, 0, upperCanvas.width, upperCanvas.height);
                            if (parent.activeObj.shape && textArea.style.display === 'none') {
                                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
                            }
                        }
                        if (this.isFhdEditing) {
                            const strokeColor = parent.pointColl[n].strokeColor;
                            parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                                value: { strokeColor: strokeColor, strokeWidth: parent.pointColl[n].strokeWidth } });
                        }
                        else {
                            parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false,
                                value: { index: null } });
                        }
                        this.isFhdPoint = false;
                    }
                }
                else {
                    if (x > parent.points[l].x - parent.pointColl[n].strokeWidth &&
                        x < parent.points[l].x + parent.pointColl[n].strokeWidth &&
                        y > parent.points[l].y - parent.pointColl[n].strokeWidth &&
                        y < parent.points[l].y + parent.pointColl[n].strokeWidth) {
                        this.isFhdPoint = true;
                        parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false,
                            value: { index: n } });
                        parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                            value: { strokeColor: null, strokeWidth: null } });
                        upperCanvas.style.cursor = parent.cursor = 'pointer';
                        isEntered = true;
                        break;
                    }
                    else if (!this.isFhdEditing || parent.pointColl[n].isSelected) {
                        if (this.isFhdPoint || this.isFhdEditing) {
                            upperContext.clearRect(0, 0, upperCanvas.width, upperCanvas.height);
                            if (parent.activeObj.shape && textArea.style.display === 'none') {
                                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
                            }
                        }
                        if (this.isFhdEditing) {
                            const strokeColor = parent.pointColl[n].strokeColor;
                            parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                                value: { strokeColor: strokeColor, strokeWidth: parent.pointColl[n].strokeWidth } });
                        }
                        this.isFhdPoint = false;
                    }
                }
            }
            if (isEntered) {
                break;
            }
        }
    }
    setCursorFromObj(x, y, obj, upperCanvas, isCropSelection) {
        const parent = this.parent;
        for (let i = 0, len = obj.length; i < len; i++) {
            if (parent.cursor === 'move') {
                return;
            }
            const actObj = extend({}, obj[i], {}, true);
            this.cursorTargetId = actObj.currIndex;
            if (actObj.shape === 'line' || actObj.shape === 'arrow') {
                this.setCursorForLineArrow(actObj, x, y, upperCanvas);
            }
            else if (actObj.shape === 'path') {
                this.setCursorForPath(actObj, x, y, upperCanvas);
            }
            else if (!isNullOrUndefined(actObj.rotatedAngle) && actObj.rotatedAngle !== 0) {
                this.setCursorForRotatedObject(actObj, x, y, upperCanvas);
            }
            else {
                upperCanvas.style.cursor = parent.cursor = this.getMouseCursor(actObj, x, y, isCropSelection, true);
            }
        }
    }
    isInside(x, y, z1, z2, z3, z4) {
        const x1 = Math.min(z1, z3);
        const x2 = Math.max(z1, z3);
        const y1 = Math.min(z2, z4);
        const y2 = Math.max(z2, z4);
        if ((x1 <= x && x <= x2) && (y1 <= y && y <= y2)) {
            return true;
        }
        else {
            return false;
        }
    }
    updateActivePoint(x, y, isCropSelection) {
        const parent = this.parent;
        const obj = { width: 0, height: 0 };
        parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
            value: { width: parent.activeObj.activePoint.width, height: parent.activeObj.activePoint.height, obj: obj } });
        const maxDimension = obj;
        const previousShapeSettings = this.updatePrevShapeSettings();
        const shapeResizingArgs = { action: 'resize', previousShapeSettings: previousShapeSettings };
        const shapeMovingArgs = { action: 'move', previousShapeSettings: previousShapeSettings };
        this.shapeResizingArgs = shapeResizingArgs;
        this.shapeMovingArgs = shapeMovingArgs;
        if (parent.activeObj.shape === 'text' && this.dragElement !== '') {
            parent.notify('shape', { prop: 'updateFontRatio', onPropertyChange: false,
                value: { obj: parent.activeObj, isTextArea: null } });
        }
        if (this.currentDrawingShape !== '' && (this.dragElement === '' || this.dragElement === 'move')) {
            if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' ||
                parent.activeObj.shape === 'path') {
                this.dragElement = 'e-resize';
            }
            else {
                if (x > parent.activeObj.activePoint.startX && y > parent.activeObj.activePoint.startY) {
                    this.dragElement = 'se-resize';
                }
                else if (x < parent.activeObj.activePoint.startX && y > parent.activeObj.activePoint.startY) {
                    this.dragElement = 'sw-resize';
                }
                else if (x > parent.activeObj.activePoint.startX && y < parent.activeObj.activePoint.startY) {
                    this.dragElement = 'ne-resize';
                }
                else if (x < parent.activeObj.activePoint.startX && y < parent.activeObj.activePoint.startY) {
                    this.dragElement = 'nw-resize';
                }
            }
        }
        if (parent.activeObj.shape === 'arrow') {
            if (Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2) > 0) {
                parent.activeObj.rotatedAngle = -Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2);
            }
            else {
                parent.activeObj.rotatedAngle = Math.abs(Math.atan2(x - parent.lowerCanvas.width / 2, y - parent.lowerCanvas.height / 2));
            }
        }
        let degree;
        let isHorizontalflip = false;
        let isVerticalflip = false;
        switch (this.dragElement.toLowerCase()) {
            case 'nw-resize':
                this.updateNWPoints(x, y, maxDimension);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'n-resize':
                this.updateNPoints(x, y);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'ne-resize':
                this.updateNEPoints(x, y, maxDimension);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'w-resize':
                this.updateWPoints(x, y);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'e-resize':
                this.updateEPoints(x, y);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'sw-resize':
                this.updateSWPoints(x, y, maxDimension);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 's-resize':
                this.updateSPoints(x, y);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'se-resize':
                this.updateSEPoints(x, y, maxDimension);
                parent.notify('shape', { prop: 'updateArrowDirection', onPropertyChange: false,
                    value: { obj: parent.activeObj, flip: null, rotatedDegree: null } });
                this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'resize');
                break;
            case 'grabbing':
                if (Math.atan2(x - (parent.activeObj.activePoint.startX + (parent.activeObj.activePoint.width / 2)), y - (parent.activeObj.activePoint.startY + (parent.activeObj.activePoint.height / 2))) > 0) {
                    parent.activeObj.rotatedAngle = -Math.atan2(x - (parent.activeObj.activePoint.startX + (parent.activeObj.activePoint.width
                        / 2)), y - (parent.activeObj.activePoint.startY + (parent.activeObj.activePoint.height / 2)));
                }
                else {
                    parent.activeObj.rotatedAngle = Math.abs(Math.atan2(x - (parent.activeObj.activePoint.startX +
                        (parent.activeObj.activePoint.width / 2)), y - (parent.activeObj.activePoint.startY +
                        (parent.activeObj.activePoint.height / 2))));
                }
                if (parent.activeObj.shapeDegree === 0) {
                    degree = parent.transform.degree;
                }
                else {
                    degree = parent.transform.degree - parent.activeObj.shapeDegree;
                }
                if (degree < 0) {
                    degree = 360 + degree;
                }
                for (let i = 0, len = parent.activeObj.flipObjColl.length; i < len; i++) {
                    if (parent.activeObj.flipObjColl[i].toLowerCase() === 'horizontal') {
                        isHorizontalflip = true;
                    }
                    else if (parent.activeObj.flipObjColl[i].toLowerCase() === 'vertical') {
                        isVerticalflip = true;
                    }
                }
                parent.activeObj.rotatedAngle -= (degree * (Math.PI / 180));
                if (degree === 0 || degree === 360) {
                    if (isVerticalflip) {
                        parent.activeObj.rotatedAngle -= (180 * (Math.PI / 180));
                    }
                }
                else if (degree === 90 || degree === -270) {
                    if (isHorizontalflip) {
                        parent.activeObj.rotatedAngle -= (180 * (Math.PI / 180));
                    }
                }
                else if (degree === 180 || degree === -180) {
                    if (isVerticalflip) {
                        parent.activeObj.rotatedAngle -= (180 * (Math.PI / 180));
                    }
                }
                else if (degree === 270 || degree === -90) {
                    if (isHorizontalflip) {
                        parent.activeObj.rotatedAngle -= (180 * (Math.PI / 180));
                    }
                }
                break;
            case 'pathdrag':
                if (!isNullOrUndefined(this.pathAdjustedIndex)) {
                    parent.activeObj.pointColl[this.pathAdjustedIndex].x = x;
                    parent.activeObj.pointColl[this.pathAdjustedIndex].y = y;
                }
                break;
            default:
                if (!isCropSelection && !parent.currObjType.isCustomCrop) {
                    if (this.dragPoint.startX) {
                        const width = (this.dragPoint.endX - this.previousPoint.x);
                        const height = (this.dragPoint.endY - this.previousPoint.y);
                        parent.activeObj.activePoint.startX += width;
                        parent.activeObj.activePoint.endX += width;
                        parent.activeObj.activePoint.startY += height;
                        parent.activeObj.activePoint.endY += height;
                        if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' &&
                            parent.activeObj.rotationCirclePointColl) {
                            parent.activeObj.rotationCirclePointColl.x += width;
                            parent.activeObj.rotationCirclePointColl.y += height;
                            parent.activeObj.rotationCirclePoint.x += width;
                            parent.activeObj.rotationCirclePoint.y += height;
                        }
                        if (parent.activeObj.shape === 'path') {
                            for (let i = 0, len = parent.activeObj.pointColl.length; i < len; i++) {
                                parent.activeObj.pointColl[i].x += width;
                                parent.activeObj.pointColl[i].y += height;
                            }
                        }
                        if (!this.isPreventDragging && (parent.activeObj.activePoint.startX < parent.img.destLeft ||
                            parent.activeObj.activePoint.startY < parent.img.destTop || parent.activeObj.activePoint.endX >
                            parent.img.destLeft + parent.img.destWidth || parent.activeObj.activePoint.endY > parent.img.destTop
                            + parent.img.destHeight)) {
                            parent.activeObj.activePoint.startX -= width;
                            parent.activeObj.activePoint.endX -= width;
                            parent.activeObj.activePoint.startY -= height;
                            parent.activeObj.activePoint.endY -= height;
                            if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' &&
                                parent.activeObj.rotationCirclePointColl) {
                                parent.activeObj.rotationCirclePointColl.x -= width;
                                parent.activeObj.rotationCirclePointColl.y -= height;
                                parent.activeObj.rotationCirclePoint.x -= width;
                                parent.activeObj.rotationCirclePoint.y -= height;
                            }
                            this.setDragWidth(width);
                            this.setDragHeight(height);
                        }
                    }
                    else {
                        parent.activeObj.activePoint.startX = x < this.mouseDownPoint.x ? x : this.mouseDownPoint.x;
                        parent.activeObj.activePoint.startY = y < this.mouseDownPoint.y ? y : this.mouseDownPoint.y;
                        x = x < this.mouseDownPoint.x ? this.mouseDownPoint.x : x;
                        y = y < this.mouseDownPoint.y ? this.mouseDownPoint.y : y;
                        parent.activeObj.activePoint.endX = x;
                        parent.activeObj.activePoint.endY = y;
                    }
                    this.triggerShapeChange(shapeResizingArgs, shapeMovingArgs, 'move');
                }
                break;
        }
    }
    triggerShapeChange(shapeResizingArgs, shapeMovingArgs, type) {
        const parent = this.parent;
        parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
        parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
        const currentShapeSettings = this.updatePrevShapeSettings();
        shapeResizingArgs.currentShapeSettings = this.shapeResizingArgs.currentShapeSettings = currentShapeSettings;
        shapeMovingArgs.currentShapeSettings = this.shapeMovingArgs.currentShapeSettings = currentShapeSettings;
        if (type === 'resize') {
            this.isCropSelection = false;
            let splitWords;
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (splitWords !== undefined && splitWords[0] === 'crop') {
                this.isCropSelection = true;
            }
            if (!this.isCropSelection && this.parent.eventType !== 'resize' && isBlazor() && parent.events && this.parent.events.onShapeResizeStart.hasDelegate === true) {
                shapeResizingArgs.action = this.currentDrawingShape !== '' ? 'drawing' : 'resize-start';
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                parent.dotNetRef.invokeMethodAsync('ShapeEventAsync', 'OnShapeResizeStart', shapeResizingArgs).then((shapeResizingArgs) => {
                    parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,
                        value: { shapeSettings: shapeResizingArgs.currentShapeSettings } });
                });
            }
            else if (!this.isCropSelection) {
                if (this.currentDrawingShape !== '') {
                    shapeResizingArgs.action = 'drawing';
                }
                parent.trigger('shapeChanging', shapeResizingArgs);
                parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,
                    value: { shapeSettings: shapeResizingArgs.currentShapeSettings } });
            }
            else {
                const selectionResizingArgs = { action: shapeResizingArgs.action,
                    previousSelectionSettings: { type: parent.getSelectionType(parent.activeObj.shape),
                        startX: shapeResizingArgs.previousShapeSettings.startX,
                        startY: shapeResizingArgs.previousShapeSettings.startY,
                        width: shapeResizingArgs.previousShapeSettings.width,
                        height: shapeResizingArgs.previousShapeSettings.height },
                    currentSelectionSettings: { type: parent.getSelectionType(parent.activeObj.shape),
                        startX: shapeResizingArgs.currentShapeSettings.startX,
                        startY: shapeResizingArgs.currentShapeSettings.startY,
                        width: shapeResizingArgs.currentShapeSettings.width,
                        height: shapeResizingArgs.currentShapeSettings.height } };
                this.selectionResizingArgs = selectionResizingArgs;
                if (isBlazor() && isNullOrUndefined(this.parent.eventType) && parent.events &&
                    parent.events.onSelectionResizeStart.hasDelegate === true) {
                    selectionResizingArgs.action = 'resize-start';
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    parent.dotNetRef.invokeMethodAsync('SelectionEventAsync', 'OnSelectionResizeStart', selectionResizingArgs).then((selectionResizingArgs) => {
                        parent.notify('shape', { prop: 'updSelChangeEventArgs', onPropertyChange: false,
                            value: { selectionSettings: selectionResizingArgs.currentSelectionSettings } });
                    });
                }
                else {
                    parent.trigger('selectionChanging', selectionResizingArgs);
                    parent.notify('shape', { prop: 'updSelChangeEventArgs', onPropertyChange: false,
                        value: { selectionSettings: selectionResizingArgs.currentSelectionSettings } });
                }
            }
        }
        else {
            if (isBlazor() && isNullOrUndefined(this.parent.eventType) && parent.events &&
                parent.events.onShapeDragStart.hasDelegate === true) {
                shapeMovingArgs.action = 'drag-start';
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                parent.dotNetRef.invokeMethodAsync('ShapeEventAsync', 'OnShapeDragStart', shapeMovingArgs).then((shapeMovingArgs) => {
                    parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,
                        value: { shapeSettings: shapeMovingArgs.currentShapeSettings } });
                });
            }
            else {
                parent.trigger('shapeChanging', shapeMovingArgs);
                parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,
                    value: { shapeSettings: shapeMovingArgs.currentShapeSettings } });
            }
        }
        this.parent.eventType = type;
    }
    setDragWidth(width) {
        const parent = this.parent;
        const tempWidth = width;
        if (tempWidth >= 0) {
            for (let i = 0; i < tempWidth; i++) {
                width = tempWidth - i;
                parent.activeObj.activePoint.startX += width;
                parent.activeObj.activePoint.endX += width;
                if (parent.activeObj.activePoint.startX >= parent.img.destLeft &&
                    parent.activeObj.activePoint.endX <= parent.img.destLeft + parent.img.destWidth) {
                    break;
                }
                else {
                    parent.activeObj.activePoint.startX -= width;
                    parent.activeObj.activePoint.endX -= width;
                }
            }
        }
        else {
            for (let i = 1; i < Math.abs(tempWidth); i++) {
                width = tempWidth + i;
                parent.activeObj.activePoint.startX += width;
                parent.activeObj.activePoint.endX += width;
                if (parent.activeObj.activePoint.startX >= parent.img.destLeft &&
                    parent.activeObj.activePoint.endX <= parent.img.destLeft + parent.img.destWidth) {
                    break;
                }
                else {
                    parent.activeObj.activePoint.startX -= width;
                    parent.activeObj.activePoint.endX -= width;
                }
            }
        }
    }
    setDragHeight(height) {
        const parent = this.parent;
        const tempHeight = height;
        if (tempHeight >= 0) {
            for (let i = 1; i < tempHeight; i++) {
                height = tempHeight - i;
                parent.activeObj.activePoint.startY += height;
                parent.activeObj.activePoint.endY += height;
                if (parent.activeObj.activePoint.startY >= parent.img.destTop &&
                    parent.activeObj.activePoint.endY <= parent.img.destTop + parent.img.destHeight) {
                    break;
                }
                else {
                    parent.activeObj.activePoint.startY -= height;
                    parent.activeObj.activePoint.endY -= height;
                }
            }
        }
        else {
            for (let i = 0; i < Math.abs(tempHeight); i++) {
                height = tempHeight + i;
                parent.activeObj.activePoint.startY += height;
                parent.activeObj.activePoint.endY += height;
                if (parent.activeObj.activePoint.startY >= parent.img.destTop &&
                    parent.activeObj.activePoint.endY <= parent.img.destTop + parent.img.destHeight) {
                    break;
                }
                else {
                    parent.activeObj.activePoint.startY -= height;
                    parent.activeObj.activePoint.endY -= height;
                }
            }
        }
    }
    limitDrag(isStart) {
        const parent = this.parent;
        let startX = isStart ? parent.activeObj.activePoint.startX : parent.activeObj.activePoint.endX;
        let startY = isStart ? parent.activeObj.activePoint.startY : parent.activeObj.activePoint.endY;
        let endX = isStart ? parent.activeObj.activePoint.endX : parent.activeObj.activePoint.startX;
        let endY = isStart ? parent.activeObj.activePoint.endY : parent.activeObj.activePoint.startY;
        if (startX < parent.img.destLeft) {
            startX = parent.img.destLeft;
        }
        if (startY < parent.img.destTop) {
            startY = parent.img.destTop;
        }
        if (endX > parent.img.destLeft + parent.img.destWidth) {
            endX = parent.img.destLeft + parent.img.destWidth;
        }
        if (endY > parent.img.destTop + parent.img.destHeight) {
            endY = parent.img.destTop + parent.img.destHeight;
        }
        if (isStart) {
            parent.activeObj.activePoint.startX = startX;
            parent.activeObj.activePoint.startY = startY;
            parent.activeObj.activePoint.endX = endX;
            parent.activeObj.activePoint.endY = endY;
        }
        else {
            parent.activeObj.activePoint.startX = endX;
            parent.activeObj.activePoint.startY = endY;
            parent.activeObj.activePoint.endX = startX;
            parent.activeObj.activePoint.endY = startY;
        }
    }
    preventDraggingInvertly() {
        const parent = this.parent;
        if (!this.isPreventDragging && parent.activeObj.rotatedAngle === 0) {
            this.limitDrag(true);
            if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' ||
                parent.activeObj.shape === 'path') {
                this.limitDrag(false);
            }
        }
    }
    preventTextDraggingInvertly() {
        const parent = this.parent;
        let isLimiting = false;
        if (!this.isPreventDragging) {
            if (parent.activeObj.activePoint.startX < parent.img.destLeft ||
                parent.activeObj.activePoint.startY < parent.img.destTop ||
                parent.activeObj.activePoint.endX > parent.img.destLeft + parent.img.destWidth ||
                parent.activeObj.activePoint.endY > parent.img.destTop + parent.img.destHeight) {
                isLimiting = true;
            }
        }
        return isLimiting;
    }
    preventInverseResize(tempActiveObj) {
        const parent = this.parent;
        if (parent.activeObj.activePoint.width < 0) {
            parent.activeObj.activePoint.width = 0;
            parent.activeObj.activePoint.startX = tempActiveObj.activePoint.startX;
            parent.activeObj.activePoint.endX = tempActiveObj.activePoint.endX;
        }
        if (parent.activeObj.activePoint.height < 0) {
            parent.activeObj.activePoint.height = 0;
            parent.activeObj.activePoint.startY = tempActiveObj.activePoint.startY;
            parent.activeObj.activePoint.endY = tempActiveObj.activePoint.endY;
        }
    }
    getScaleRatio(scale) {
        const parent = this.parent;
        const point = { x: scale, y: scale };
        if (parent.activeObj.shape && parent.activeObj.shape !== 'crop-custom' &&
            parent.activeObj.shape !== 'crop-circle' && parent.activeObj.shape !== 'crop-square') {
            let ratio = parent.activeObj.shape.split('-');
            if (ratio.length > 1) {
                ratio = ratio[1].split(':');
                const newScale = scale / (parseInt(ratio[1], 10));
                point.x = newScale * (parseInt(ratio[0], 10));
                point.y = newScale * (parseInt(ratio[1], 10));
            }
        }
        return point;
    }
    updateNWPoints(x, y, maxDimension) {
        const parent = this.parent;
        let diff;
        let width;
        let height;
        let scale;
        let percentage;
        const prevDiffX = this.diffPoint.x;
        const prevDiffY = this.diffPoint.y;
        const tempActiveObj = extend({}, parent.activeObj, null, true);
        if (parent.activeObj.shape === 'text') {
            if (this.oldPoint.x === undefined && this.oldPoint.y === undefined) {
                this.diffPoint.x = parent.activeObj.activePoint.startX - x;
                this.diffPoint.y = parent.activeObj.activePoint.startY - y;
            }
            else {
                this.diffPoint.x = this.oldPoint.x - x;
                this.diffPoint.y = this.oldPoint.y - y;
            }
            this.oldPoint.x = x;
            this.oldPoint.y = y;
            if (this.diffPoint.x <= prevDiffX && this.diffPoint.y >= prevDiffY) {
                diff = Math.min(this.diffPoint.x, this.diffPoint.y);
            }
            else {
                diff = Math.max(this.diffPoint.x, this.diffPoint.y);
            }
            percentage = (diff / 10);
            parent.activeObj.activePoint.startX -= (maxDimension.width / 100) * percentage;
            parent.activeObj.activePoint.startY -= (maxDimension.height / 100) * percentage;
            if (this.preventTextDraggingInvertly()) {
                parent.activeObj.activePoint.startX += (maxDimension.width / 100) * percentage;
                parent.activeObj.activePoint.startY += (maxDimension.height / 100) * percentage;
            }
            parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
            parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,
                value: { obj: parent.activeObj } });
        }
        else {
            let splitWords;
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape !== undefined && splitWords[0] !== 'crop')) {
                this.adjustNWPoints(parent.activeObj.activePoint, x, y, parent.activeObj.rotatedAngle);
                if (parent.activeObj.activePoint.startX > parent.activeObj.activePoint.endX) {
                    const temp = parent.activeObj.activePoint.startX;
                    parent.activeObj.activePoint.startX = parent.activeObj.activePoint.endX;
                    parent.activeObj.activePoint.endX = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'ne-resize';
                }
                if (parent.activeObj.activePoint.startY > parent.activeObj.activePoint.endY) {
                    const temp = parent.activeObj.activePoint.startY;
                    parent.activeObj.activePoint.startY = parent.activeObj.activePoint.endY;
                    parent.activeObj.activePoint.endY = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'sw-resize';
                }
                this.preventDraggingInvertly();
            }
            else {
                if (parent.activeObj.activePoint.startX < x && parent.activeObj.activePoint.startY < y) {
                    width = x - parent.activeObj.activePoint.startX;
                    height = y - parent.activeObj.activePoint.startY;
                    scale = Math.min(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.startX += newScale.x;
                    parent.activeObj.activePoint.startY += newScale.y;
                    const left = parent.img.destLeft > 0 ? parent.img.destLeft : 0;
                    const top = parent.img.destTop > 0 ? parent.img.destTop : 0;
                    if (parent.activeObj.activePoint.startX < left || parent.activeObj.activePoint.startY < top) {
                        parent.activeObj.activePoint.startX -= newScale.x;
                        parent.activeObj.activePoint.startY -= newScale.y;
                    }
                }
                else {
                    width = parent.activeObj.activePoint.startX - x;
                    height = y - parent.activeObj.activePoint.endY;
                    scale = Math.max(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.startX -= newScale.x;
                    parent.activeObj.activePoint.startY -= newScale.y;
                    const left = parent.img.destLeft > 0 ? parent.img.destLeft : 0;
                    const top = parent.img.destTop > 0 ? parent.img.destTop : 0;
                    if (parent.activeObj.activePoint.startX < left || parent.activeObj.activePoint.startY < top) {
                        parent.activeObj.activePoint.startX += newScale.x;
                        parent.activeObj.activePoint.startY += newScale.y;
                    }
                }
            }
            parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
            parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
            this.preventInverseResize(tempActiveObj);
        }
    }
    updateNPoints(x, y) {
        const parent = this.parent;
        let width;
        let height;
        let scale;
        if (parent.activeObj.shape !== 'text') {
            let splitWords;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape && splitWords[0] !== 'crop')) {
                if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' && parent.activeObj.shape !== 'path' &&
                    parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
                    if (this.dragPoint.startX && this.dragPoint.startY) {
                        this.previousPoint.x = this.dragPoint.endX;
                        this.previousPoint.y = this.dragPoint.endY;
                        this.dragPoint.endX = x;
                        this.dragPoint.endY = y;
                    }
                    width = (this.dragPoint.endX - this.previousPoint.x);
                    height = (this.dragPoint.endY - this.previousPoint.y);
                    this.adjustRotationPoints(parent.activeObj.activePoint, width, height, parent.activeObj.rotatedAngle);
                }
                else {
                    parent.activeObj.activePoint.startY = y;
                    parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
                }
                if (parent.activeObj.activePoint.startY > parent.activeObj.activePoint.endY) {
                    const temp = parent.activeObj.activePoint.startY;
                    parent.activeObj.activePoint.startY = parent.activeObj.activePoint.endY;
                    parent.activeObj.activePoint.endY = temp;
                    this.dragElement = this.resizedElement = 's-resize';
                }
                this.preventDraggingInvertly();
            }
            else {
                if (parent.activeObj.activePoint.endX > x && parent.activeObj.activePoint.startY < y) {
                    width = parent.activeObj.activePoint.endX - x;
                    height = y - parent.activeObj.activePoint.startY;
                    scale = Math.min(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.endX -= newScale.x;
                    parent.activeObj.activePoint.startY += newScale.y;
                    if (parent.activeObj.activePoint.endX > (parent.img.destLeft + parent.img.destWidth) ||
                        parent.activeObj.activePoint.startY < parent.img.destTop) {
                        parent.activeObj.activePoint.endX += newScale.x;
                        parent.activeObj.activePoint.startY -= newScale.y;
                    }
                }
                else {
                    width = x - parent.activeObj.activePoint.endX;
                    height = parent.activeObj.activePoint.startY - y;
                    scale = Math.max(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.endX += newScale.x;
                    parent.activeObj.activePoint.startY -= newScale.y;
                    if (parent.activeObj.activePoint.endX > (parent.img.destLeft + parent.img.destWidth) ||
                        parent.activeObj.activePoint.startY < parent.img.destTop) {
                        parent.activeObj.activePoint.endX -= newScale.x;
                        parent.activeObj.activePoint.startY += newScale.y;
                    }
                }
                parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
                parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
            }
        }
    }
    updateNEPoints(x, y, maxDimension) {
        const parent = this.parent;
        let diff;
        let width;
        let height;
        let scale;
        let percentage;
        const prevDiffX = this.diffPoint.x;
        const prevDiffY = this.diffPoint.y;
        const tempActiveObj = extend({}, parent.activeObj, null, true);
        if (parent.activeObj.shape === 'text') {
            if (this.oldPoint.x === undefined && this.oldPoint.y === undefined) {
                this.diffPoint.x = x - parent.activeObj.activePoint.endX;
                this.diffPoint.y = parent.activeObj.activePoint.startY - y;
            }
            else {
                this.diffPoint.x = x - this.oldPoint.x;
                this.diffPoint.y = this.oldPoint.y - y;
            }
            this.oldPoint.x = x;
            this.oldPoint.y = y;
            if (this.diffPoint.x <= prevDiffX && this.diffPoint.y >= prevDiffY) {
                diff = Math.min(this.diffPoint.x, this.diffPoint.y);
            }
            else {
                diff = Math.max(this.diffPoint.x, this.diffPoint.y);
            }
            percentage = (diff / 10);
            parent.activeObj.activePoint.endX += (maxDimension.width / 100) * percentage;
            parent.activeObj.activePoint.startY -= (maxDimension.height / 100) * percentage;
            if (this.preventTextDraggingInvertly()) {
                parent.activeObj.activePoint.endX -= (maxDimension.width / 100) * percentage;
                parent.activeObj.activePoint.startY += (maxDimension.height / 100) * percentage;
            }
            parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
            parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,
                value: { obj: parent.activeObj } });
        }
        else {
            let splitWords;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape !== undefined && splitWords[0] !== 'crop')) {
                this.adjustNEPoints(parent.activeObj.activePoint, x, y, parent.activeObj.rotatedAngle);
                if (parent.activeObj.activePoint.endX < parent.activeObj.activePoint.startX) {
                    const temp = parent.activeObj.activePoint.endX;
                    parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX;
                    parent.activeObj.activePoint.startX = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'nw-resize';
                }
                if (parent.activeObj.activePoint.startY > parent.activeObj.activePoint.endY) {
                    const temp = parent.activeObj.activePoint.startY;
                    parent.activeObj.activePoint.startY = parent.activeObj.activePoint.endY;
                    parent.activeObj.activePoint.endY = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'se-resize';
                }
                this.preventDraggingInvertly();
            }
            else {
                if (parent.activeObj.activePoint.endX > x && parent.activeObj.activePoint.startY < y) {
                    width = parent.activeObj.activePoint.endX - x;
                    height = y - parent.activeObj.activePoint.startY;
                    scale = Math.min(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.endX -= newScale.x;
                    parent.activeObj.activePoint.startY += newScale.y;
                    const endX = parent.img.destLeft + parent.img.destWidth < parent.lowerCanvas.width ?
                        parent.img.destLeft + parent.img.destWidth : parent.lowerCanvas.width;
                    const endY = parent.img.destTop > 0 ? parent.img.destTop : 0;
                    if (parent.activeObj.activePoint.endX > endX || parent.activeObj.activePoint.startY < endY) {
                        parent.activeObj.activePoint.endX += newScale.x;
                        parent.activeObj.activePoint.startY -= newScale.y;
                    }
                }
                else {
                    width = x - parent.activeObj.activePoint.endX;
                    height = parent.activeObj.activePoint.startY - y;
                    scale = Math.max(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.endX += newScale.x;
                    parent.activeObj.activePoint.startY -= newScale.y;
                    const endX = parent.img.destLeft + parent.img.destWidth < parent.lowerCanvas.width ?
                        parent.img.destLeft + parent.img.destWidth : parent.lowerCanvas.width;
                    const endY = parent.img.destTop > 0 ? parent.img.destTop : 0;
                    if (parent.activeObj.activePoint.endX > endX || parent.activeObj.activePoint.startY < endY) {
                        parent.activeObj.activePoint.endX -= newScale.x;
                        parent.activeObj.activePoint.startY += newScale.y;
                    }
                }
            }
            parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
            parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
            this.preventInverseResize(tempActiveObj);
        }
    }
    updateWPoints(x, y) {
        const parent = this.parent;
        let width;
        let height;
        let scale;
        if (parent.activeObj.shape !== 'text') {
            let splitWords;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape && splitWords[0] !== 'crop')) {
                if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' && parent.activeObj.shape !== 'path' &&
                    parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
                    if (this.dragPoint.startX && this.dragPoint.startY) {
                        this.previousPoint.x = this.dragPoint.endX;
                        this.previousPoint.y = this.dragPoint.endY;
                        this.dragPoint.endX = x;
                        this.dragPoint.endY = y;
                    }
                    width = (this.dragPoint.endX - this.previousPoint.x);
                    height = (this.dragPoint.endY - this.previousPoint.y);
                    this.adjustRotationPoints(parent.activeObj.activePoint, width, height, parent.activeObj.rotatedAngle);
                }
                else {
                    parent.activeObj.activePoint.startX = x;
                    parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
                }
                if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'path') {
                    parent.activeObj.activePoint.startY = y;
                    parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
                    if (this.adjustActObjForLineArrow()) {
                        this.dragElement = 'e-resize';
                        if (parent.activeObj.triangleDirection === 'right') {
                            parent.activeObj.triangleDirection = 'left';
                        }
                        else if (parent.activeObj.triangleDirection === 'left') {
                            parent.activeObj.triangleDirection = 'right';
                        }
                    }
                }
                else if (parent.activeObj.activePoint.startX > parent.activeObj.activePoint.endX) {
                    const temp = parent.activeObj.activePoint.startX;
                    parent.activeObj.activePoint.startX = parent.activeObj.activePoint.endX;
                    parent.activeObj.activePoint.endX = temp;
                    this.dragElement = this.resizedElement = 'e-resize';
                }
                this.preventDraggingInvertly();
            }
            else {
                if (parent.activeObj.activePoint.startX < x && parent.activeObj.activePoint.endY > y) {
                    width = x - parent.activeObj.activePoint.startX;
                    height = parent.activeObj.activePoint.endY - y;
                    scale = Math.min(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.startX += newScale.x;
                    parent.activeObj.activePoint.endY -= newScale.y;
                    if (parent.activeObj.activePoint.startX < parent.img.destLeft || parent.activeObj.activePoint.endY >
                        (parent.img.destTop + parent.img.destHeight)) {
                        parent.activeObj.activePoint.startX -= newScale.x;
                        parent.activeObj.activePoint.endY += newScale.y;
                    }
                }
                else {
                    width = parent.activeObj.activePoint.startX - x;
                    height = y - parent.activeObj.activePoint.endY;
                    scale = Math.max(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.startX -= newScale.x;
                    parent.activeObj.activePoint.endY += newScale.y;
                    if (parent.activeObj.activePoint.startX < parent.img.destLeft || parent.activeObj.activePoint.endY >
                        (parent.img.destTop + parent.img.destHeight)) {
                        parent.activeObj.activePoint.startX += newScale.x;
                        parent.activeObj.activePoint.endY -= newScale.y;
                    }
                }
                parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
                parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
            }
        }
    }
    updateEPoints(x, y) {
        const parent = this.parent;
        let width;
        let height;
        let scale;
        if (parent.activeObj.shape !== 'text') {
            let splitWords;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape && splitWords[0] !== 'crop')) {
                if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' && parent.activeObj.shape !== 'path' &&
                    parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
                    if (this.dragPoint.startX && this.dragPoint.startY) {
                        this.previousPoint.x = this.dragPoint.endX;
                        this.previousPoint.y = this.dragPoint.endY;
                        this.dragPoint.endX = x;
                        this.dragPoint.endY = y;
                    }
                    width = (this.dragPoint.endX - this.previousPoint.x);
                    height = (this.dragPoint.endY - this.previousPoint.y);
                    this.adjustRotationPoints(parent.activeObj.activePoint, width, height, parent.activeObj.rotatedAngle);
                }
                else {
                    parent.activeObj.activePoint.endX = x;
                    parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
                }
                if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'path') {
                    parent.activeObj.activePoint.endY = y;
                    parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
                    if (this.adjustActObjForLineArrow()) {
                        this.dragElement = 'w-resize';
                        if (parent.activeObj.triangleDirection === 'right') {
                            parent.activeObj.triangleDirection = 'left';
                        }
                        else if (parent.activeObj.triangleDirection === 'left') {
                            parent.activeObj.triangleDirection = 'right';
                        }
                    }
                }
                else if (parent.activeObj.activePoint.endX < parent.activeObj.activePoint.startX) {
                    const temp = parent.activeObj.activePoint.endX;
                    parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX;
                    parent.activeObj.activePoint.startX = temp;
                    this.dragElement = this.resizedElement = 'w-resize';
                }
                this.preventDraggingInvertly();
            }
            else {
                if (parent.activeObj.activePoint.endX > x && parent.activeObj.activePoint.endY > y) {
                    width = parent.activeObj.activePoint.endX - x;
                    height = parent.activeObj.activePoint.endY - y;
                    scale = Math.min(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.endX -= newScale.x;
                    parent.activeObj.activePoint.endY -= newScale.y;
                    if (parent.activeObj.activePoint.endX > (parent.img.destLeft + parent.img.destWidth) ||
                        parent.activeObj.activePoint.endY > (parent.img.destTop + parent.img.destHeight)) {
                        parent.activeObj.activePoint.endX += newScale.x;
                        parent.activeObj.activePoint.endY += newScale.y;
                    }
                }
                else {
                    width = x - parent.activeObj.activePoint.endX;
                    height = y - parent.activeObj.activePoint.endY;
                    scale = Math.max(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.endX += newScale.x;
                    parent.activeObj.activePoint.endY += newScale.y;
                    if (parent.activeObj.activePoint.endX > (parent.img.destLeft + parent.img.destWidth) ||
                        parent.activeObj.activePoint.endY > (parent.img.destTop + parent.img.destHeight)) {
                        parent.activeObj.activePoint.endX -= newScale.x;
                        parent.activeObj.activePoint.endY -= newScale.y;
                    }
                }
                parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
                parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
            }
        }
    }
    updateSWPoints(x, y, maxDimension) {
        const parent = this.parent;
        let diff;
        let width;
        let height;
        let scale;
        let percentage;
        const prevDiffX = this.diffPoint.x;
        const prevDiffY = this.diffPoint.y;
        const tempActiveObj = extend({}, parent.activeObj, null, true);
        if (parent.activeObj.shape === 'text') {
            if (isNullOrUndefined(this.oldPoint.x) && isNullOrUndefined(this.oldPoint.y)) {
                this.diffPoint.x = parent.activeObj.activePoint.startX - x;
                this.diffPoint.y = y - parent.activeObj.activePoint.endY;
            }
            else {
                this.diffPoint.x = this.oldPoint.x - x;
                this.diffPoint.y = y - this.oldPoint.y;
            }
            this.oldPoint.x = x;
            this.oldPoint.y = y;
            if (this.diffPoint.x <= prevDiffX && this.diffPoint.y >= prevDiffY) {
                diff = Math.min(this.diffPoint.x, this.diffPoint.y);
            }
            else {
                diff = Math.max(this.diffPoint.x, this.diffPoint.y);
            }
            percentage = (diff / 10);
            parent.activeObj.activePoint.startX -= (maxDimension.width / 100) * percentage;
            parent.activeObj.activePoint.endY += (maxDimension.height / 100) * percentage;
            if (this.preventTextDraggingInvertly()) {
                parent.activeObj.activePoint.startX += (maxDimension.width / 100) * percentage;
                parent.activeObj.activePoint.endY -= (maxDimension.height / 100) * percentage;
            }
            parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
            parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,
                value: { obj: parent.activeObj } });
        }
        else {
            let splitWords;
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape !== undefined && splitWords[0] !== 'crop')) {
                this.adjustSWPoints(parent.activeObj.activePoint, x, y, parent.activeObj.rotatedAngle);
                if (parent.activeObj.activePoint.startX > parent.activeObj.activePoint.endX) {
                    const temp = parent.activeObj.activePoint.startX;
                    parent.activeObj.activePoint.startX = parent.activeObj.activePoint.endX;
                    parent.activeObj.activePoint.endX = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'se-resize';
                }
                if (parent.activeObj.activePoint.endY < parent.activeObj.activePoint.startY) {
                    const temp = parent.activeObj.activePoint.endY;
                    parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY;
                    parent.activeObj.activePoint.startY = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'nw-resize';
                }
                this.preventDraggingInvertly();
            }
            else {
                if (parent.activeObj.activePoint.startX < x && parent.activeObj.activePoint.endY > y) {
                    width = x - parent.activeObj.activePoint.startX;
                    height = parent.activeObj.activePoint.endY - y;
                    scale = Math.min(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.startX += newScale.x;
                    parent.activeObj.activePoint.endY -= newScale.y;
                    const endX = parent.img.destLeft > 0 ? parent.img.destLeft : 0;
                    const endY = parent.img.destTop + parent.img.destHeight < parent.lowerCanvas.height ? parent.img.destTop +
                        parent.img.destHeight : parent.lowerCanvas.height;
                    if (parent.activeObj.activePoint.startX < endX || parent.activeObj.activePoint.endY > endY) {
                        parent.activeObj.activePoint.startX -= newScale.x;
                        parent.activeObj.activePoint.endY += newScale.y;
                    }
                }
                else {
                    width = parent.activeObj.activePoint.startX - x;
                    height = y - parent.activeObj.activePoint.endY;
                    scale = Math.max(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.startX -= newScale.x;
                    parent.activeObj.activePoint.endY += newScale.y;
                    const endX = parent.img.destLeft > 0 ? parent.img.destLeft : 0;
                    const endY = parent.img.destTop + parent.img.destHeight < parent.lowerCanvas.height ? parent.img.destTop +
                        parent.img.destHeight : parent.lowerCanvas.height;
                    if (parent.activeObj.activePoint.startX < endX || parent.activeObj.activePoint.endY > endY) {
                        parent.activeObj.activePoint.startX += newScale.x;
                        parent.activeObj.activePoint.endY -= newScale.y;
                    }
                }
            }
            parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
            parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
            this.preventInverseResize(tempActiveObj);
        }
    }
    updateSPoints(x, y) {
        const parent = this.parent;
        let width;
        let height;
        let scale;
        if (parent.activeObj.shape !== 'text') {
            let splitWords;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape && splitWords[0] !== 'crop')) {
                if (parent.activeObj.shape !== 'line' && parent.activeObj.shape !== 'arrow' && parent.activeObj.shape !== 'path' &&
                    parent.activeObj.rotatedAngle !== 0 && this.dragPoint.startX) {
                    if (this.dragPoint.startX && this.dragPoint.startY) {
                        this.previousPoint.x = this.dragPoint.endX;
                        this.previousPoint.y = this.dragPoint.endY;
                        this.dragPoint.endX = x;
                        this.dragPoint.endY = y;
                    }
                    width = (this.dragPoint.endX - this.previousPoint.x);
                    height = (this.dragPoint.endY - this.previousPoint.y);
                    this.adjustRotationPoints(parent.activeObj.activePoint, width, height, parent.activeObj.rotatedAngle);
                }
                else {
                    parent.activeObj.activePoint.endY = y;
                    parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
                }
                if (parent.activeObj.activePoint.endY < parent.activeObj.activePoint.startY) {
                    const temp = parent.activeObj.activePoint.endY;
                    parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY;
                    parent.activeObj.activePoint.startY = temp;
                    this.dragElement = this.resizedElement = 'n-resize';
                }
                this.preventDraggingInvertly();
            }
            else {
                if (parent.activeObj.activePoint.endX > x && parent.activeObj.activePoint.endY > y) {
                    width = parent.activeObj.activePoint.endX - x;
                    height = parent.activeObj.activePoint.endY - y;
                    scale = Math.min(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.endX -= newScale.x;
                    parent.activeObj.activePoint.endY -= newScale.y;
                    if (parent.activeObj.activePoint.endX > (parent.img.destLeft + parent.img.destWidth) ||
                        parent.activeObj.activePoint.endY > (parent.img.destTop + parent.img.destHeight)) {
                        parent.activeObj.activePoint.endX += newScale.x;
                        parent.activeObj.activePoint.endY += newScale.y;
                    }
                }
                else {
                    width = x - parent.activeObj.activePoint.endX;
                    height = y - parent.activeObj.activePoint.endY;
                    scale = Math.max(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.endX += newScale.x;
                    parent.activeObj.activePoint.endY += newScale.x;
                    if (parent.activeObj.activePoint.endX > (parent.img.destLeft + parent.img.destWidth) ||
                        parent.activeObj.activePoint.endY > (parent.img.destTop + parent.img.destHeight)) {
                        parent.activeObj.activePoint.endX -= newScale.x;
                        parent.activeObj.activePoint.endY -= newScale.y;
                    }
                }
                parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
                parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
            }
        }
    }
    updateSEPoints(x, y, maxDimension) {
        const parent = this.parent;
        let diff;
        let width;
        let height;
        let scale;
        let percentage;
        const prevDiffX = this.diffPoint.x;
        const prevDiffY = this.diffPoint.y;
        const tempActiveObj = extend({}, parent.activeObj, null, true);
        if (parent.activeObj.shape === 'text') {
            if (this.oldPoint.x === undefined && this.oldPoint.y === undefined) {
                this.diffPoint.x = x - parent.activeObj.activePoint.endX;
                this.diffPoint.y = y - parent.activeObj.activePoint.endY;
            }
            else {
                this.diffPoint.x = x - this.oldPoint.x;
                this.diffPoint.y = y - this.oldPoint.y;
            }
            this.oldPoint.x = x;
            this.oldPoint.y = y;
            if (this.diffPoint.x >= prevDiffX && this.diffPoint.y >= prevDiffY) {
                diff = Math.max(this.diffPoint.x, this.diffPoint.y);
            }
            else {
                diff = Math.min(this.diffPoint.x, this.diffPoint.y);
            }
            percentage = (diff / 10);
            parent.activeObj.activePoint.endX += (maxDimension.width / 50) * percentage;
            parent.activeObj.activePoint.endY += (maxDimension.height / 50) * percentage;
            if (this.preventTextDraggingInvertly()) {
                parent.activeObj.activePoint.endX -= (maxDimension.width / 50) * percentage;
                parent.activeObj.activePoint.endY -= (maxDimension.height / 50) * percentage;
            }
            parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
            parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
            parent.notify('shape', { prop: 'updateFontSize', onPropertyChange: false,
                value: { obj: parent.activeObj } });
        }
        else {
            let splitWords;
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.activeObj.shape === 'crop-custom' || (parent.activeObj.shape !== undefined && splitWords[0] !== 'crop')) {
                this.adjustSEPoints(parent.activeObj.activePoint, x, y, parent.activeObj.rotatedAngle);
                if (parent.activeObj.activePoint.endX < parent.activeObj.activePoint.startX) {
                    const temp = parent.activeObj.activePoint.endX;
                    parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX;
                    parent.activeObj.activePoint.startX = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'sw-resize';
                }
                if (parent.activeObj.activePoint.endY < parent.activeObj.activePoint.startY) {
                    const temp = parent.activeObj.activePoint.endY;
                    parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY;
                    parent.activeObj.activePoint.startY = temp;
                    this.dragElement = parent.upperCanvas.style.cursor = parent.cursor = 'ne-resize';
                }
                this.preventDraggingInvertly();
            }
            else {
                if (parent.activeObj.activePoint.endX > x && parent.activeObj.activePoint.endY > y) {
                    width = parent.activeObj.activePoint.endX - x;
                    height = parent.activeObj.activePoint.endY - y;
                    scale = Math.min(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.endX -= newScale.x;
                    parent.activeObj.activePoint.endY -= newScale.y;
                    const endX = parent.img.destLeft + parent.img.destWidth < parent.lowerCanvas.width ?
                        parent.img.destLeft + parent.img.destWidth : parent.lowerCanvas.width;
                    const endY = parent.img.destTop + parent.img.destHeight < parent.lowerCanvas.height ?
                        parent.img.destTop + parent.img.destHeight : parent.lowerCanvas.height;
                    if (parent.activeObj.activePoint.endX > endX || parent.activeObj.activePoint.endY > endY) {
                        parent.activeObj.activePoint.endX += newScale.x;
                        parent.activeObj.activePoint.endY += newScale.y;
                    }
                }
                else {
                    width = x - parent.activeObj.activePoint.endX;
                    height = y - parent.activeObj.activePoint.endY;
                    scale = Math.max(width, height);
                    const newScale = this.getScaleRatio(scale);
                    parent.activeObj.activePoint.endX += newScale.x;
                    parent.activeObj.activePoint.endY += newScale.y;
                    const endX = parent.img.destLeft + parent.img.destWidth < parent.lowerCanvas.width ? parent.img.destLeft +
                        parent.img.destWidth : parent.lowerCanvas.width;
                    const endY = parent.img.destTop + parent.img.destHeight < parent.lowerCanvas.height ? parent.img.destTop +
                        parent.img.destHeight : parent.lowerCanvas.height;
                    if (parent.activeObj.activePoint.endX > endX || parent.activeObj.activePoint.endY > endY) {
                        parent.activeObj.activePoint.endX -= newScale.x;
                        parent.activeObj.activePoint.endY -= newScale.y;
                    }
                }
            }
            parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
            parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
            this.preventInverseResize(tempActiveObj);
        }
    }
    adjustNWPoints(rectangle, x, y, angle) {
        const cx = rectangle.startX + rectangle.width / 2;
        const cy = rectangle.startY + rectangle.height / 2;
        const rotatedC = this.rotatePoints(rectangle.endX, rectangle.endY, cx, cy, angle);
        const newCenter = [(rotatedC[0] + x) / 2, (rotatedC[1] + y) / 2];
        const newBottomRight = this.rotatePoints(rotatedC[0], rotatedC[1], newCenter[0], newCenter[1], -angle);
        const newTopLeft = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
        rectangle.endX = newBottomRight[0];
        rectangle.endY = newBottomRight[1];
        rectangle.startY = newTopLeft[1];
        rectangle.startX = newTopLeft[0];
        rectangle.width = rectangle.endX - rectangle.startX;
        rectangle.height = rectangle.endY - rectangle.startY;
        return rectangle;
    }
    adjustNEPoints(rectangle, x, y, angle) {
        const cx = rectangle.startX + rectangle.width / 2;
        const cy = rectangle.startY + rectangle.height / 2;
        const rotatedD = this.rotatePoints(rectangle.startX, rectangle.endY, cx, cy, angle);
        const newCenter = [(rotatedD[0] + x) / 2, (rotatedD[1] + y) / 2];
        const newBottomLeft = this.rotatePoints(rotatedD[0], rotatedD[1], newCenter[0], newCenter[1], -angle);
        const newTopRight = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
        rectangle.startX = newBottomLeft[0];
        rectangle.endY = newBottomLeft[1];
        rectangle.width = newTopRight[0] - newBottomLeft[0];
        rectangle.height = newBottomLeft[1] - newTopRight[1];
        rectangle.endX = rectangle.startX + rectangle.width;
        rectangle.startY = rectangle.endY - rectangle.height;
        return rectangle;
    }
    adjustSWPoints(rectangle, x, y, angle) {
        const cx = rectangle.startX + rectangle.width / 2;
        const cy = rectangle.startY + rectangle.height / 2;
        const rotatedB = this.rotatePoints(rectangle.endX, rectangle.startY, cx, cy, angle);
        const newCenter = [(rotatedB[0] + x) / 2, (rotatedB[1] + y) / 2];
        const newTopRight = this.rotatePoints(rotatedB[0], rotatedB[1], newCenter[0], newCenter[1], -angle);
        const newBottomLeft = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
        rectangle.endX = newTopRight[0];
        rectangle.startY = newTopRight[1];
        rectangle.startX = newBottomLeft[0];
        rectangle.endY = newBottomLeft[1];
        rectangle.width = rectangle.endX - rectangle.startX;
        rectangle.height = rectangle.endY - rectangle.startY;
        return rectangle;
    }
    adjustSEPoints(rectangle, x, y, angle) {
        const cx = rectangle.startX + rectangle.width / 2;
        const cy = rectangle.startY + rectangle.height / 2;
        const rotatedA = this.rotatePoints(rectangle.startX, rectangle.startY, cx, cy, angle);
        const newCenter = [(rotatedA[0] + x) / 2, (rotatedA[1] + y) / 2];
        const newTopLeft = this.rotatePoints(rotatedA[0], rotatedA[1], newCenter[0], newCenter[1], -angle);
        const newBottomRight = this.rotatePoints(x, y, newCenter[0], newCenter[1], -angle);
        rectangle.startX = newTopLeft[0];
        rectangle.startY = newTopLeft[1];
        rectangle.width = newBottomRight[0] - newTopLeft[0];
        rectangle.height = newBottomRight[1] - newTopLeft[1];
        rectangle.endX = rectangle.startX + rectangle.width;
        rectangle.endY = rectangle.startY + rectangle.height;
        return rectangle;
    }
    adjustRotationPoints(rectangle, x, y, angle) {
        const cx = rectangle.startX + rectangle.width / 2;
        const cy = rectangle.startY + rectangle.height / 2;
        this.getResizeDirection(rectangle, x, y, angle);
        const rotatedA = this.rotatePoints(rectangle.startX, rectangle.startY, cx, cy, angle);
        const rotatedB = this.rotatePoints(rectangle.endX, rectangle.startY, cx, cy, angle);
        const rotatedC = this.rotatePoints(rectangle.endX, rectangle.endY, cx, cy, angle);
        const rotatedD = this.rotatePoints(rectangle.startX, rectangle.endY, cx, cy, angle);
        const newCenter = [(rotatedA[0] + rotatedC[0]) / 2, (rotatedA[1] + rotatedC[1]) / 2];
        const newTopLeft = this.rotatePoints(rotatedA[0], rotatedA[1], newCenter[0], newCenter[1], -angle);
        const newBottomLeft = this.rotatePoints(rotatedD[0], rotatedD[1], newCenter[0], newCenter[1], -angle);
        const newTopRight = this.rotatePoints(rotatedB[0], rotatedB[1], newCenter[0], newCenter[1], -angle);
        rectangle.startX = newTopLeft[0];
        rectangle.startY = newTopLeft[1];
        rectangle.endX = newTopRight[0];
        rectangle.endY = newBottomLeft[1];
        rectangle.width = rectangle.endX - rectangle.startX;
        rectangle.height = rectangle.endY - rectangle.startY;
        return rectangle;
    }
    rotatePoints(x, y, cx, cy, angle) {
        return [
            (x - cx) * Math.cos(angle) - (y - cy) * Math.sin(angle) + cx,
            (x - cx) * Math.sin(angle) + (y - cy) * Math.cos(angle) + cy
        ];
    }
    setResizedValue(element, value, x, y) {
        switch (element) {
            case 'x':
                value += x;
                break;
            case 'y':
                value += y;
                break;
            case 'abs-x':
                value += (x > 0 ? -x : Math.abs(x));
                break;
            case 'abs-y':
                value += (y > 0 ? -y : Math.abs(y));
                break;
            case 'y-abs-x':
                value += (y + ((x > 0 ? -x : Math.abs(x)) / 2));
                break;
            case 'abs-x-abs-y':
                value += ((x > 0 ? -x : Math.abs(x)) + ((y > 0 ? -y : Math.abs(y)) / 2));
                break;
            case 'abs-y-x':
                value += ((y > 0 ? -y : Math.abs(y)) + (x / 2));
                break;
            case 'x-y':
                value += (x + (y / 2));
                break;
        }
        return value;
    }
    getResizeDirection(rectangle, x, y, angle) {
        const rotatedAngle = angle * (180 / Math.PI);
        const element = this.getResizedElement(rotatedAngle, this.resizedElement);
        if (this.resizedElement === 'e-resize') {
            rectangle.width = this.setResizedValue(element, rectangle.width, x, y);
            rectangle.endX = rectangle.width + rectangle.startX;
        }
        else if (this.resizedElement === 'n-resize') {
            rectangle.startY = this.setResizedValue(element, rectangle.startY, x, y);
            rectangle.height = rectangle.endY - rectangle.startY;
        }
        else if (this.resizedElement === 'w-resize') {
            rectangle.startX = this.setResizedValue(element, rectangle.startX, x, y);
            rectangle.width = rectangle.startX + rectangle.endX;
        }
        else if (this.resizedElement === 's-resize') {
            rectangle.height = this.setResizedValue(element, rectangle.height, x, y);
            rectangle.endY = rectangle.height + rectangle.startY;
        }
    }
    getResizedElement(degree, element) {
        let resizeMappings = [];
        if (element === 'n-resize') {
            resizeMappings = [
                [337.5, 360, 'y'],
                [0, 22.5, 'y'],
                [22.5, 67.5, 'y-abs-x'],
                [67.5, 112.5, 'abs-x'],
                [112.5, 157.5, 'abs-x-abs-y'],
                [157.5, 202.5, 'abs-y'],
                [202.5, 247.5, 'abs-y-x'],
                [247.5, 292.5, 'x'],
                [292.5, 337.5, 'x-y']
            ];
        }
        else if (element === 'e-resize') {
            resizeMappings = [
                [337.5, 360, 'x'],
                [0, 22.5, 'x'],
                [22.5, 67.5, 'x-y'],
                [67.5, 112.5, 'y'],
                [112.5, 157.5, 'y-abs-x'],
                [157.5, 202.5, 'abs-x'],
                [202.5, 247.5, 'abs-x-abs-y'],
                [247.5, 292.5, 'abs-y'],
                [292.5, 337.5, 'abs-y-x']
            ];
        }
        else if (element === 's-resize') {
            resizeMappings = [
                [337.5, 360, 'y'],
                [0, 22.5, 'y'],
                [22.5, 67.5, 'y-abs-x'],
                [67.5, 112.5, 'abs-x'],
                [112.5, 157.5, 'abs-x-abs-y'],
                [157.5, 202.5, 'abs-y'],
                [202.5, 247.5, 'abs-y-x'],
                [247.5, 292.5, 'x'],
                [292.5, 337.5, 'x-y']
            ];
        }
        else if (element === 'w-resize') {
            resizeMappings = [
                [337.5, 360, 'x'],
                [0, 22.5, 'x'],
                [22.5, 67.5, 'x-y'],
                [67.5, 112.5, 'y'],
                [112.5, 157.5, 'y-abs-x'],
                [157.5, 202.5, 'abs-x'],
                [202.5, 247.5, 'abs-x-abs-y'],
                [247.5, 292.5, 'abs-y'],
                [292.5, 337.5, 'abs-y-x']
            ];
        }
        const positiveDegree = degree < 0 ? 360 - Math.abs(degree) : degree;
        for (const [startDegree, endDegree, resizeElement] of resizeMappings) {
            if ((positiveDegree > startDegree && positiveDegree <= endDegree) ||
                (positiveDegree + 360 > startDegree && positiveDegree + 360 <= endDegree)) {
                return resizeElement;
            }
        }
        return element;
    }
    updateCursorStyles(x, y, type) {
        const parent = this.parent;
        let isResize = false;
        if (parent.activeObj.keyHistory !== '' && parent.activeObj.shape === undefined && !parent.currObjType.isCustomCrop &&
            !parent.currObjType.isLine && parent.currObjType.isText) {
            parent.activeObj.shape = 'text';
        }
        const actObj = extend({}, parent.activeObj, {}, true);
        if (isNullOrUndefined(actObj.topLeftCircle)) {
            return;
        }
        let degree;
        if (actObj.shapeDegree === 0) {
            degree = parent.transform.degree;
        }
        else {
            degree = parent.transform.degree - actObj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        if (this.isObjSelected) {
            if (actObj.shape === 'line' || actObj.shape === 'arrow') {
                isResize = this.updateCursorStylesForLineArrow(x, y, actObj);
            }
            else if (actObj.shape === 'path') {
                isResize = this.updateCursorStylesForPath(x, y, actObj);
            }
            else if (actObj.rotatedAngle) {
                this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
                if (parent.cursor === 'grabbing') {
                    parent.upperCanvas.style.cursor = this.parent.cursor = 'grabbing';
                    this.dragElement = parent.cursor;
                }
                else if (parent.cursor === 'move') {
                    this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
                    this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
                }
                else if (parent.cursor !== 'default') {
                    isResize = true;
                    this.dragElement = parent.cursor;
                    parent.currObjType.isResize = true;
                }
            }
            else {
                const rotationCirclePoint = this.getTransRotationPoint(actObj);
                if (x >= (actObj.topLeftCircle.startX - (actObj.topLeftCircle.radius * 2)) &&
                    x <= (actObj.topLeftCircle.startX + (actObj.topLeftCircle.radius * 2)) &&
                    y >= (actObj.topLeftCircle.startY - (actObj.topLeftCircle.radius * 2)) &&
                    y <= (actObj.topLeftCircle.startY + (actObj.topLeftCircle.radius * 2)) && this.dragElement !== 'nw-resize') {
                    actObj.topLeftCircle.startX = actObj.topLeftCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'nw-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.topLeftCircle.startX - (actObj.topLeftCircle.radius * 2)) &&
                    x <= (actObj.topRightCircle.startX - (actObj.topLeftCircle.radius * 2)) &&
                    y >= (actObj.topCenterCircle.startY - (actObj.topLeftCircle.radius * 2)) &&
                    y <= (actObj.topCenterCircle.startY + (actObj.topLeftCircle.radius * 2)) && this.dragElement !== 'n-resize') {
                    actObj.topCenterCircle.startX = actObj.topCenterCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'n-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.topRightCircle.startX - (actObj.topLeftCircle.radius * 2)) &&
                    x <= (actObj.topRightCircle.startX + (actObj.topLeftCircle.radius * 2)) &&
                    y >= (actObj.topRightCircle.startY - (actObj.topLeftCircle.radius * 2)) &&
                    y <= (actObj.topRightCircle.startY + (actObj.topLeftCircle.radius * 2)) && this.dragElement !== 'ne-resize') {
                    actObj.topRightCircle.startX = actObj.topRightCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'ne-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.centerLeftCircle.startX - (actObj.topLeftCircle.radius * 2)) &&
                    x <= (actObj.centerLeftCircle.startX + (actObj.topLeftCircle.radius * 2)) &&
                    y >= (actObj.topLeftCircle.startY - (actObj.topLeftCircle.radius * 2)) &&
                    y <= (actObj.bottomLeftCircle.startY - (actObj.topLeftCircle.radius * 2)) && this.dragElement !== 'w-resize') {
                    actObj.centerLeftCircle.startX = actObj.centerLeftCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'w-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.centerRightCircle.startX - (actObj.topLeftCircle.radius * 2)) &&
                    x <= (actObj.centerRightCircle.startX + (actObj.topLeftCircle.radius * 2)) &&
                    y >= (actObj.topRightCircle.startY - (actObj.topLeftCircle.radius * 2)) &&
                    y <= (actObj.bottomRightCircle.startY - (actObj.topLeftCircle.radius * 2)) && this.dragElement !== 'e-resize') {
                    actObj.centerRightCircle.startX = actObj.centerRightCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'e-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.bottomLeftCircle.startX - (actObj.topLeftCircle.radius * 2)) &&
                    x <= (actObj.bottomLeftCircle.startX + (actObj.topLeftCircle.radius * 2)) &&
                    y >= (actObj.bottomLeftCircle.startY - (actObj.topLeftCircle.radius * 2)) &&
                    y <= (actObj.bottomLeftCircle.startY + (actObj.topLeftCircle.radius * 2)) && this.dragElement !== 'sw-resize') {
                    actObj.bottomLeftCircle.startX = actObj.bottomLeftCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'sw-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.bottomLeftCircle.startX - (actObj.topLeftCircle.radius * 2)) &&
                    x <= (actObj.bottomRightCircle.startX - (actObj.topLeftCircle.radius * 2)) &&
                    y >= (actObj.bottomCenterCircle.startY - (actObj.topLeftCircle.radius * 2)) &&
                    y <= (actObj.bottomCenterCircle.startY + (actObj.topLeftCircle.radius * 2)) && this.dragElement !== 's-resize') {
                    actObj.bottomCenterCircle.startX = actObj.bottomCenterCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 's-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (x >= (actObj.bottomRightCircle.startX - (actObj.topLeftCircle.radius * 2)) &&
                    x <= (actObj.bottomRightCircle.startX + (actObj.topLeftCircle.radius * 2)) &&
                    y >= (actObj.bottomRightCircle.startY - (actObj.topLeftCircle.radius * 2)) &&
                    y <= (actObj.bottomRightCircle.startY + (actObj.topLeftCircle.radius * 2)) && this.dragElement !== 'se-resize') {
                    actObj.bottomRightCircle.startX = actObj.bottomRightCircle.startY = 0;
                    parent.upperCanvas.style.cursor = parent.cursor = 'se-resize';
                    isResize = true;
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else if (rotationCirclePoint &&
                    x >= rotationCirclePoint.x - (actObj.topLeftCircle.radius * 2) &&
                    x <= rotationCirclePoint.x + (actObj.topLeftCircle.radius * 2) &&
                    y >= rotationCirclePoint.y - (actObj.topLeftCircle.radius * 2) &&
                    y <= rotationCirclePoint.y + (actObj.topLeftCircle.radius * 2) && this.dragElement !== 'grabbing') {
                    parent.upperCanvas.style.cursor = parent.cursor = 'grabbing';
                    this.dragElement = parent.upperCanvas.style.cursor;
                }
                else {
                    this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
                    this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
                }
                if ((actObj.shape === 'text') && (parent.cursor === 'n-resize' ||
                    parent.cursor === 's-resize' || parent.cursor === 'e-resize' ||
                    parent.cursor === 'w-resize')) {
                    parent.upperCanvas.style.cursor = parent.cursor = 'move';
                    this.dragElement = '';
                    this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
                    this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
                }
            }
        }
        else {
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
        }
        this.previousPoint.x = this.previousPoint.y = this.diffPoint.x = this.diffPoint.y = 0;
        if (type === 'touchstart') {
            if (isResize || (x >= actObj.activePoint.startX && x <= actObj.activePoint.endX
                && y >= actObj.activePoint.startY && y <= actObj.activePoint.endY) || this.dragElement === 'grabbing') {
                parent.currObjType.isDragging = true;
            }
            else if (actObj.shape === 'line' || actObj.shape === 'arrow') {
                this.setCursorForLineArrow(actObj, x, y, parent.upperCanvas);
                if (parent.cursor === 'move') {
                    parent.currObjType.isDragging = true;
                }
            }
            else if (actObj.shape === 'path') {
                this.setCursorForPath(actObj, x, y, parent.upperCanvas);
                if (parent.cursor === 'move') {
                    parent.currObjType.isDragging = true;
                }
            }
        }
        else {
            parent.currObjType.isDragging = true;
        }
        if (actObj.rotatedAngle !== 0 && (this.dragElement === 'e-resize' ||
            this.dragElement === 'w-resize' || this.dragElement === 'n-resize' ||
            this.dragElement === 's-resize')) {
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
        }
    }
    updateCursorStylesForLineArrow(x, y, actObj) {
        let isResize = false;
        const parent = this.parent;
        let point;
        for (let i = 0; i < 5; i++) {
            point = actObj.pointColl[i];
            if (x >= (point.x - (actObj.topLeftCircle.radius * 2)) && x <= (point.x + (actObj.topLeftCircle.radius * 2)) &&
                y >= (point.y - (actObj.topLeftCircle.radius * 2)) && y <= (point.y + (actObj.topLeftCircle.radius * 2))) {
                actObj.centerLeftCircle.startX = actObj.centerLeftCircle.startY = 0;
                this.dragElement = 'w-resize';
                isResize = true;
                break;
            }
        }
        if (!isResize) {
            for (let i = 1; i < 6; i++) {
                point = actObj.pointColl[actObj.pointColl.length - i];
                if (x >= (point.x - (actObj.topLeftCircle.radius * 2)) && x <= (point.x + (actObj.topLeftCircle.radius * 2)) &&
                    y >= (point.y - (actObj.topLeftCircle.radius * 2)) && y <= (point.y + (actObj.topLeftCircle.radius * 2))) {
                    actObj.centerRightCircle.startX = actObj.centerRightCircle.startY = 0;
                    this.dragElement = 'e-resize';
                    isResize = true;
                    break;
                }
            }
        }
        if (!isResize) {
            for (let i = 0; i < actObj.pointColl.length; i++) {
                point = actObj.pointColl[i];
                if (x >= (point.x - (actObj.topLeftCircle.radius * 2)) && x <= (point.x + (actObj.topLeftCircle.radius * 2)) &&
                    y >= (point.y - (actObj.topLeftCircle.radius * 2)) && y <= (point.y + (actObj.topLeftCircle.radius * 2))) {
                    parent.upperCanvas.style.cursor = parent.cursor = 'move';
                    this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
                    this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
                    break;
                }
                else {
                    parent.upperCanvas.style.cursor = parent.cursor = 'default';
                }
            }
        }
        return isResize;
    }
    updateCursorStylesForPath(x, y, actObj) {
        let isResize = false;
        this.pathAdjustedIndex = this.setCursorForLineArrow(actObj, x, y, this.parent.upperCanvas);
        if (this.parent.cursor === 'move') {
            isResize = true;
            this.dragElement = 'pathDrag';
        }
        if (!isResize) {
            this.parent.upperCanvas.style.cursor = this.parent.cursor = 'move';
            this.dragPoint.startX = this.previousPoint.x = this.dragPoint.endX = x;
            this.dragPoint.startY = this.previousPoint.y = this.dragPoint.endY = y;
        }
        return isResize;
    }
    setTextSelection(width, height) {
        const parent = this.parent;
        let degree = parent.transform.degree;
        if (parent.activeObj.shapeDegree === 0) {
            degree = parent.transform.degree;
        }
        else {
            degree = parent.transform.degree - parent.activeObj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        for (let i = 0, len = parent.activeObj.flipObjColl.length; i < len; i++) {
            const flip = parent.activeObj.flipObjColl[i].toLowerCase();
            switch (degree) {
                case 0:
                    switch (flip) {
                        case 'horizontal':
                            parent.activeObj.activePoint = { startX: parent.activeObj.activePoint.endX - width,
                                startY: parent.activeObj.activePoint.startY,
                                endX: (parent.activeObj.activePoint.endX),
                                endY: parent.activeObj.activePoint.startY + (height ? height : 0) };
                            break;
                        case 'vertical':
                            parent.activeObj.activePoint.startY = parent.activeObj.activePoint.endY - height;
                            parent.activeObj.activePoint = { startX: parent.activeObj.activePoint.startX,
                                startY: parent.activeObj.activePoint.startY,
                                endX: (parent.activeObj.activePoint.startX + (width ? width : 0)),
                                endY: parent.activeObj.activePoint.endY };
                            break;
                        default:
                            parent.activeObj.activePoint = { startX: parent.activeObj.activePoint.startX,
                                startY: parent.activeObj.activePoint.startY,
                                endX: (parent.activeObj.activePoint.startX + (width ? width : 0)),
                                endY: parent.activeObj.activePoint.startY + (height ? height : 0) };
                            break;
                    }
                    break;
                case 90:
                    switch (flip) {
                        case 'horizontal':
                            parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + height;
                            parent.activeObj.activePoint = { startX: parent.activeObj.activePoint.startX,
                                startY: parent.activeObj.activePoint.startY, endX: (parent.activeObj.activePoint.endX),
                                endY: parent.activeObj.activePoint.startY + (width ? width : 0) };
                            break;
                        case 'vertical':
                            parent.activeObj.activePoint.startX = parent.activeObj.activePoint.endX - height;
                            parent.activeObj.activePoint = { startX: parent.activeObj.activePoint.startX,
                                startY: parent.activeObj.activePoint.endY - width,
                                endX: (parent.activeObj.activePoint.endX),
                                endY: parent.activeObj.activePoint.endY };
                            break;
                        default:
                            parent.activeObj.activePoint.startX = parent.activeObj.activePoint.endX - height;
                            parent.activeObj.activePoint = { startX: parent.activeObj.activePoint.startX,
                                startY: parent.activeObj.activePoint.startY, endX: (parent.activeObj.activePoint.endX),
                                endY: parent.activeObj.activePoint.startY + (width ? width : 0) };
                            break;
                    }
                    break;
                case 180:
                    switch (flip) {
                        case 'horizontal':
                            parent.activeObj.activePoint.startY = parent.activeObj.activePoint.endY - height;
                            parent.activeObj.activePoint = { startX: parent.activeObj.activePoint.startX,
                                startY: parent.activeObj.activePoint.startY,
                                endX: (parent.activeObj.activePoint.startX + width),
                                endY: parent.activeObj.activePoint.endY };
                            break;
                        case 'vertical':
                            parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + height;
                            parent.activeObj.activePoint = { endX: parent.activeObj.activePoint.endX, endY: parent.activeObj.activePoint.endY,
                                startX: (parent.activeObj.activePoint.endX - (width ? width : 0)),
                                startY: parent.activeObj.activePoint.startY };
                            break;
                        default:
                            parent.activeObj.activePoint = { endX: parent.activeObj.activePoint.endX, endY: parent.activeObj.activePoint.endY,
                                startX: (parent.activeObj.activePoint.endX - (width ? width : 0)),
                                startY: parent.activeObj.activePoint.endY - (height ? height : 0) };
                            break;
                    }
                    break;
                case 270:
                    switch (flip) {
                        case 'horizontal':
                            parent.activeObj.activePoint.startX = parent.activeObj.activePoint.endX - height;
                            parent.activeObj.activePoint = { startX: parent.activeObj.activePoint.startX,
                                startY: parent.activeObj.activePoint.endY - (width ? width : 0),
                                endX: parent.activeObj.activePoint.endX,
                                endY: parent.activeObj.activePoint.endY };
                            break;
                        case 'vertical':
                            parent.activeObj.activePoint = { startX: parent.activeObj.activePoint.startX,
                                startY: parent.activeObj.activePoint.startY,
                                endX: (parent.activeObj.activePoint.startX + height),
                                endY: parent.activeObj.activePoint.startY + (width ? width : 0) };
                            break;
                        default:
                            parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + height;
                            parent.activeObj.activePoint = { startX: parent.activeObj.activePoint.startX,
                                startY: parent.activeObj.activePoint.endY - (width ? width : 0),
                                endX: parent.activeObj.activePoint.endX,
                                endY: parent.activeObj.activePoint.endY };
                            break;
                    }
                    break;
            }
        }
        if (parent.activeObj.flipObjColl.length === 0) {
            switch (degree) {
                case 0:
                    parent.activeObj.activePoint = { startX: parent.activeObj.activePoint.startX, startY: parent.activeObj.activePoint.startY,
                        endX: (parent.activeObj.activePoint.startX + (width ? width : 0)),
                        endY: parent.activeObj.activePoint.startY + (height ? height : 0) };
                    break;
                case 90:
                    parent.activeObj.activePoint.startX = parent.activeObj.activePoint.endX - height;
                    parent.activeObj.activePoint = { startX: parent.activeObj.activePoint.startX, startY: parent.activeObj.activePoint.startY,
                        endX: (parent.activeObj.activePoint.endX),
                        endY: parent.activeObj.activePoint.startY + (width ? width : 0) };
                    break;
                case 180:
                    parent.activeObj.activePoint = { endX: parent.activeObj.activePoint.endX, endY: parent.activeObj.activePoint.endY,
                        startX: (parent.activeObj.activePoint.endX - (width ? width : 0)),
                        startY: parent.activeObj.activePoint.endY - (height ? height : 0) };
                    break;
                case 270:
                    parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + height;
                    parent.activeObj.activePoint = { startX: parent.activeObj.activePoint.startX,
                        startY: parent.activeObj.activePoint.endY - (width ? width : 0),
                        endX: parent.activeObj.activePoint.endX,
                        endY: parent.activeObj.activePoint.endY };
                    break;
            }
        }
        parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
        parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
        if (parent.transform.degree === 360 || parent.transform.degree === -360) {
            parent.transform.degree = 0;
        }
    }
    setActivePoint(startX, startY) {
        const parent = this.parent;
        if (isNullOrUndefined(parent.activeObj.activePoint)) {
            return;
        }
        if (parent.currObjType.isText) {
            const textWidth = startX ? startX : 0;
            const textHeight = startY ? startY : parent.activeObj.textSettings.fontSize;
            if (parent.activeObj.textSettings.fontSize === undefined) {
                parent.activeObj.textSettings.fontSize = (Math.abs(parent.baseImg.width - parent.baseImg.height)) * 0.1;
            }
            this.setTextSelection(textWidth, textHeight);
            this.mouseDownPoint.x = parent.activeObj.activePoint.endX;
            this.mouseDownPoint.y = parent.activeObj.activePoint.endY;
            if (parent.activeObj.horTopLine !== undefined) {
                parent.activeObj.activePoint = extend({}, parent.activeObj.activePoint, {}, true);
            }
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
        }
        else if (startX && startY) {
            parent.activeObj.activePoint.startX = this.mouseDownPoint.x = startX;
            parent.activeObj.activePoint.startY = this.mouseDownPoint.y = startY;
            parent.currObjType.isDragging = true;
        }
        else {
            const selectInfo = parent.activeObj;
            parent.activeObj.activePoint = { startX: selectInfo.horTopLine.startX, startY: selectInfo.horTopLine.startY,
                endX: selectInfo.horTopLine.endX, endY: selectInfo.horTopLine.endY };
            parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
            parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
        }
    }
    mouseDownEventHandler(e) {
        const parent = this.parent;
        if (e.type === 'touchstart') {
            this.isTouch = true;
        }
        else {
            this.isTouch = false;
        }
        if (e.type === 'touchstart' && e.currentTarget === parent.lowerCanvas && !parent.isImageLoaded) {
            return;
        }
        this.isCropSelection = false;
        this.isPan = true;
        let splitWords;
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (splitWords !== undefined && splitWords[0] === 'crop') {
            this.isCropSelection = true;
        }
        if (this.isCropSelection) {
            this.dragCanvas = parent.togglePan = true;
        }
        const imageEditorClickEventArgs = { point: this.setXYPoints(e) };
        if (isBlazor() && parent.events && parent.events.clicked.hasDelegate === true) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            parent.dotNetRef.invokeMethodAsync('ClickEventAsync', 'click', imageEditorClickEventArgs).then((imageEditorClickEventArgs) => {
                this.clickEvent(imageEditorClickEventArgs, e);
            });
        }
        else {
            parent.trigger('click', imageEditorClickEventArgs);
            this.clickEvent(imageEditorClickEventArgs, e);
        }
    }
    getImagePoints(x, y) {
        const parent = this.parent;
        if (x < parent.img.destLeft) {
            x = parent.img.destLeft;
        }
        else if (x > parent.img.destLeft + parent.img.destWidth) {
            x = parent.img.destLeft + parent.img.destWidth;
        }
        if (y < parent.img.destTop) {
            y = parent.img.destTop;
        }
        else if (y > parent.img.destTop + parent.img.destHeight) {
            y = parent.img.destTop + parent.img.destHeight;
        }
        return { x: x, y: y };
    }
    clickEvent(imageEditorClickEventArgs, e) {
        const parent = this.parent;
        const x = imageEditorClickEventArgs.point.x;
        const y = imageEditorClickEventArgs.point.y;
        const cursor = parent.activeObj.shape && parent.activeObj.shape === 'text' ?
            parent.cursor : 'default';
        if (this.currentDrawingShape !== '') {
            const object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            this.initialPrevObj = object['currObj'];
            this.initialPrevObj.objColl = extend([], parent.objColl, [], true);
            this.initialPrevObj.pointColl = extend([], parent.pointColl, [], true);
            this.initialPrevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
            const selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            this.initialPrevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            this.setActivePoint(x, y);
            if (this.currentDrawingShape === 'path') {
                const point = this.getImagePoints(x, y);
                parent.activeObj.pointColl.push({ x: point.x, y: point.y });
                if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
                    parent.activeObj.activePoint.width = 0;
                    parent.activeObj.activePoint.height = 0;
                    parent.activeObj.activePoint.startX = parent.activeObj.pointColl[parent.activeObj.pointColl.length - 1].x;
                    parent.activeObj.activePoint.startY = parent.activeObj.pointColl[parent.activeObj.pointColl.length - 1].y;
                }
            }
            parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX;
            parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY;
            parent.currObjType.isDragging = true;
            return;
        }
        if (this.isCropSelection && this.dragCanvas) {
            this.setCursor(x, y);
            if (parent.cursor !== 'move' && parent.cursor !== 'crosshair' &&
                parent.cursor !== 'default' && parent.cursor !== 'grab') {
                this.isPan = false;
            }
        }
        if (parent.activeObj.shape) {
            this.isObjSelected = true;
        }
        else {
            this.isObjSelected = false;
        }
        const object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        const activeObj = extend({}, parent.activeObj, null, true);
        const isShape = this.isShapeTouch(e, this.isCropSelection);
        const isFreehandDraw = this.isFreehandDrawTouch(e, this.isCropSelection);
        const isShapeClick = isShape ? isShape : this.isShapeClick(e, this.isCropSelection);
        const allowUndoRedoPush = this.applyCurrShape(isShapeClick);
        if (this.isTouch && !isShape && activeObj.shape && !this.isCropSelection) {
            if (this.applyObj(x, y)) {
                parent.okBtn(true);
                parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });
            }
            const prevCropObj = extend({}, parent.cropObj, {}, true);
            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: parent.isCircleCrop } });
            if (allowUndoRedoPush) {
                parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            }
        }
        if (!isShape && !parent.togglePen && !this.isCropSelection) {
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
                parent.notify('toolbar', { prop: 'close-contextual-toolbar', onPropertyChange: false });
            }
            else if (parent.isImageLoaded) {
                parent.updateToolbar(parent.element, 'imageLoaded', 'okBtnClick');
            }
        }
        if (this.dragCanvas && this.isPan && (parent.cursor === 'grab' || this.isTouch)
            && !isShape && !isFreehandDraw && !parent.togglePen) {
            if (this.applyObj(x, y)) {
                parent.okBtn(true);
                if (allowUndoRedoPush) {
                    parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                }
                parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });
            }
            if (this.isFhdEditing) {
                parent.notify('freehand-draw', { prop: 'applyFhd', onPropertyChange: false });
                this.isFhdCustomized = false;
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
                }
            }
            if (parent.activeObj.shape && (parent.activeObj.shape === 'rectangle' ||
                parent.activeObj.shape === 'ellipse' || parent.activeObj.shape === 'line' ||
                parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'path' || parent.activeObj.shape === 'text')) {
                parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                    value: { x: null, y: null, isMouseDown: null } });
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'setCurrentToolbar', value: { type: 'main' } });
                    parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
                }
                else {
                    parent.updateToolbar(parent.element, 'imageLoaded');
                }
            }
            this.canvasMouseDownHandler(e);
        }
        else {
            let isLineArrow = false;
            if (parent.activeObj.shape && (parent.activeObj.shape === 'line' ||
                parent.activeObj.shape === 'arrow')) {
                isLineArrow = true;
            }
            const points = this.setXYPoints(e);
            const x = points.x;
            const y = points.y;
            if (this.applyObj(x, y)) {
                parent.okBtn(true);
                if (allowUndoRedoPush) {
                    parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                }
                parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });
            }
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: x, y: y, isMouseDown: true } });
            const obj = { index: null };
            parent.notify('freehand-draw', { prop: 'getFreehandDrawHoveredIndex', onPropertyChange: false, value: { obj: obj } });
            const indexObj = { freehandSelectedIndex: null };
            parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
            if (this.isFhdPoint || (this.isFhdCustomized && !parent.togglePen)) {
                if (!isNullOrUndefined(indexObj['freehandSelectedIndex']) &&
                    indexObj['freehandSelectedIndex'] !== obj['index']) {
                    const tempHoveredIndex = obj['index'];
                    parent.okBtn();
                    this.isFhdCustomized = false;
                    parent.notify('freehand-draw', { prop: 'setFreehandDrawHoveredIndex', onPropertyChange: false,
                        value: { index: tempHoveredIndex } });
                    if (obj['index'] > -1) {
                        const strokeColor = parent.pointColl[obj['index']].strokeColor;
                        parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                            value: { strokeColor: strokeColor, strokeWidth: parent.pointColl[obj['index']].strokeWidth } });
                    }
                }
                indexObj['freehandSelectedIndex'] = null;
                parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
                if (!isNullOrUndefined(obj['index']) && obj['index'] > -1) {
                    parent.notify('freehand-draw', { prop: 'selectFhd', value: { type: 'ok' } });
                    if (!isBlazor()) {
                        parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: true } });
                    }
                    else {
                        parent.updateToolbar(parent.element, 'pen');
                        parent.updateToolbar(parent.element, 'quickAccessToolbar', 'pen');
                    }
                }
                else if (indexObj['freehandSelectedIndex']) {
                    parent.okBtn();
                    const strokeColor = parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor;
                    parent.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                        value: { strokeColor: strokeColor, strokeWidth: parent.pointColl[indexObj['freehandSelectedIndex']].strokeWidth } });
                }
            }
            else {
                if (this.isFhdEditing) {
                    parent.notify('freehand-draw', { prop: 'cancelFhd', value: { type: 'ok' } });
                    if (document.getElementById(parent.element.id + '_quickAccessToolbarArea')) {
                        document.getElementById(parent.element.id + '_quickAccessToolbarArea').style.display = 'none';
                    }
                }
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'close-contextual-toolbar', onPropertyChange: false });
                }
                this.isFhdEditing = false;
                if (isLineArrow) {
                    this.setCursor(x, y);
                }
                else if (cursor !== 'default') {
                    parent.upperCanvas.style.cursor = parent.cursor = cursor;
                }
                // this.setCursor(x, y);
                if (parent.cursor === 'crosshair' || (Browser.isDevice && parent.togglePen)) {
                    if (parent.togglePen) {
                        if (isNullOrUndefined(parent.activeObj.strokeSettings)) {
                            const obj = { strokeSettings: {} };
                            parent.notify('shape', { prop: 'getStrokeSettings', onPropertyChange: false,
                                value: { obj: obj } });
                            parent.activeObj.strokeSettings = obj['strokeSettings'];
                        }
                        const obj = { penStrokeWidth: null };
                        parent.notify('freehand-draw', { prop: 'getPenStrokeWidth', onPropertyChange: false, value: { obj: obj } });
                        if (isNullOrUndefined(obj['penStrokeWidth'])) {
                            parent.notify('freehand-draw', { prop: 'setPenStrokeWidth', onPropertyChange: false, value: { value: 2 } });
                        }
                        this.upperContext.strokeStyle = parent.activeObj.strokeSettings.strokeColor;
                        this.upperContext.fillStyle = parent.activeObj.strokeSettings.strokeColor;
                        parent.notify('freehand-draw', { prop: 'freehandDownHandler', onPropertyChange: false,
                            value: { e: e, canvas: parent.upperCanvas } });
                    }
                    else {
                        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                    }
                    parent.currObjType.isActiveObj = false;
                    this.dragElement = '';
                    this.dragPoint.startX = this.dragPoint.startY = this.dragPoint.endX = this.dragPoint.endY = 0;
                }
                if ((parent.cursor !== 'crosshair' && e.type.toLowerCase() === 'touchstart') ||
                    (parent.currObjType.isActiveObj && parent.cursor !== 'default' && !parent.togglePen)) {
                    if (parent.currObjType.isUndoAction) {
                        parent.notify('undo-redo', { prop: 'refreshUrc', value: { bool: null } });
                    }
                    this.findTarget(x, y, e.type);
                }
                else if ((parent.currObjType.shape === '' || parent.currObjType.isCustomCrop) && !parent.togglePen && parent.cursor !== 'default') {
                    this.setActivePoint(x, y);
                }
            }
        }
        this.isShapeInserted = false;
        this.tempActiveObj = extend({}, parent.activeObj, {}, true);
    }
    mouseMoveEventHandler(e) {
        const parent = this.parent;
        const cursor = parent.cursor;
        const canvasCursor = parent.upperCanvas.style.cursor;
        e.preventDefault();
        const bbox = parent.lowerCanvas.getBoundingClientRect();
        if (e.type === 'touchmove' && e.touches.length === 2) {
            if (this.isFirstMove) {
                this.startTouches = this.targetTouches(e.touches);
                this.tempTouches = [];
                this.tempTouches.push({ x: (e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft) - bbox.left),
                    y: (e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop)) - bbox.top });
                this.tempTouches.push({ x: (e.touches[1].clientX || (e.touches[1].pageX - parent.lowerCanvas.offsetLeft)) - bbox.left,
                    y: (e.touches[1].clientY || (e.touches[1].pageY - parent.lowerCanvas.offsetTop)) - bbox.top });
            }
            else {
                const firstFingerX = (e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft)) - bbox.left;
                const firstFingerY = (e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop)) - bbox.top;
                const secondFingerX = (e.touches[1].clientX || (e.touches[1].pageX - parent.lowerCanvas.offsetLeft)) - bbox.left;
                const secondFingerY = (e.touches[1].clientY || (e.touches[1].pageY - parent.lowerCanvas.offsetTop)) - bbox.top;
                const center = { x: firstFingerX < secondFingerX ? secondFingerX - ((secondFingerX - firstFingerX) / 2) :
                        firstFingerX - ((firstFingerX - secondFingerX) / 2), y: firstFingerY < secondFingerY ?
                        secondFingerY - ((secondFingerY - firstFingerY) / 2) : firstFingerY - ((firstFingerY - secondFingerY) / 2) };
                if (this.currMousePoint.x !== center.x && this.currMousePoint.y !== center.y) {
                    let type = '';
                    if (e.type === 'touchmove' && (parent.zoomSettings.zoomTrigger & ZoomTrigger.Pinch) === ZoomTrigger.Pinch) {
                        this.zoomType = 'Pinch';
                        const scale = this.calculateScale(this.startTouches, this.targetTouches(e.touches));
                        this.startTouches = this.targetTouches(e.touches);
                        if (scale > 1) {
                            type = 'zoomIn';
                        }
                        else if (scale < 1) {
                            type = 'zoomOut';
                        }
                    }
                    if (type !== '') {
                        parent.notify('draw', { prop: 'performPointZoom', onPropertyChange: false,
                            value: { x: center.x, y: center.y, type: type } });
                    }
                    this.tempTouches = [];
                    this.tempTouches.push({ x: e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft),
                        y: e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop) });
                    this.tempTouches.push({ x: e.touches[1].clientX || (e.touches[1].pageX - parent.lowerCanvas.offsetLeft),
                        y: e.touches[1].clientY || (e.touches[1].pageY - parent.lowerCanvas.offsetTop) });
                    this.currMousePoint.x = center.x;
                    this.currMousePoint.y = center.y;
                }
            }
            this.isFirstMove = false;
            return;
        }
        let x;
        let y;
        if (e.type === 'mousemove') {
            x = e.clientX;
            y = e.clientY;
        }
        else {
            this.touchEndPoint.x = x = e.touches[0].clientX;
            this.touchEndPoint.y = y = e.touches[0].clientY;
        }
        x -= bbox.left;
        y -= bbox.top;
        this.canvasMouseMoveHandler(e);
        let isCropSelection = false;
        let splitWords;
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (splitWords !== undefined && splitWords[0] === 'crop') {
            isCropSelection = true;
        }
        if (isCropSelection) {
            parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
        }
        parent.upperCanvas.style.cursor = canvasCursor;
        parent.cursor = cursor;
        if (parent.currObjType.isActiveObj && (parent.activeObj.activePoint !== undefined || parent.objColl.length > 0) &&
            !this.dragCanvas || parent.activeObj.activePoint !== undefined) {
            if (this.dragElement === '') {
                this.setCursor(x, y);
                if ((parent.activeObj.activePoint &&
                    (parent.activeObj.activePoint.width === 0 || (!isNullOrUndefined(parent.activeObj.currIndex) &&
                        this.cursorTargetId !== parent.activeObj.currIndex)))
                    && parent.cursor !== 'default' &&
                    parent.cursor !== 'move' && parent.cursor !== 'crosshair'
                    && parent.cursor !== 'grab' && parent.cursor !== 'pointer') {
                    parent.upperCanvas.style.cursor = parent.cursor = 'move';
                }
                this.findTarget(x, y, e.type);
            }
        }
        if (parent.currObjType.isDragging) {
            this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            this.updateActivePoint(x, y, isCropSelection);
            parent.notify('shape', { prop: 'updateTrianglePoints', onPropertyChange: false, value: { obj: parent.activeObj } });
            if (this.isPreventDragging) {
                if ((parent.activeObj.activePoint.startX > parent.img.destLeft) &&
                    (parent.activeObj.activePoint.endX < parent.img.destLeft + parent.img.destWidth) &&
                    (parent.activeObj.activePoint.startY > parent.img.destTop)
                    && (parent.activeObj.activePoint.endY < parent.img.destTop + parent.img.destHeight)) {
                    this.isPreventDragging = false;
                }
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,
                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
            }
            else {
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,
                        points: null, isPreventDrag: null, saveContext: null, isPreventSelection: null } });
            }
            if (isCropSelection) {
                this.dragCanvas = parent.togglePan = true;
            }
        }
    }
    mouseUpEventHandler(e) {
        const parent = this.parent;
        if (e.type === 'touchstart') {
            this.isTouch = false;
        }
        else if (e.type === 'touchend') {
            e.stopImmediatePropagation();
        }
        e.preventDefault();
        if (parent.togglePan) {
            this.canvasMouseUpHandler(e);
        }
        let x;
        let y;
        if (e.type === 'mouseup') {
            x = e.clientX;
            y = e.clientY;
        }
        else {
            x = this.touchEndPoint.x;
            y = this.touchEndPoint.y;
        }
        const bbox = parent.lowerCanvas.getBoundingClientRect();
        x -= bbox.left;
        y -= bbox.top;
        if (e.type === 'touchend') {
            this.startTouches = this.tempTouches = [];
            this.isFirstMove = false;
            if (parent.textArea.style.display === 'none') {
                this.timer = 0;
            }
        }
        let isCropSelection = false;
        let splitWords;
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (splitWords !== undefined && splitWords[0] === 'crop') {
            isCropSelection = true;
        }
        if (isBlazor() && this.parent.eventType) {
            if (this.parent.eventType === 'pan') {
                if (parent.events && parent.events.onPanEnd.hasDelegate === true) {
                    parent.dotNetRef.invokeMethodAsync('PanEventAsync', 'OnPanEnd', this.parent.panEventArgs);
                }
            }
            else if (this.parent.eventType === 'resize') {
                if (!this.isCropSelection && this.parent.events && this.parent.events.onShapeResizeEnd.hasDelegate === true) {
                    this.shapeResizingArgs.currentShapeSettings = this.updatePrevShapeSettings();
                    this.shapeResizingArgs.action = this.currentDrawingShape !== '' ? 'drawing' : 'resize-end';
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    this.parent.dotNetRef.invokeMethodAsync('ShapeEventAsync', 'OnShapeResizeEnd', this.shapeResizingArgs).then((shapeResizingArgs) => {
                        this.parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,
                            value: { shapeSettings: shapeResizingArgs.currentShapeSettings } });
                    });
                }
                else if (this.shapeResizingArgs && this.selectionResizingArgs && this.parent.events &&
                    this.parent.events.onSelectionResizeEnd.hasDelegate === true) {
                    const currentSelectionSettings = { type: this.parent.activeObj.shape,
                        startX: this.shapeResizingArgs.currentShapeSettings.startX,
                        startY: this.shapeResizingArgs.currentShapeSettings.startY,
                        width: this.shapeResizingArgs.currentShapeSettings.width,
                        height: this.shapeResizingArgs.currentShapeSettings.height };
                    this.selectionResizingArgs.currentSelectionSettings = currentSelectionSettings;
                    this.selectionResizingArgs.action = 'resize-end';
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    this.parent.dotNetRef.invokeMethodAsync('SelectionEventAsync', 'OnSelectionResizeEnd', this.selectionResizingArgs).then((selectionResizingArgs) => {
                        this.parent.notify('shape', { prop: 'updateSelectionChangeEventArgs', onPropertyChange: false,
                            value: { selectionSettings: selectionResizingArgs.currentSelectionSettings } });
                    });
                }
            }
            else {
                if (this.shapeMovingArgs && this.parent.events && this.parent.events.onShapeDragEnd.hasDelegate === true) {
                    this.shapeMovingArgs.currentShapeSettings = this.updatePrevShapeSettings();
                    this.shapeMovingArgs.action = 'drag-end';
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    this.parent.dotNetRef.invokeMethodAsync('ShapeEventAsync', 'OnShapeDragEnd', this.shapeMovingArgs).then((shapeMovingArgs) => {
                        this.parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,
                            value: { shapeSettings: shapeMovingArgs.currentShapeSettings } });
                    });
                }
            }
            this.shapeResizingArgs = null;
            this.shapeMovingArgs = null;
            this.parent.panEventArgs = null;
            this.parent.eventType = null;
        }
        if (this.currentDrawingShape === 'path') {
            return;
        }
        if (e.currentTarget === parent.upperCanvas) {
            this.pathAdjustedIndex = null;
            if (this.currentDrawingShape !== '') {
                if (this.currentDrawingShape === 'text') {
                    const prevCropObj = extend({}, parent.cropObj, {}, true);
                    parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                        value: { operation: 'shapeTransform', previousObj: this.initialPrevObj, previousObjColl: this.initialPrevObj.objColl,
                            previousPointColl: this.initialPrevObj.pointColl, previousSelPointColl: this.initialPrevObj.selPointColl,
                            previousCropObj: prevCropObj, previousText: null,
                            currentText: null, previousFilter: null, isCircleCrop: null } });
                }
                else {
                    parent.notify('undo-redo', { prop: 'updateUrObj', onPropertyChange: false, value: { objColl: this.initialPrevObj.objColl } });
                }
                this.isShapeInserted = true;
                this.currentDrawingShape = '';
                if (parent.activeObj.activePoint.width === 0 && parent.activeObj.activePoint.height === 0) {
                    parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });
                }
            }
            this.adjustActObjForLineArrow();
            this.updPtCollForShpRot();
            parent.currObjType.shape = parent.currObjType.shape.toLowerCase();
            const prevCropObj = extend({}, parent.cropObj, {}, true);
            const object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            const prevObj = object['currObj'];
            prevObj.objColl = extend([], parent.objColl, [], true);
            prevObj.pointColl = extend([], parent.pointColl, [], true);
            prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
            const selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            if (!parent.togglePen && !isCropSelection) {
                if (this.tempObjColl && parent.activeObj.activePoint.width !== 0) {
                    parent.objColl.push(parent.activeObj);
                    if (JSON.stringify(parent.activeObj.activePoint) !== JSON.stringify(this.tempActiveObj.activePoint)) {
                        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                            value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: this.tempObjColl,
                                previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                                previousCropObj: prevCropObj, previousText: null,
                                currentText: null, previousFilter: null, isCircleCrop: null } });
                    }
                    this.redrawShape(parent.objColl[parent.objColl.length - 1], true);
                    this.tempObjColl = undefined;
                }
                if (!this.isFhdEditing) {
                    this.applyCurrActObj(x, y);
                    parent.currObjType.isResize = false;
                    if (!isBlazor()) {
                        parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
                    }
                }
            }
            if (parent.activeObj) {
                let isCropSelection = false;
                let splitWords;
                if (parent.activeObj.shape !== undefined) {
                    splitWords = parent.activeObj.shape.split('-');
                }
                if (splitWords === undefined && (parent.currObjType.isCustomCrop || parent.togglePen)) {
                    isCropSelection = true;
                }
                else if (splitWords !== undefined && splitWords[0] === 'crop') {
                    isCropSelection = true;
                }
                if (!isBlazor()) {
                    if ((parent.activeObj.shape === 'rectangle') || (parent.activeObj.shape === 'ellipse')
                        || (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'path')) {
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    else if (parent.activeObj.shape === 'text') {
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    else if (this.isFhdEditing) {
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'pen',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    else if (!isCropSelection) {
                        const eventargs = { type: 'main', isApplyBtn: null, isCropping: false, isZooming: null };
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: eventargs });
                    }
                    parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
                }
                else {
                    if ((parent.activeObj.shape === 'rectangle') || (parent.activeObj.shape === 'ellipse')
                        || (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'path')) {
                        parent.updateToolbar(parent.element, parent.activeObj.shape);
                    }
                    else if (parent.activeObj.shape === 'text') {
                        parent.updateToolbar(parent.element, 'text');
                    }
                }
            }
        }
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (splitWords !== undefined && splitWords[0] === 'crop') {
            isCropSelection = true;
        }
        if (parent.activeObj.shape && !isCropSelection && e.currentTarget === parent.upperCanvas &&
            parent.textArea.style.display === 'none') {
            if (parent.activeObj.shape === 'text') {
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',
                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                }
            }
            else {
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                }
            }
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
                parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
            }
            else {
                parent.updateToolbar(parent.element, 'quickAccessToolbar', parent.activeObj.shape);
            }
        }
        if (parent.togglePen && e.currentTarget === parent.upperCanvas) {
            parent.notify('freehand-draw', { prop: 'freehandUpHandler', onPropertyChange: false,
                value: { e: e, canvas: parent.upperCanvas, context: this.upperContext } });
        }
        else {
            parent.currObjType.shape = '';
        }
        this.dragElement = '';
        parent.currObjType.isInitialLine = parent.currObjType.isDragging = false;
        this.selMouseUpEvent();
    }
    adjustActObjForLineArrow(obj) {
        let isAdjusted = false;
        const parent = this.parent;
        obj = obj ? obj : parent.activeObj;
        if (obj.shape && (obj.shape === 'line' || parent.activeObj.shape === 'arrow')) {
            let temp;
            if ((this.dragElement === 'e-resize' && obj.activePoint.endX < obj.activePoint.startX) ||
                (this.dragElement === 'w-resize' && obj.activePoint.startX > obj.activePoint.endX)) {
                isAdjusted = true;
                temp = obj.activePoint.startX;
                obj.activePoint.startX = obj.activePoint.endX;
                obj.activePoint.endX = temp;
                temp = obj.activePoint.startY;
                obj.activePoint.startY = obj.activePoint.endY;
                obj.activePoint.endY = temp;
            }
            obj.activePoint.width = Math.abs(obj.activePoint.endX - obj.activePoint.startX);
            obj.activePoint.height = Math.abs(obj.activePoint.endY - obj.activePoint.startY);
            if (parent.activeObj.shape !== 'path') {
                parent.notify('shape', { prop: 'setPointCollForLineArrow', onPropertyChange: false,
                    value: { obj: obj } });
                // Updating ratio for point collection
                for (let i = 0; i < obj.pointColl.length; i++) {
                    obj.pointColl[i].ratioX = (obj.pointColl[i].x -
                        parent.img.destLeft) / parent.img.destWidth;
                    obj.pointColl[i].ratioY = (obj.pointColl[i].y -
                        parent.img.destTop) / parent.img.destHeight;
                }
            }
        }
        return isAdjusted;
    }
    updPtCollForShpRot(obj) {
        const parent = this.parent;
        obj = obj ? obj : parent.activeObj;
        if (obj.shape && obj.rotatedAngle !== 0) {
            parent.notify('shape', { prop: 'setPointCollForShapeRotation', onPropertyChange: false,
                value: { obj: obj } });
            // Updating ratio for point collection
            for (let i = 0; i < obj.horTopLinePointColl.length; i++) {
                obj.horTopLinePointColl[i].ratioX = (obj.horTopLinePointColl[i].x -
                    parent.img.destLeft) / parent.img.destWidth;
                obj.horTopLinePointColl[i].ratioY = (obj.horTopLinePointColl[i].y -
                    parent.img.destTop) / parent.img.destHeight;
            }
            for (let i = 0; i < obj.horBottomLinePointColl.length; i++) {
                obj.horBottomLinePointColl[i].ratioX = (obj.horBottomLinePointColl[i].x -
                    parent.img.destLeft) / parent.img.destWidth;
                obj.horBottomLinePointColl[i].ratioY = (obj.horBottomLinePointColl[i].y -
                    parent.img.destTop) / parent.img.destHeight;
            }
            for (let i = 0; i < obj.verLeftLinePointColl.length; i++) {
                obj.verLeftLinePointColl[i].ratioX = (obj.verLeftLinePointColl[i].x -
                    parent.img.destLeft) / parent.img.destWidth;
                obj.verLeftLinePointColl[i].ratioY = (obj.verLeftLinePointColl[i].y -
                    parent.img.destTop) / parent.img.destHeight;
            }
            for (let i = 0; i < obj.verRightLinePointColl.length; i++) {
                obj.verRightLinePointColl[i].ratioX = (obj.verRightLinePointColl[i].x -
                    parent.img.destLeft) / parent.img.destWidth;
                obj.verRightLinePointColl[i].ratioY = (obj.verRightLinePointColl[i].y -
                    parent.img.destTop) / parent.img.destHeight;
            }
        }
    }
    setXYPoints(e) {
        e.preventDefault();
        let x;
        let y;
        if (e.type === 'mousedown') {
            x = e.clientX;
            y = e.clientY;
        }
        else {
            this.touchEndPoint.x = x = e.touches[0].clientX;
            this.touchEndPoint.y = y = e.touches[0].clientY;
        }
        const bbox = this.parent.lowerCanvas.getBoundingClientRect();
        x -= bbox.left;
        y -= bbox.top;
        return { x: x, y: y };
    }
    getCurrentIndex() {
        let index;
        const parent = this.parent;
        for (let i = 0; i < parent.objColl.length; i++) {
            if (parent.activeObj.currIndex === parent.objColl[i].currIndex) {
                index = i;
                break;
            }
        }
        return index;
    }
    isShapeClick(e, isCropSelection) {
        const parent = this.parent;
        let isShape = false;
        if (parent.togglePen) {
            return isShape;
        }
        if (parent.activeObj.shape && parent.activeObj.shape === 'text' && this.isShapeInserted) {
            const isTextArea = parent.textArea.style.display === 'block' ? true : false;
            const activeObj = extend({}, parent.activeObj, null, true);
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: true } });
            const points = this.setXYPoints(e);
            const x = points.x;
            const y = points.y;
            isShape = this.findTargetObj(x, y, isCropSelection);
            if (!isCropSelection) {
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }
            if (isTextArea) {
                parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;
                parent.textArea.style.display = 'block';
                parent.activeObj = activeObj;
                const index = this.getCurrentIndex();
                if (isNullOrUndefined(index)) {
                    parent.objColl.pop();
                }
                else {
                    parent.objColl.splice(index, 1);
                }
            }
            else if (!isShape && activeObj.shape) {
                parent.activeObj = activeObj;
                const index = this.getCurrentIndex();
                if ((!isNullOrUndefined(index) &&
                    JSON.stringify(parent.activeObj.activePoint) === JSON.stringify(parent.objColl[index].activePoint))) {
                    parent.objColl.splice(index, 1);
                }
                else if (isNullOrUndefined(parent.activeObj.currIndex)) {
                    parent.objColl.pop();
                }
            }
        }
        return isShape;
    }
    isShapeTouch(e, isCropSelection) {
        const parent = this.parent;
        let isShape = false;
        if (e.type === 'touchstart' && !parent.togglePen) {
            if (parent.activeObj && parent.activeObj.shape === 'text') {
                this.timer = setTimeout(this.setTimer.bind(this), 1000, e);
            }
            const isTextArea = parent.textArea.style.display === 'block' ? true : false;
            const activeObj = extend({}, parent.activeObj, null, true);
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: true } });
            const points = this.setXYPoints(e);
            const x = points.x;
            const y = points.y;
            isShape = this.findTargetObj(x, y, isCropSelection);
            if (!isCropSelection) {
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            }
            if (isTextArea) {
                parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;
                parent.textArea.style.display = 'block';
                parent.activeObj = activeObj;
                const index = this.getCurrentIndex();
                if (isNullOrUndefined(index)) {
                    parent.objColl.pop();
                }
                else {
                    parent.objColl.splice(index, 1);
                }
            }
            else if (!isShape && activeObj.shape) {
                parent.activeObj = activeObj;
                const index = this.getCurrentIndex();
                if (!isCropSelection) {
                    if ((!isNullOrUndefined(index) && JSON.stringify(parent.activeObj.activePoint) ===
                        JSON.stringify(parent.objColl[index].activePoint))) {
                        parent.objColl.splice(index, 1);
                    }
                    else if (isNullOrUndefined(parent.activeObj.currIndex)) {
                        parent.objColl.pop();
                    }
                }
            }
            // this.timer = null;
        }
        return isShape;
    }
    isFreehandDrawTouch(e, isCropSelection) {
        const parent = this.parent;
        let isFreehandDraw = false;
        if (e.type === 'touchstart' && !isCropSelection && !parent.togglePen) {
            const isTextArea = parent.textArea.style.display === 'block' ? true : false;
            const activeObj = extend({}, parent.activeObj, null, true);
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: true } });
            const points = this.setXYPoints(e);
            const x = points.x;
            const y = points.y;
            this.setCursor(x, y);
            if (this.isFhdPoint) {
                isFreehandDraw = true;
            }
            if (isTextArea) {
                parent.textArea.value = parent.objColl[parent.objColl.length - 1].keyHistory;
                parent.textArea.style.display = 'block';
                parent.activeObj = activeObj;
                const index = this.getCurrentIndex();
                if (isNullOrUndefined(index)) {
                    parent.objColl.pop();
                }
                else {
                    parent.objColl.splice(index, 1);
                }
            }
            else if (activeObj.shape) {
                parent.activeObj = activeObj;
                const index = this.getCurrentIndex();
                if (!isCropSelection) {
                    if ((!isNullOrUndefined(index) && JSON.stringify(parent.activeObj.activePoint) ===
                        JSON.stringify(parent.objColl[index].activePoint))) {
                        parent.objColl.splice(index, 1);
                    }
                    else if (isNullOrUndefined(parent.activeObj.currIndex)) {
                        parent.objColl.pop();
                    }
                }
            }
        }
        return isFreehandDraw;
    }
    applyObj(x, y) {
        const parent = this.parent;
        let isApply = false;
        if (parent.activeObj.shape && (parent.activeObj.shape === 'rectangle' || parent.activeObj.shape === 'ellipse' ||
            parent.activeObj.shape === 'text' || parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' ||
            parent.activeObj.shape === 'path')) {
            if (x >= (parent.activeObj.activePoint.startX - (parent.activeObj.topLeftCircle.radius * 2)) &&
                x <= (parent.activeObj.activePoint.endX + (parent.activeObj.topLeftCircle.radius * 2)) &&
                y >= (parent.activeObj.activePoint.startY - (parent.activeObj.topLeftCircle.radius * 2)) &&
                y <= (parent.activeObj.activePoint.endY + (parent.activeObj.topLeftCircle.radius * 2))) {
                isApply = false;
            }
            else if (parent.upperCanvas.style.cursor !== 'default' && parent.upperCanvas.style.cursor !== 'grab' &&
                parent.upperCanvas.style.cursor !== 'crosshair' && parent.upperCanvas.style.cursor !== 'pointer' &&
                parent.upperCanvas.style.cursor !== 'move') {
                isApply = false;
            }
            else {
                isApply = true;
            }
        }
        return isApply;
    }
    applyCurrShape(isShapeClick) {
        const parent = this.parent;
        let isApply = false;
        if (parent.togglePen) {
            return isApply;
        }
        let obj = extend({}, parent.activeObj, null, true);
        if (this.isShapeInserted && parent.activeObj.shape === 'text' && isShapeClick) {
            this.isInitialTextEdited = true;
            parent.notify('draw', { prop: 'setShapeTextInsert', onPropertyChange: false, value: { bool: true } });
        }
        if (parent.textArea.style.display === 'block') {
            const activeObj = extend({}, parent.activeObj, null, true);
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: null } });
            obj = extend({}, parent.objColl[parent.objColl.length - 1], null, true);
            parent.objColl.pop();
            parent.activeObj = extend({}, activeObj, null, true);
            parent.textArea.value = obj.keyHistory;
            parent.textArea.style.display = 'block';
            let strokeColor = obj.strokeSettings && obj.strokeSettings.strokeColor ? obj.strokeSettings.strokeColor.split('(')[0] === 'rgb' ?
                this.rgbToHex(parseFloat(obj.strokeSettings.strokeColor.split('(')[1].split(',')[0]), parseFloat(obj.strokeSettings.strokeColor.split('(')[1].split(',')[1]), parseFloat(obj.strokeSettings.strokeColor.split('(')[1].split(',')[2])) :
                obj.strokeSettings.strokeColor : null;
            if (strokeColor && strokeColor === '#ffffff') {
                strokeColor = '#fff';
            }
            if (this.tempActiveObj.strokeSettings && this.tempActiveObj.strokeSettings.strokeColor &&
                this.tempActiveObj.strokeSettings.strokeColor === '#ffffff') {
                this.tempActiveObj.strokeSettings.strokeColor = '#fff';
            }
            if (obj.keyHistory !== this.tempActiveObj.keyHistory ||
                (strokeColor && (strokeColor !== this.tempActiveObj.strokeSettings.strokeColor)) ||
                obj.textSettings.fontFamily !== this.tempActiveObj.textSettings.fontFamily ||
                Math.round(obj.textSettings.fontSize) !== Math.round(this.tempActiveObj.textSettings.fontSize) ||
                Math.round(obj.textSettings.fontRatio) !== Math.round(this.tempActiveObj.textSettings.fontRatio) ||
                obj.textSettings.bold !== this.tempActiveObj.textSettings.bold ||
                obj.textSettings.italic !== this.tempActiveObj.textSettings.italic ||
                obj.textSettings.underline !== this.tempActiveObj.textSettings.underline) {
                isApply = true;
            }
            if (this.isInitialTextEdited && !isApply) {
                isApply = true;
                this.isInitialTextEdited = false;
            }
        }
        else {
            this.tempActiveObj.activePoint.height = Math.abs(this.tempActiveObj.activePoint.height);
            isApply = JSON.stringify(obj) !== JSON.stringify(this.tempActiveObj);
        }
        return isApply;
    }
    canvasMouseDownHandler(e) {
        const parent = this.parent;
        e.preventDefault();
        let x;
        let y;
        if (e.type === 'mousedown') {
            x = e.offsetX || (e.pageX - parent.lowerCanvas.offsetLeft);
            y = e.offsetY || (e.pageY - parent.lowerCanvas.offsetTop);
        }
        else {
            x = e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft);
            y = e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop);
        }
        const bbox = parent.lowerCanvas.getBoundingClientRect();
        x -= bbox.left;
        y -= bbox.top;
        this.panDown = { x: x, y: y };
        const tempPanMoveObj = { tempPanMove: null };
        parent.notify('transform', { prop: 'getTempPanMove', onPropertyChange: false,
            value: { obj: tempPanMoveObj } });
        if (isNullOrUndefined(tempPanMoveObj['tempPanMove'])) {
            parent.notify('transform', { prop: 'setTempPanMove', onPropertyChange: false,
                value: { point: { x: x, y: y } } });
        }
    }
    canvasMouseMoveHandler(e) {
        const parent = this.parent;
        if (this.dragCanvas) {
            parent.lowerCanvas.style.cursor = 'grab';
        }
        else {
            this.dragCanvas = parent.togglePan = false;
            parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = 'default';
        }
        let x;
        let y;
        if (e.type === 'mousemove') {
            x = e.offsetX;
            y = e.offsetY;
        }
        else {
            x = e.touches[0].clientX || (e.touches[0].pageX - parent.lowerCanvas.offsetLeft);
            y = e.touches[0].clientY || (e.touches[0].pageY - parent.lowerCanvas.offsetTop);
        }
        const bbox = parent.lowerCanvas.getBoundingClientRect();
        x -= bbox.left;
        y -= bbox.top;
        const panMove = { x: x, y: y };
        parent.notify('transform', { prop: 'setPanMove', onPropertyChange: false,
            value: { point: { x: x, y: y } } });
        if (this.panDown && panMove && parent.togglePan && this.dragCanvas) {
            parent.notify('transform', { prop: 'drawPannedImage', onPropertyChange: false,
                value: { xDiff: null, yDiff: null } });
        }
    }
    canvasMouseUpHandler(e) {
        const parent = this.parent;
        e.preventDefault();
        const panMoveObj = { panMove: null };
        parent.notify('transform', { prop: 'getPanMove', onPropertyChange: false,
            value: { obj: panMoveObj } });
        if (parent.togglePan) {
            if (this.panDown && panMoveObj['panMove'] && parent.togglePan && this.dragCanvas) {
                this.panDown = null;
                parent.notify('transform', { prop: 'setPanMove', onPropertyChange: false,
                    value: { point: null } });
                parent.notify('transform', { prop: 'setTempPanMove', onPropertyChange: false,
                    value: { point: null } });
            }
        }
        if (this.currentDrawingShape !== 'path') {
            parent.currObjType.isDragging = false;
        }
    }
    touchStartHandler(e) {
        e.preventDefault();
        if (this.touchTime === 0) {
            this.touchTime = new Date().getTime();
        }
        else {
            if (((new Date().getTime()) - this.touchTime) < 400) {
                this.parent.notify('shape', { prop: 'stopPathDrawing', onPropertyChange: false, value: { e: e } });
                this.touchTime = 0;
            }
            else {
                this.touchTime = new Date().getTime();
            }
        }
        if (e.touches.length === 2) {
            this.isFirstMove = true;
        }
        else {
            this.mouseDownEventHandler(e);
        }
        EventHandler.add(this.parent.lowerCanvas, 'touchend', this.mouseUpEventHandler, this);
        EventHandler.add(this.parent.lowerCanvas, 'touchmove', this.mouseMoveEventHandler, this);
        EventHandler.add(this.parent.upperCanvas, 'touchend', this.mouseUpEventHandler, this);
        EventHandler.add(this.parent.upperCanvas, 'touchmove', this.mouseMoveEventHandler, this);
    }
    unwireEvent() {
        EventHandler.remove(this.parent.lowerCanvas, 'touchend', this.mouseUpEventHandler);
        EventHandler.remove(this.parent.lowerCanvas, 'touchmove', this.mouseMoveEventHandler);
        EventHandler.remove(this.parent.upperCanvas, 'touchend', this.mouseUpEventHandler);
        EventHandler.remove(this.parent.upperCanvas, 'touchmove', this.mouseMoveEventHandler);
    }
    keyDownEventHandler(e) {
        const parent = this.parent;
        if (e.ctrlKey && (e.key === '+' || e.key === '-')) {
            e.preventDefault();
        }
        const obj = { fileName: '', fileType: null };
        parent.notify('draw', { prop: 'getFileName', onPropertyChange: false, value: { obj: obj } });
        const beforeSave = { fileName: obj['fileName'], fileType: obj['fileType'], cancel: false };
        let splitWords;
        switch (e.key) {
            case (e.ctrlKey && 's'):
                if (isBlazor() && parent.events && parent.events.saving.hasDelegate === true) {
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    parent.dotNetRef.invokeMethodAsync('BeforeSaveEventAsync', 'BeforeSave', beforeSave).then((args) => {
                        this.beforeSaveEvent(args, e);
                    });
                }
                else {
                    parent.trigger('beforeSave', beforeSave);
                    this.beforeSaveEvent(beforeSave, e);
                }
                break;
            case (e.ctrlKey && 'z'):
                if (parent.allowUndoRedo) {
                    parent.notify('undo-redo', { prop: 'call-undo' });
                }
                break;
            case (e.ctrlKey && 'y'):
                if (parent.allowUndoRedo) {
                    parent.notify('undo-redo', { prop: 'call-redo' });
                }
                break;
            case (e.ctrlKey && '+'):
                if ((parent.zoomSettings.zoomTrigger & ZoomTrigger.Commands) === ZoomTrigger.Commands) {
                    this.zoomType = 'Commands';
                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                        value: { zoomFactor: .1, zoomPoint: null } });
                }
                break;
            case (e.ctrlKey && '-'):
                if ((parent.zoomSettings.zoomTrigger & ZoomTrigger.Commands) === ZoomTrigger.Commands) {
                    this.zoomType = 'Commands';
                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                        value: { zoomFactor: -.1, zoomPoint: null } });
                }
                break;
            case 'Delete':
                this.deleteItem();
                break;
            case 'Escape':
                parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });
                break;
            case 'Enter':
                if (parent.activeObj.shape) {
                    splitWords = parent.activeObj.shape.split('-');
                }
                if (this.isKeyBoardCrop(e) &&
                    parent.activeObj.horTopLine && (parent.activeObj.shape && splitWords[0] === 'crop')) {
                    parent.crop();
                }
                break;
            case 'Tab':
                this.performTabAction();
                break;
            default:
                if (Browser.isDevice && parent.textArea.style.display === 'block') {
                    setTimeout(this.textKeyDown.bind(this), 1, e);
                }
                break;
        }
    }
    isKeyBoardCrop(e) {
        let bool = false;
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const target = e.target;
        if ((target.id === this.parent.element.id + '_ok' || target.id === '') && !isBlazor()) {
            bool = true;
        }
        return bool;
    }
    beforeSaveEvent(observableSaveArgs, e) {
        const parent = this.parent;
        if (!observableSaveArgs.cancel) {
            parent.notify('export', { prop: 'export', onPropertyChange: false,
                value: { type: observableSaveArgs.fileType, fileName: observableSaveArgs.fileName } });
        }
        e.preventDefault();
        e.stopImmediatePropagation();
    }
    handleScroll(e) {
        const parent = this.parent;
        let x;
        let y;
        let isInsideCanvas = false;
        if (e.type === 'mousewheel') {
            // eslint-disable-next-line
            x = e.clientX;
            y = e.clientY;
        }
        const bbox = parent.lowerCanvas.getBoundingClientRect();
        x -= bbox.left;
        y -= bbox.top;
        if (x > parent.img.destLeft && x < parent.img.destLeft + parent.img.destWidth && y > parent.img.destTop &&
            y < parent.img.destTop + parent.img.destHeight) {
            isInsideCanvas = true;
        }
        e.stopPropagation();
        if (e.ctrlKey === true && isInsideCanvas) {
            e.preventDefault();
            if (!parent.isCropTab && (parent.activeObj.shape && parent.activeObj.shape.split('-')[0] !== 'crop')) {
                parent.okBtn();
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'close-contextual-toolbar', onPropertyChange: false });
                }
            }
            let type = '';
            if (e.type === 'mousewheel' && (parent.zoomSettings.zoomTrigger & ZoomTrigger.MouseWheel) === ZoomTrigger.MouseWheel) {
                this.zoomType = 'MouseWheel';
                // eslint-disable-next-line
                if (e.wheelDelta > 0) {
                    type = 'zoomIn';
                }
                else {
                    type = 'zoomOut';
                }
            }
            if (type !== '') {
                parent.notify('draw', { prop: 'performPointZoom', onPropertyChange: false,
                    value: { x: x, y: y, type: type } });
            }
        }
    }
    textKeyDown(e) {
        const parent = this.parent;
        if (String.fromCharCode(e.which) === '\r') {
            this.textRow += 1;
        }
        parent.textArea.setAttribute('rows', this.textRow.toString());
        parent.textArea.style.height = 'auto';
        parent.textArea.style.height = parent.textArea.scrollHeight + 'px';
        parent.notify('shape', { prop: 'setTextBoxWidth', onPropertyChange: false, value: { e: e } });
        if (Browser.isDevice) {
            parent.textArea.style.width = parseFloat(parent.textArea.style.width) + parent.textArea.style.fontSize + 'px';
        }
        const rows = parent.textArea.value.split('\n');
        this.textRow = rows.length;
        parent.textArea.setAttribute('rows', this.textRow.toString());
        this.isInitialTextEdited = false;
    }
    clearSelection() {
        const parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            parent.togglePen = false;
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.dragElement = '';
            this.dragPoint.startX = this.dragPoint.startY = this.dragPoint.endX = this.dragPoint.endY = 0;
            parent.currObjType.shape = '';
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.currObjType.isActiveObj = true;
            parent.currObjType.isCustomCrop = false;
            parent.upperCanvas.style.cursor = parent.cursor = 'default';
        }
    }
    setDragDirection(width, height) {
        const arcRadius = (7.5);
        const parent = this.parent;
        if (parent.img.destWidth > parent.img.destHeight) {
            parent.activeObj.activePoint.startX = this.dragPoint.startX = ((width / 2) - (height / 2))
                + arcRadius;
            parent.activeObj.activePoint.startY = this.dragPoint.startY = ((height / 2) - (height / 2))
                + arcRadius;
            parent.activeObj.activePoint.endX = ((width / 2) + (height / 2)) - arcRadius;
            parent.activeObj.activePoint.endY = ((height / 2) + (height / 2)) - arcRadius;
        }
        else {
            parent.activeObj.activePoint.startY = this.dragPoint.startX = ((height / 2) - (width) / 2)
                + arcRadius;
            parent.activeObj.activePoint.endY = ((height / 2) + (width) / 2) - arcRadius;
            parent.activeObj.activePoint.startX = this.dragPoint.startX = arcRadius;
            parent.activeObj.activePoint.endX = width - arcRadius;
        }
    }
    calcShapeRatio(x, y, imgWidth, imgHeight) {
        const parent = this.parent;
        const arcRadius = (7.5);
        const originalWidth = imgWidth;
        const originalHeight = imgHeight;
        const presetRatio = x / y;
        const standardSize = originalWidth >= originalHeight ? originalWidth : originalHeight;
        let width = standardSize * presetRatio;
        let height = standardSize;
        const scaleWidth = this.getScale(width, originalWidth);
        const snippetArray = [];
        for (let i = 0; i < 2; i++) {
            if (i === 0) {
                snippetArray.push(width * scaleWidth);
            }
            else {
                snippetArray.push(height * scaleWidth);
            }
        }
        width = snippetArray[0];
        height = snippetArray[1];
        const scaleHeight = this.getScale(height, originalHeight);
        const snippetArray1 = [];
        for (let i = 0; i < 2; i++) {
            if (i === 0) {
                snippetArray1.push(width * scaleHeight);
            }
            else {
                snippetArray1.push(height * scaleHeight);
            }
        }
        width = snippetArray1[0];
        height = snippetArray1[1];
        parent.activeObj.activePoint.width = width;
        parent.activeObj.activePoint.height = height;
        parent.activeObj.activePoint.startX = (this.dragPoint.startX = (originalWidth - width) / 2) + arcRadius;
        parent.activeObj.activePoint.startY = (this.dragPoint.startY = (originalHeight - height) / 2) + arcRadius;
        parent.activeObj.activePoint.endX = ((originalWidth - width) / 2 + width) - arcRadius;
        parent.activeObj.activePoint.endY = ((originalHeight - height) / 2 + height) - arcRadius;
        if (parent.activeObj.activePoint.startX < parent.img.destLeft && parent.img.destLeft + parent.img.destWidth >
            parent.lowerCanvas.clientWidth) {
            parent.activeObj.activePoint.startX = parent.img.destLeft;
            parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + width - arcRadius;
        }
        if (parent.activeObj.activePoint.startY < parent.img.destTop && parent.img.destTop + parent.img.destHeight >
            parent.lowerCanvas.clientHeight) {
            parent.activeObj.activePoint.startY = parent.img.destTop;
            parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + height - arcRadius;
        }
        parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
        parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
    }
    getScale(value, originalValue) {
        return value > originalValue ? originalValue / value : 1;
    }
    findTarget(x, y, type) {
        const parent = this.parent;
        if (type.toLowerCase() === 'mousedown' || type.toLowerCase() === 'touchstart') {
            let splitWords;
            let isCrop = false;
            if (parent.activeObj.shape) {
                splitWords = parent.activeObj.shape.split('-');
                if (splitWords[0] === 'crop') {
                    isCrop = true;
                }
            }
            this.findTargetObj(x, y, isCrop);
            this.updateCursorStyles(x, y, type);
        }
        else {
            switch (this.dragElement.toLowerCase()) {
                case 'nw-resize':
                    parent.activeObj.topLeftCircle.startX = x;
                    parent.activeObj.topLeftCircle.startY = y;
                    break;
                case 'n-resize':
                    parent.activeObj.topCenterCircle.startX = x;
                    parent.activeObj.topCenterCircle.startY = y;
                    break;
                case 'ne-resize':
                    parent.activeObj.topRightCircle.startX = x;
                    parent.activeObj.topRightCircle.startY = y;
                    break;
                case 'w-resize':
                    parent.activeObj.centerLeftCircle.startX = x;
                    parent.activeObj.centerLeftCircle.startY = y;
                    break;
                case 'e-resize':
                    parent.activeObj.centerRightCircle.startX = x;
                    parent.activeObj.centerRightCircle.startY = y;
                    break;
                case 'sw-resize':
                    parent.activeObj.bottomLeftCircle.startX = x;
                    parent.activeObj.bottomLeftCircle.startY = y;
                    break;
                case 's-resize':
                    parent.activeObj.bottomCenterCircle.startX = x;
                    parent.activeObj.bottomCenterCircle.startY = y;
                    break;
                case 'se-resize':
                    parent.activeObj.bottomRightCircle.startX = x;
                    parent.activeObj.bottomRightCircle.startY = y;
                    break;
                default:
                    if (this.dragPoint.startX && this.dragPoint.startY) {
                        this.previousPoint.x = this.dragPoint.endX;
                        this.previousPoint.y = this.dragPoint.endY;
                        this.dragPoint.endX = x;
                        this.dragPoint.endY = y;
                    }
                    break;
            }
        }
    }
    findTargetObj(x, y, isCrop) {
        const parent = this.parent;
        let isShape = false;
        if (parent.objColl.length !== 0 && !parent.currObjType.isCustomCrop && !isCrop) {
            let diffX = 0;
            let i;
            for (let index = 0; index < parent.objColl.length; index++) {
                const cursor = parent.upperCanvas.style.cursor;
                this.setCursor(x, y);
                const actObj = extend({}, parent.objColl[index], {}, true);
                if (actObj.shape === 'line' || actObj.shape === 'arrow') {
                    for (let j = 0; j < actObj.pointColl.length; j++) {
                        if (x >= actObj.pointColl[j].x - (actObj.topLeftCircle.radius * 2) &&
                            x <= actObj.pointColl[j].x + (actObj.topLeftCircle.radius * 2) &&
                            y >= actObj.pointColl[j].y - (actObj.topLeftCircle.radius * 2) &&
                            y <= actObj.pointColl[j].y + (actObj.topLeftCircle.radius * 2)) {
                            if (this.isTouch || parent.cursor === 'move' ||
                                parent.cursor === 'grab' || this.isShapeInserted) {
                                if (diffX === 0 || diffX > x - actObj.activePoint.startX) {
                                    diffX = x - parent.objColl[index].activePoint.startX;
                                    i = index;
                                }
                            }
                            else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                                i = index;
                            }
                            break;
                        }
                    }
                }
                else if (actObj.shape === 'path') {
                    const cursor = this.setCursorForPath(actObj, x, y, parent.upperCanvas);
                    if (cursor !== 'default' && cursor !== 'grab') {
                        if (this.isTouch || parent.cursor === 'move' || parent.cursor === 'grab' || this.isShapeInserted) {
                            if (diffX === 0 || diffX > x - actObj.activePoint.startX) {
                                diffX = x - parent.objColl[index].activePoint.startX;
                                i = index;
                            }
                        }
                        else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                            i = index;
                        }
                    }
                }
                else if (actObj.rotatedAngle !== 0) {
                    const cursor = this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
                    if (cursor !== 'default' && cursor !== 'grab') {
                        if (this.isTouch || parent.cursor === 'move' || parent.cursor === 'grab' || this.isShapeInserted) {
                            if (diffX === 0 || diffX > x - actObj.activePoint.startX) {
                                diffX = x - parent.objColl[index].activePoint.startX;
                                i = index;
                            }
                        }
                        else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                            i = index;
                        }
                    }
                }
                else {
                    const rotationCirclePoint = this.getTransRotationPoint(actObj);
                    if ((x >= (actObj.activePoint.startX - (actObj.topLeftCircle.radius * 2)) &&
                        x <= (actObj.activePoint.endX + (actObj.topLeftCircle.radius * 2)) &&
                        y >= (actObj.activePoint.startY - (actObj.topLeftCircle.radius * 2)) &&
                        y <= (actObj.activePoint.endY + (actObj.topLeftCircle.radius * 2))) ||
                        (rotationCirclePoint &&
                            x >= (rotationCirclePoint.x - (actObj.topLeftCircle.radius * 2)) &&
                            x <= (rotationCirclePoint.x + (actObj.topLeftCircle.radius * 2)) &&
                            y >= (rotationCirclePoint.y - (actObj.topLeftCircle.radius * 2)) &&
                            y <= (rotationCirclePoint.y + (actObj.topLeftCircle.radius * 2)))) {
                        if (this.isTouch || cursor === 'move' || cursor === 'grabbing' || this.isShapeInserted
                            || parent.cursor === 'move' || parent.cursor === 'grabbing') {
                            if (diffX === 0 || diffX > x - actObj.activePoint.startX) {
                                diffX = x - parent.objColl[index].activePoint.startX;
                                i = index;
                            }
                        }
                        else if (parent.objColl[index].currIndex === this.tempActiveObj.currIndex) {
                            i = index;
                        }
                    }
                }
            }
            if (isNullOrUndefined(i)) {
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                isShape = false;
            }
            else {
                this.tempObjColl = extend([], parent.objColl, [], true);
                parent.currObjType.isCustomCrop = false;
                parent.activeObj = extend({}, parent.objColl[i], {}, true);
                const temp = extend({}, parent.objColl[i], {}, true);
                parent.objColl.splice(i, 1);
                if (parent.transform.degree === 0) {
                    const temp = this.lowerContext.filter;
                    this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
                    parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
                    this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
                    this.lowerContext.filter = 'none';
                    parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
                    parent.activeObj = extend({}, temp, {}, true);
                    parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                        value: { context: this.lowerContext, points: null } });
                    this.lowerContext.filter = temp;
                    this.getCurrentFlipState();
                }
                else {
                    parent.notify('draw', { prop: 'callUpdateCurrTransState', onPropertyChange: false });
                    parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                        value: { context: this.lowerContext, points: null } });
                }
                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
                if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                        value: { context: this.lowerContext, isSave: null, isFlip: null } });
                }
                this.setActivePoint();
                parent.activeObj = extend({}, temp, {}, true);
                const tempStrokeSettings = extend({}, parent.activeObj.strokeSettings, {}, true);
                parent.notify('draw', { prop: 'setTempStrokeSettings', onPropertyChange: false,
                    value: { tempStrokeSettings: tempStrokeSettings } });
                const tempTextSettings = extend({}, parent.activeObj.textSettings, {}, true);
                parent.notify('draw', { prop: 'setTempTextSettings', onPropertyChange: false, value: { tempTextSettings: tempTextSettings } });
                const shapeSettings = this.updatePrevShapeSettings();
                const shapeChangingArgs = { action: 'select', previousShapeSettings: shapeSettings,
                    currentShapeSettings: shapeSettings };
                if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow') {
                    shapeChangingArgs.currentShapeSettings.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
                    shapeChangingArgs.currentShapeSettings.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
                }
                this.isCropSelection = false;
                let splitWords;
                if (parent.activeObj.shape !== undefined) {
                    splitWords = parent.activeObj.shape.split('-');
                }
                if (splitWords !== undefined && splitWords[0] === 'crop') {
                    this.isCropSelection = true;
                }
                if (!this.isCropSelection && isBlazor() && isNullOrUndefined(this.parent.eventType) &&
                    parent.events && parent.events.shapeChanging.hasDelegate === true) {
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    parent.dotNetRef.invokeMethodAsync('ShapeEventAsync', 'OnShape', shapeChangingArgs).then((shapeChangingArgs) => {
                        this.shapeEvent(shapeChangingArgs);
                    });
                }
                else if (!this.isCropSelection) {
                    parent.trigger('shapeChanging', shapeChangingArgs);
                    this.shapeEvent(shapeChangingArgs);
                }
                else {
                    const selectionChangingArgs = { action: shapeChangingArgs.action,
                        previousSelectionSettings: { type: parent.getSelectionType(parent.activeObj.shape),
                            startX: shapeChangingArgs.previousShapeSettings.startX,
                            startY: shapeChangingArgs.previousShapeSettings.startY,
                            width: shapeChangingArgs.previousShapeSettings.width,
                            height: shapeChangingArgs.previousShapeSettings.height },
                        currentSelectionSettings: { type: parent.getSelectionType(parent.activeObj.shape),
                            startX: shapeChangingArgs.currentShapeSettings.startX,
                            startY: shapeChangingArgs.currentShapeSettings.startY,
                            width: shapeChangingArgs.currentShapeSettings.width,
                            height: shapeChangingArgs.currentShapeSettings.height } };
                    if (isBlazor() && parent.events && parent.events.onSelectionResizeStart.hasDelegate === true) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        parent.dotNetRef.invokeMethodAsync('SelectionEventAsync', 'OnSelectionResizeStart', selectionChangingArgs).then((selectionChangingArgs) => {
                            shapeChangingArgs.currentShapeSettings.startX = selectionChangingArgs.currentSelectionSettings.startX;
                            shapeChangingArgs.currentShapeSettings.startY = selectionChangingArgs.currentSelectionSettings.startY;
                            shapeChangingArgs.currentShapeSettings.width = selectionChangingArgs.currentSelectionSettings.width;
                            shapeChangingArgs.currentShapeSettings.height = selectionChangingArgs.currentSelectionSettings.height;
                            this.shapeEvent(shapeChangingArgs);
                        });
                    }
                    else {
                        parent.trigger('selectionChanging', selectionChangingArgs);
                        shapeChangingArgs.currentShapeSettings.startX = selectionChangingArgs.currentSelectionSettings.startX;
                        shapeChangingArgs.currentShapeSettings.startY = selectionChangingArgs.currentSelectionSettings.startY;
                        shapeChangingArgs.currentShapeSettings.width = selectionChangingArgs.currentSelectionSettings.width;
                        shapeChangingArgs.currentShapeSettings.height = selectionChangingArgs.currentSelectionSettings.height;
                        this.shapeEvent(shapeChangingArgs);
                    }
                }
                isShape = true;
            }
        }
        return isShape;
    }
    shapeEvent(shapeChangingArgs) {
        const parent = this.parent;
        parent.notify('shape', { prop: 'updateShapeChangeEventArgs', onPropertyChange: false,
            value: { shapeSettings: shapeChangingArgs.currentShapeSettings } });
        if (parent.activeObj.activePoint) {
            const obj = { prevActObj: null };
            parent.notify('draw', { prop: 'getPrevActObj', onPropertyChange: false, value: { obj: obj } });
            if (isNullOrUndefined(obj['prevActObj'])) {
                parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false,
                    value: { prevActObj: extend({}, parent.activeObj, {}, true) } });
            }
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,
                    points: null, isPreventDrag: true, saveContext: null, isPreventSelection: true } });
            if (!this.isShapeInserted) {
                if (parent.activeObj.activePoint.startX < parent.img.destLeft) {
                    this.isPreventDragging = true;
                }
                else if (parent.activeObj.activePoint.endX > parent.img.destLeft + parent.img.destWidth) {
                    this.isPreventDragging = true;
                }
                else if (parent.activeObj.activePoint.startY < parent.img.destTop) {
                    this.isPreventDragging = true;
                }
                else if (parent.activeObj.activePoint.endY > parent.img.destTop + parent.img.destHeight) {
                    this.isPreventDragging = true;
                }
            }
        }
    }
    // eslint-disable-next-line
    targetTouches(touches) {
        const bbox = this.parent.lowerCanvas.getBoundingClientRect();
        const p1 = { x: touches[0].pageX - bbox.left, y: touches[0].pageY - bbox.top };
        const p2 = { x: touches[1].pageX - bbox.left, y: touches[1].pageY - bbox.top };
        const points = [p1, p2];
        return points;
    }
    calculateScale(startTouches, endTouches) {
        const startDistance = this.getDistance(startTouches[0], startTouches[1]);
        const endDistance = this.getDistance(endTouches[0], endTouches[1]);
        return endDistance / startDistance;
    }
    getDistance(a, b) {
        let x = 0;
        let y = 0;
        if (a && b) {
            x = a.x - b.x;
            y = a.y - b.y;
        }
        return Math.sqrt(x * x + y * y);
    }
    redrawShape(obj, isMouseUp) {
        const parent = this.parent;
        for (let i = 0, len = parent.objColl.length; i < len; i++) {
            if (JSON.stringify(obj) === JSON.stringify(parent.objColl[i])) {
                parent.objColl.splice(i, 1);
                break;
            }
        }
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (this.isPreventDragging) {
            if (parent.activeObj.activePoint.startX > parent.img.destLeft) {
                this.isPreventDragging = false;
            }
            if (isMouseUp && parent.activeObj.rotatedAngle !== 0) {
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,
                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
            }
            else {
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,
                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
            }
        }
        else {
            if (isMouseUp && parent.activeObj.rotatedAngle !== 0) {
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,
                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
            }
            else {
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: null, isCropRatio: null,
                        points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
            }
        }
    }
    setTimer(e) {
        if (this.timer > 10) {
            clearTimeout(this.timer);
            this.timer = 0;
            this.parent.notify('shape', { prop: 'findTextTarget', onPropertyChange: false, value: { e: e } });
            if (Browser.isDevice) {
                this.upperContext.clearRect(0, 0, this.parent.upperCanvas.width, this.parent.upperCanvas.height);
            }
        }
    }
    applyCurrActObj(x, y) {
        const parent = this.parent;
        let isInside = false;
        const actObj = extend({}, parent.activeObj, {}, true);
        if (isNullOrUndefined(actObj.activePoint)) {
            return;
        }
        const radius = actObj.topLeftCircle ? actObj.topLeftCircle.radius : 0;
        if ((x >= Math.floor(actObj.activePoint.startX) &&
            x <= Math.ceil(actObj.activePoint.endX) &&
            y >= Math.floor(actObj.activePoint.startY) &&
            y <= Math.ceil(actObj.activePoint.endY))) {
            isInside = true;
        }
        else if (radius !== 0 && (x >= Math.floor(actObj.activePoint.startX) - radius &&
            x <= Math.ceil(actObj.activePoint.endX) + radius &&
            y >= Math.floor(actObj.activePoint.startY) - radius &&
            y <= Math.ceil(actObj.activePoint.endY) + radius)) {
            isInside = true;
            this.tempActiveObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
                flipObjColl: [], triangle: [], triangleRatio: [] };
        }
        else if (actObj.shape === 'text' && this.dragElement !== '') {
            isInside = true;
        }
        else if (actObj.shape === 'line' || actObj.shape === 'arrow') {
            const smallPoint = { x: actObj.activePoint.startX < actObj.activePoint.endX ? actObj.activePoint.startX :
                    actObj.activePoint.endX,
                y: actObj.activePoint.startY < actObj.activePoint.endY ? actObj.activePoint.startY : actObj.activePoint.endY };
            const largePoint = { x: actObj.activePoint.startX > actObj.activePoint.endX ? actObj.activePoint.startX :
                    actObj.activePoint.endX,
                y: actObj.activePoint.startY > actObj.activePoint.endY ? actObj.activePoint.startY : actObj.activePoint.endY };
            if (x >= (Math.floor(smallPoint.x) - 5) && x <= (Math.ceil(largePoint.x) + 5) &&
                y >= (Math.floor(smallPoint.y) - 5) && y <= (Math.ceil(largePoint.y) + 5)) {
                isInside = true;
            }
        }
        else if (actObj.shape === 'path') {
            const cursor = this.setCursorForPath(actObj, x, y, parent.upperCanvas);
            if (cursor === 'move') {
                isInside = true;
            }
        }
        else if (this.dragElement === 'grabbing') {
            isInside = true;
        }
        else if (actObj.rotatedAngle !== 0) {
            const cursor = this.setCursorForRotatedObject(actObj, x, y, parent.upperCanvas);
            if ((cursor !== 'default' && cursor !== 'grab') || this.dragElement === 'n-resize' || this.dragElement === 'e-resize' ||
                this.dragElement === 's-resize' || this.dragElement === 'w-resize') {
                isInside = true;
            }
        }
        if (!isInside) {
            if (isNullOrUndefined(parent.activeObj.currIndex)) {
                parent.activeObj.currIndex = 'shape_' + (parent.objColl.length + 1);
            }
            parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
            if (parent.activeObj.horTopLine !== undefined && parent.activeObj.horTopLine.startX !== 0 && parent.activeObj.horTopLine.endX
                !== 0 && !parent.currObjType.isCustomCrop && parent.currObjType.shape !== '') {
                parent.objColl.push(extend({}, parent.activeObj, {}, true));
            }
            if (parent.activeObj.shape === 'text' || (parent.currObjType.shape === 'ellipse' || parent.currObjType.shape === 'rectangle' ||
                parent.currObjType.shape === 'line' || parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'path')) {
                const tempFilter = this.lowerContext.filter;
                this.lowerContext.filter = 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
                    'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' +
                    'invert(0%)';
                for (let i = 0; i < parent.objColl.length; i++) {
                    const obj = { isInside: false };
                    parent.notify('crop', { prop: 'isObjInImage', onPropertyChange: false,
                        value: { obj: parent.objColl[i], object: obj } });
                    if (obj['isInside']) {
                        parent.notify('shape', { prop: 'apply', onPropertyChange: false,
                            value: { shape: parent.objColl[i].shape, obj: parent.objColl[i], canvas: null } });
                        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                    }
                }
                parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
                this.lowerContext.filter = tempFilter;
                if (parent.activeObj.shape) {
                    parent.notify('shape', { prop: 'apply', onPropertyChange: false,
                        value: { shape: null, obj: null, canvas: null } });
                }
                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
                parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
                if (parent.isCircleCrop) {
                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                        value: { context: this.lowerContext, isSave: null, isFlip: null } });
                }
            }
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            }
        }
    }
    getCurrentFlipState() {
        const parent = this.parent;
        if (parent.rotateFlipColl.length !== 0) {
            const totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, {}, true);
            parent.notify('draw', { prop: 'callUpdateCurrTransState', onPropertyChange: false });
            parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
        }
        else {
            parent.notify('draw', { prop: 'callUpdateCurrTransState', onPropertyChange: false });
        }
    }
    setTextBoxStylesToActObj() {
        const parent = this.parent;
        parent.activeObj.textSettings.fontFamily = parent.textArea.style.fontFamily;
        parent.activeObj.strokeSettings.strokeColor = parent.textArea.style.color !== '' &&
            parent.textArea.style.color.split('(')[1] && parent.textArea.style.color.split('(')[1].split(',')[0] &&
            parent.textArea.style.color.split('(')[1].split(',')[1] && parent.textArea.style.color.split('(')[1].split(',')[2] ?
            this.rgbToHex(parseFloat(parent.textArea.style.color.split('(')[1].split(',')[0]), parseFloat(parent.textArea.style.color.split('(')[1].split(',')[1]), parseFloat(parent.textArea.style.color.split('(')[1].split(',')[2])) :
            parent.textArea.style.color;
        if (parent.textArea.style.fontWeight === 'bold') {
            parent.activeObj.textSettings.bold = true;
        }
        else {
            parent.activeObj.textSettings.bold = false;
        }
        if (parent.textArea.style.fontStyle === 'italic') {
            parent.activeObj.textSettings.italic = true;
        }
        else {
            parent.activeObj.textSettings.italic = false;
        }
        parent.activeObj.textSettings.fontSize = (parseFloat(parent.textArea.style.fontSize));
    }
    rgbToHex(r, g, b) {
        return '#' + this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);
    }
    componentToHex(rgb) {
        const hex = rgb.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }
    deleteItem() {
        const parent = this.parent;
        let shapeChangingArgs = {};
        let previousShapeSettings = {};
        if (this.isFhdEditing) {
            this.updateFreehandDrawColorChange();
            const prevCropObj = extend({}, parent.cropObj, {}, true);
            const object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            const prevObj = object['currObj'];
            prevObj.objColl = extend([], parent.objColl, [], true);
            prevObj.pointColl = extend([], parent.pointColl, [], true);
            prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
            const selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            const obj = { freehandDrawSelectedId: null };
            parent.notify('freehand-draw', { prop: 'getFreehandDrawSelectedId', onPropertyChange: false, value: { obj: obj } });
            parent.notify('freehand-draw', { prop: 'deleteFhd', value: { id: obj['freehandDrawSelectedId'] } });
            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'deleteFreehandDrawing', previousObj: prevObj, previousObjColl: this.tempObjColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            parent.notify('freehand-draw', { prop: 'resetFreehandDrawSelectedId' });
        }
        else if (parent.textArea.style.display === 'none') {
            const obj = { prevActObj: null };
            parent.notify('draw', { prop: 'getPrevActObj', onPropertyChange: false, value: { obj: obj } });
            if (obj['prevActObj']) {
                obj['prevActObj']['activePoint']['width'] = Math.abs(obj['prevActObj']['activePoint']['width']);
                obj['prevActObj']['activePoint']['height'] = Math.abs(obj['prevActObj']['activePoint']['height']);
            }
            if (obj['prevActObj'] && JSON.stringify(obj['prevActObj']) !== JSON.stringify(parent.activeObj)) {
                const index = parent.activeObj.currIndex;
                parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });
                for (let i = 0; i < parent.objColl.length; i++) {
                    if (parent.objColl[i].currIndex === index) {
                        parent.objColl.splice(i, 1);
                        parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
                        break;
                    }
                }
            }
            const object = { isNewPath: null };
            parent.notify('draw', { prop: 'getNewPath', value: { obj: object } });
            if (object['isNewPath']) {
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                parent.notify('draw', { prop: 'render-image', value: { isMouseWheel: null } });
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
                }
                else {
                    parent.updateToolbar(parent.element, 'imageLoaded');
                }
            }
            else if (parent.activeObj.shape) {
                parent.objColl.push(parent.activeObj);
                const prevCropObj = extend({}, parent.cropObj, {}, true);
                const object = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                const prevObj = object['currObj'];
                prevObj.objColl = extend([], parent.objColl, [], true);
                prevObj.pointColl = extend([], parent.pointColl, [], true);
                prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
                const selPointCollObj = { selPointColl: null };
                parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                    value: { obj: selPointCollObj } });
                prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
                parent.objColl.pop();
                previousShapeSettings = this.updatePrevShapeSettings();
                shapeChangingArgs = { action: 'delete', previousShapeSettings: previousShapeSettings, currentShapeSettings: null };
                parent.notify('shape', { prop: 'setKeyHistory', onPropertyChange: false, value: { keyHistory: '' } });
                parent.clearSelection();
                if (isBlazor() && parent.events && parent.events.shapeChanging.hasDelegate === true) {
                    parent.dotNetRef.invokeMethodAsync('ShapeEventAsync', 'OnShape', shapeChangingArgs);
                }
                else {
                    parent.trigger('shapeChanging', shapeChangingArgs);
                    if (!isBlazor()) {
                        parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
                    }
                }
                if (!isNullOrUndefined(prevObj.objColl[prevObj.objColl.length - 1].currIndex)) {
                    parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                        value: { operation: 'deleteObj', previousObj: prevObj, previousObjColl: this.tempObjColl,
                            previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                            previousCropObj: prevCropObj, previousText: null,
                            currentText: null, previousFilter: null, isCircleCrop: null } });
                    parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                }
            }
            parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });
        }
        if (document.getElementById(parent.element.id + '_quickAccessToolbarArea')) {
            document.getElementById(parent.element.id + '_quickAccessToolbarArea').style.display = 'none';
        }
    }
    updateFreehandDrawColorChange() {
        const parent = this.parent;
        const indexObj = { freehandSelectedIndex: null };
        parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
        if (!isNullOrUndefined(indexObj['freehandSelectedIndex']) && !isNullOrUndefined(parent.pointColl[indexObj['freehandSelectedIndex']])
            && parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor === '#42a5f5') {
            const obj = { tempFreeHandDrawEditingStyles: null };
            parent.notify('freehand-draw', { prop: 'getTempFreeHandDrawEditingStyles', value: { obj: obj } });
            parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor = obj['tempFreeHandDrawEditingStyles'].strokeColor;
        }
    }
    updatePrevShapeSettings(obj) {
        const parent = this.parent;
        const fontStyle = [];
        if (parent.activeObj.shape === 'text' && parent.activeObj.textSettings) {
            if (parent.activeObj.textSettings.bold) {
                fontStyle.push('bold');
            }
            if (parent.activeObj.textSettings.italic) {
                fontStyle.push('italic');
            }
            if (parent.activeObj.textSettings.underline) {
                fontStyle.push('underline');
            }
        }
        const shapeSettingsObj = {
            id: !isNullOrUndefined(parent.activeObj.currIndex) ? parent.activeObj.currIndex : null,
            type: parent.toPascalCase(parent.activeObj.shape),
            startX: parent.activeObj.activePoint.startX, startY: parent.activeObj.activePoint.startY,
            width: parent.activeObj.activePoint.width, height: parent.activeObj.activePoint.height,
            strokeColor: parent.activeObj.strokeSettings ? parent.activeObj.strokeSettings.strokeColor : null,
            strokeWidth: parent.activeObj.strokeSettings ? parent.activeObj.strokeSettings.strokeWidth : null,
            fillColor: parent.activeObj.strokeSettings ? parent.activeObj.strokeSettings.fillColor : null,
            radius: parent.activeObj.shape === 'ellipse' ? parent.activeObj.activePoint.width / 2 : null,
            length: parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' ? parent.activeObj.activePoint.width : null,
            text: parent.activeObj.shape === 'text' ? (parent.activeObj.keyHistory ? parent.activeObj.keyHistory :
                (parent.activeObj.textSettings.text ? parent.activeObj.textSettings.text : null)) : null,
            fontSize: parent.activeObj.shape === 'text' ? (parent.activeObj.textSettings ? parent.activeObj.textSettings.fontSize : null) : null,
            fontFamily: parent.activeObj.shape === 'text' ? (parent.activeObj.textSettings ? parent.activeObj.textSettings.fontFamily : null) : null,
            fontStyle: parent.activeObj.shape === 'text' ? fontStyle : null,
            color: parent.activeObj.shape === 'text' ? (parent.activeObj.strokeSettings ? parent.activeObj.strokeSettings.strokeColor : null) : null
        };
        if (obj) {
            obj['shapeSettingsObj'] = shapeSettingsObj;
        }
        return shapeSettingsObj;
    }
    getRectanglePoints(rectX, rectY, rectWidth, rectHeight, rectAngle, pointX, pointY) {
        const centerX = rectX + rectWidth / 2;
        const centerY = rectY + rectHeight / 2;
        const angleRad = rectAngle * (Math.PI / 180);
        const cosAngle = Math.cos(angleRad);
        const sinAngle = Math.sin(angleRad);
        const localX = pointX - centerX;
        const localY = pointY - centerY;
        const rotatedX = localX * cosAngle + localY * sinAngle;
        const rotatedY = -localX * sinAngle + localY * cosAngle;
        const halfWidth = rectWidth / 2;
        const halfHeight = rectHeight / 2;
        // Check if the rotated point is within the bounds of the rectangle
        if (rotatedX >= -halfWidth && rotatedX <= halfWidth && rotatedY >= -halfHeight &&
            rotatedY <= halfHeight) {
            return true; // Point is inside the rotated rectangle
        }
        else {
            return false; // Point is outside the rotated rectangle
        }
    }
    getTransRotationPoint(obj, object) {
        let rotationCirclePoint;
        let degree;
        let isHorizontalflip = false;
        let isVerticalflip = false;
        if (obj.shapeDegree === 0) {
            degree = this.parent.transform.degree;
        }
        else {
            degree = this.parent.transform.degree - obj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        if (obj.flipObjColl) {
            for (let i = 0; i < obj.flipObjColl.length; i++) {
                if (obj.flipObjColl[i].toLowerCase() === 'horizontal') {
                    isHorizontalflip = true;
                }
                else if (obj.flipObjColl[i].toLowerCase() === 'vertical') {
                    isVerticalflip = true;
                }
            }
        }
        if (degree === 0 || degree === 360) {
            if (isVerticalflip) {
                rotationCirclePoint = { x: obj.topCenterCircle.startX,
                    y: obj.topCenterCircle.startY - obj.rotationCircleLine };
            }
            else {
                rotationCirclePoint = { x: obj.bottomCenterCircle.startX,
                    y: obj.bottomCenterCircle.startY + obj.rotationCircleLine };
            }
        }
        else if (degree === 90 || degree === -270) {
            if (isHorizontalflip) {
                rotationCirclePoint = { x: obj.centerRightCircle.startX +
                        obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
            }
            else {
                rotationCirclePoint = { x: obj.centerLeftCircle.startX -
                        obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
            }
        }
        else if (degree === 180 || degree === -180) {
            if (isVerticalflip) {
                rotationCirclePoint = { x: obj.bottomCenterCircle.startX,
                    y: obj.bottomCenterCircle.startY + obj.rotationCircleLine };
            }
            else {
                rotationCirclePoint = { x: obj.topCenterCircle.startX,
                    y: obj.topCenterCircle.startY - obj.rotationCircleLine };
            }
        }
        else if (degree === 270 || degree === -90) {
            if (isHorizontalflip) {
                rotationCirclePoint = { x: obj.centerLeftCircle.startX -
                        obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
            }
            else {
                rotationCirclePoint = { x: obj.centerRightCircle.startX +
                        obj.rotationCircleLine, y: obj.centerLeftCircle.startY };
            }
        }
        if (object) {
            object['rotationCirclePoint'] = rotationCirclePoint;
        }
        return rotationCirclePoint;
    }
}

class Shape {
    constructor(parent) {
        this.textSettings = { text: 'Enter Text', fontFamily: 'Arial', fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
        this.strokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null };
        this.keyHistory = ''; // text history
        this.parent = parent;
        this.addEventListener();
    }
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    }
    addEventListener() {
        this.parent.on('shape', this.shape, this);
        this.parent.on('destroyed', this.destroy, this);
    }
    removeEventListener() {
        this.parent.off('shape', this.shape);
        this.parent.off('destroyed', this.destroy);
    }
    shape(args) {
        this.initShapePvtProps();
        switch (args.prop) {
            case 'drawEllipse':
                this.drawEllipse(args.value['x'], args.value['y'], args.value['radiusX'], args.value['radiusY'], args.value['strokeWidth'], args.value['strokeColor'], args.value['fillColor']);
                break;
            case 'drawLine':
                this.drawLine(args.value['startX'], args.value['startY'], args.value['endX'], args.value['endY'], args.value['strokeWidth'], args.value['strokeColor']);
                break;
            case 'drawArrow':
                this.drawArrow(args.value['startX'], args.value['startY'], args.value['endX'], args.value['endY'], args.value['strokeWidth'], args.value['strokeColor'], args.value['arrowStart'], args.value['arrowEnd']);
                break;
            case 'drawPath':
                this.drawPath(args.value['pointColl'], args.value['strokeWidth'], args.value['strokeColor']);
                break;
            case 'drawRectangle':
                this.drawRectangle(args.value['x'], args.value['y'], args.value['width'], args.value['height'], args.value['strokeWidth'], args.value['strokeColor'], args.value['fillColor']);
                break;
            case 'drawText':
                this.drawText(args.value['x'], args.value['y'], args.value['text'], args.value['fontFamily'], args.value['fontSize'], args.value['bold'], args.value['italic'], args.value['color']);
                break;
            case 'redrawActObj':
                this.redrawActObj(args.value['x'], args.value['y'], args.value['isMouseDown']);
                break;
            case 'apply':
                this.apply(args.value['shape'], args.value['obj'], args.value['canvas']);
                break;
            case 'updateShapeChangeEventArgs':
                this.updateShapeChangeEventArgs(args.value['shapeSettings']);
                break;
            case 'updSelChangeEventArgs':
                this.updSelChangeEventArgs(args.value['selectionSettings']);
                break;
            case 'iterateObjColl':
                this.iterateObjColl();
                break;
            case 'updImgRatioForActObj':
                this.updImgRatioForActObj();
                break;
            case 'zoomObjColl':
                this.zoomObjColl(args.value['isPreventApply']);
                break;
            case 'redrawObj':
                this.redrawObj(args.value['degree']);
                break;
            case 'rotateObjColl':
                this.rotateObjColl();
                break;
            case 'draw-shape-text':
                this.drawShapeText();
                break;
            case 'redraw-text':
                this.redrawText();
                break;
            case 'draw-shape':
                this.drawShape(args.value['obj'], args.value['strokeWidth'], args.value['strokeColor'], args.value['fillColor'], args.value['start'], args.value['width'], args.value['height']);
                break;
            case 'renderTextArea':
                this.renderTextArea(args.value['x'], args.value['y'], args.value['actObj']);
                break;
            case 'setTextBoxWidth':
                this.setTextBoxWidth(args.value['e']);
                break;
            case 'findTextTarget':
                this.findTextTarget(args.value['e']);
                break;
            case 'panObjColl':
                this.panObjColl(args.value['xDiff'], args.value['yDiff'], args.value['panRegion']);
                break;
            case 'updateFontStyles':
                this.updateFontStyles(args.value['isTextBox']);
                break;
            case 'applyFontStyle':
                this.applyFontStyle(args.value['item']);
                break;
            case 'updateFontRatio':
                this.updateFontRatio(args.value['obj'], args.value['isTextArea']);
                break;
            case 'updateFontSize':
                this.updateFontSize(args.value['obj']);
                break;
            case 'updateObjColl':
                this.updateObjColl(args.value['item'], args.value['objColl']);
                break;
            case 'pushActItemIntoObj':
                this.pushActItemIntoObj();
                break;
            case 'clearActObj':
                this.clearActObj();
                break;
            case 'refreshActiveObj':
                this.refreshActiveObj();
                break;
            case 'applyActObj':
                this.applyActObj(args.value['isMouseDown']);
                break;
            case 'wireEvent':
                EventHandler.add(this.parent.upperCanvas, 'dblclick', this.findTextTarget, this);
                EventHandler.add(this.parent.textArea, 'mousedown', this.findTextTarget, this);
                break;
            case 'unWireEvent':
                EventHandler.remove(this.parent.upperCanvas, 'dblclick', this.findTextTarget);
                EventHandler.remove(this.parent.textArea, 'mousedown', this.findTextTarget);
                break;
            case 'getShapeSetting':
                this.getShapeSetting(args.value['id'], args.value['obj']);
                break;
            case 'getShapeSettings':
                this.getShapeSettings(args.value['obj']);
                break;
            case 'isPointsInRange':
                this.isPointsInRange(args.value['x'], args.value['y'], args.value['obj']);
                break;
            case 'alignRotateFlipColl':
                this.alignRotateFlipColl(args.value['collection'], args.value['isRotateFlipCollection'], args.value['obj']);
                break;
            case 'selectShape':
                this.selectShape(args.value['id'], args.value['obj']);
                break;
            case 'deleteShape':
                this.deleteShape(args.value['id']);
                break;
            case 'getMaxText':
                this.getMaxText(args.value['isTextBox'], args.value['text'], args.value['obj']);
                break;
            case 'setPointCollForLineArrow':
                args.value['obj'].pointColl = this.getLinePoints(args.value['obj'].activePoint.startX, args.value['obj'].activePoint.startY, args.value['obj'].activePoint.endX, args.value['obj'].activePoint.endY);
                break;
            case 'setPointCollForShapeRotation':
                this.setPointCollForShapeRotation(args.value['obj']);
                break;
            case 'setTextSettings':
                if (args.value['textSettings']) {
                    this.textSettings = args.value['textSettings'];
                }
                else if (args.value['fontFamily']) {
                    this.textSettings.fontFamily = args.value['fontFamily'];
                }
                else if (args.value['fontSize']) {
                    this.textSettings.fontSize = args.value['fontSize'];
                }
                break;
            case 'setStrokeSettings':
                if (args.value['strokeSettings']) {
                    this.strokeSettings = args.value['strokeSettings'];
                }
                else if (args.value['strokeColor']) {
                    this.strokeSettings.strokeColor = args.value['strokeColor'];
                }
                else if (args.value['fillColor']) {
                    this.strokeSettings.fillColor = args.value['fillColor'];
                }
                else if (args.value['strokeWidth']) {
                    this.strokeSettings.strokeWidth = args.value['strokeWidth'];
                }
                break;
            case 'getStrokeSettings':
                args.value['obj']['strokeSettings'] = this.strokeSettings;
                break;
            case 'setKeyHistory':
                this.keyHistory = args.value['keyHistory'];
                break;
            case 'getKeyHistory':
                args.value['obj']['keyHistory'] = this.keyHistory;
                break;
            case 'setTextBoxPos':
                this.setTextBoxPos(args.value['actObj'], args.value['degree'], args.value['flip'], args.value['x'], args.value['y']);
                break;
            case 'setTextBoxPoints':
                this.setTextBoxPoints(args.value['actObj'], args.value['degree'], args.value['flip'], args.value['x'], args.value['y']);
                break;
            case 'alignTextAreaIntoCanvas':
                this.alignTextAreaIntoCanvas();
                break;
            case 'initializeTextShape':
                this.initializeTextShape(args.value['text'], args.value['fontFamily'], args.value['fontSize'], args.value['bold'], args.value['italic'], args.value['strokeColor']);
                break;
            case 'stopPathDrawing':
                this.stopPathDrawing(args.value['e']);
                break;
            case 'updateArrowRatio':
                this.updateArrowRatio(args.value['obj']);
                break;
            case 'getSquarePointForRotatedShape':
                this.getSquarePointForRotatedShape(args.value['obj'], args.value['object']);
                break;
            case 'reset':
                this.reset();
                break;
        }
    }
    getModuleName() {
        return 'shape';
    }
    initShapePvtProps() {
        if (this.parent.lowerCanvas) {
            this.lowerContext = this.parent.lowerCanvas.getContext('2d');
        }
        if (this.parent.upperCanvas) {
            this.upperContext = this.parent.upperCanvas.getContext('2d');
        }
    }
    reset() {
        this.textSettings =
            { text: 'Enter Text', fontFamily: 'Arial', fontSize: null, fontRatio: null, bold: false, italic: false, underline: false };
        this.strokeSettings = { strokeColor: '#fff', fillColor: '', strokeWidth: null };
    }
    drawEllipse(x, y, radiusX, radiusY, strokeWidth, strokeColor, fillColor, degree) {
        this.initializeShape('ellipse');
        const start = x && y ? { x: x, y: y } : null;
        this.drawShape('ellipse', strokeWidth, strokeColor, fillColor, start, radiusX, radiusY, null, null, null, degree);
    }
    drawLine(startX, startY, endX, endY, strokeWidth, strokeColor) {
        this.initializeShape('line');
        const start = startX && startY ? { x: startX, y: startY } : null;
        const width = endX - startX;
        const height = endY - startY;
        this.drawShape('line', strokeWidth, strokeColor, null, start, width, height);
    }
    drawPath(pointColl, strokeWidth, strokeColor) {
        this.initializeShape('path');
        if (pointColl) {
            this.drawShape('path', strokeWidth, strokeColor, null, null, null, null, pointColl);
        }
        else {
            this.drawShape('line', strokeWidth, strokeColor, null, null, null, null);
            const obj = extend({}, this.parent.objColl[this.parent.objColl.length - 1], null, true);
            obj.shape = 'path';
            obj.lineDraw = null;
            obj.pointColl = [{ x: obj.activePoint.startX, y: obj.activePoint.startY },
                { x: obj.activePoint.endX, y: obj.activePoint.endY }];
            this.parent.objColl[this.parent.objColl.length - 1] = obj;
        }
    }
    drawArrow(startX, startY, endX, endY, strokeWidth, strokeColor, arrowStart, arrowEnd) {
        this.initializeShape('arrow');
        const start = startX && startY ? { x: startX, y: startY } : null;
        const width = endX - startX;
        const height = endY - startY;
        this.drawShape('arrow', strokeWidth, strokeColor, null, start, width, height, null, arrowStart, arrowEnd);
    }
    drawRectangle(x, y, width, height, strokeWidth, strokeColor, fillColor, degree) {
        this.initializeShape('rectangle');
        const start = x && y ? { x: x, y: y } : null;
        this.drawShape('rectangle', strokeWidth, strokeColor, fillColor, start, width, height, null, null, null, degree);
    }
    drawText(x, y, text, fontFamily, fontSize, bold, italic, color) {
        this.drawShapeText(text, fontFamily, fontSize, bold, italic, color, x, y);
    }
    initializeShape(type) {
        this.redrawActObj();
        this.parent.activeObj.shape = type;
        if (this.parent.currObjType.shape === 'freehanddraw') {
            this.apply();
            this.parent.upperCanvas.style.cursor = this.parent.cursor = 'default';
            this.parent.currObjType.shape = '';
        }
        this.parent.currObjType.isCustomCrop = false;
    }
    updateWidthHeight(obj) {
        obj.activePoint.width = obj.activePoint.endX - obj.activePoint.startX;
        obj.activePoint.height = obj.activePoint.endY - obj.activePoint.startY;
        return obj;
    }
    setDimension(width, height) {
        if (width && height) {
            this.parent.activeObj.activePoint.width = width;
            this.parent.activeObj.activePoint.height = height;
            if (this.parent.currObjType.shape.toLowerCase() === 'ellipse') {
                this.parent.activeObj.activePoint.width = 2 * width;
                this.parent.activeObj.activePoint.height = 2 * height;
            }
        }
    }
    getArrowType(type) {
        let arrowType = type;
        if (type) {
            const typeToArrowType = { 'None': 'none', 'Arrow': 'arrow', 'SolidArrow': 'arrowSolid',
                'Circle': 'circle', 'SolidCircle': 'circleSolid', 'Square': 'square', 'SolidSquare': 'squareSolid', 'Bar': 'bar' };
            arrowType = typeToArrowType[`${type}`];
        }
        return arrowType;
    }
    drawShape(type, strokeWidth, strokeColor, fillColor, start, width, height, pointColl, arrowStart, arrowEnd, degree) {
        const parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
            this.redrawActObj();
            const objColl = extend([], parent.objColl, [], true);
            parent.togglePen = false;
            this.keyHistory = '';
            this.parent.upperCanvas.style.display = 'block';
            this.refreshActiveObj();
            parent.currObjType.shape = type;
            if (parent.currObjType.shape.toLowerCase() === 'path' && isNullOrUndefined(pointColl)) {
                parent.activeObj.shape = parent.currObjType.shape.toLowerCase();
                parent.activeObj.pointColl = [];
                parent.upperCanvas.style.cursor = this.parent.cursor = 'crosshair';
                parent.notify('selection', { prop: 'setCurrentDrawingShape', onPropertyChange: false, value: { value: 'path' } });
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
                }
            }
            else {
                if (parent.currObjType.shape.toLowerCase() !== 'freehanddraw' && parent.currObjType.shape.toLowerCase() !== '') {
                    parent.activeObj.shape = parent.currObjType.shape.toLowerCase();
                    this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                    if (isNullOrUndefined(parent.activeObj.strokeSettings)) {
                        parent.activeObj.strokeSettings = this.strokeSettings;
                    }
                    if (parent.currObjType.shape.toLowerCase() === 'path' && pointColl) {
                        parent.activeObj.pointColl = pointColl;
                    }
                    parent.activeObj.strokeSettings.strokeWidth = strokeWidth ? strokeWidth : parent.activeObj.strokeSettings.strokeWidth;
                    parent.activeObj.strokeSettings.strokeColor = strokeColor ? strokeColor : parent.activeObj.strokeSettings.strokeColor;
                    parent.activeObj.strokeSettings.fillColor = fillColor ? fillColor : parent.activeObj.strokeSettings.fillColor;
                    const tempWidth = parent.img.destWidth > 100 ? 100 : parent.img.destWidth / 2;
                    const tempHeight = parent.img.destHeight > 100 ? 100 : parent.img.destHeight / 2;
                    parent.activeObj.activePoint.width = tempWidth;
                    parent.activeObj.activePoint.height = tempHeight;
                    if (parent.currObjType.shape.toLowerCase() === 'line' || parent.currObjType.shape.toLowerCase() === 'arrow') {
                        parent.activeObj.lineDraw = 'horizontal';
                        parent.activeObj.activePoint.height = 0;
                        if (parent.currObjType.shape.toLowerCase() === 'arrow') {
                            parent.activeObj.activePoint.width += 50;
                            parent.activeObj.start = this.getArrowType(arrowStart);
                            parent.activeObj.end = this.getArrowType(arrowEnd);
                        }
                    }
                    else if (parent.currObjType.shape.toLowerCase() === 'rectangle') {
                        parent.activeObj.activePoint.width += parent.activeObj.activePoint.width / 2;
                    }
                    this.setDimension(width, height);
                    if (start) {
                        parent.activeObj.activePoint.startX = start.x;
                        parent.activeObj.activePoint.startY = start.y;
                        parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX +
                            parent.activeObj.activePoint.width;
                        parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY +
                            parent.activeObj.activePoint.height;
                    }
                    else {
                        this.setCenterPoints();
                    }
                    this.setPointCollForLineAndArrow();
                    if (parent.currObjType.shape.toLowerCase() === 'arrow') {
                        parent.activeObj.triangleDirection = 'right';
                    }
                    parent.currObjType.isDragging = parent.currObjType.isCustomCrop = false;
                    this.initShapeProps();
                    const obj = { shapeSettingsObj: {} };
                    parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
                    const shapeSettings = obj['shapeSettingsObj'];
                    const shapeChangingArgs = { action: 'insert', previousShapeSettings: shapeSettings,
                        currentShapeSettings: shapeSettings };
                    if (isBlazor() && parent.events && parent.events.shapeChanging.hasDelegate === true) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        this.parent.dotNetRef.invokeMethodAsync('ShapeEventAsync', 'OnShape', shapeChangingArgs).then((shapeChangingArgs) => {
                            this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings);
                            this.setDimension(width, height);
                            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
                            if (degree) {
                                parent.activeObj.rotatedAngle = degree * (Math.PI / 180);
                                parent.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: parent.activeObj } });
                            }
                            parent.updateToolbar(parent.element, 'quickAccessToolbar', 'shape');
                            parent.notify('selection', { prop: 'isShapeInserted', onPropertyChange: false, value: { bool: true } });
                            parent.notify('undo-redo', { prop: 'updateUrObj', onPropertyChange: false, value: { objColl: objColl } });
                            if (parent.isPublicMethod) {
                                parent.notify('undo-redo', { prop: 'updateUndoRedo', onPropertyChange: false });
                            }
                            parent.isPublicMethod = false;
                        });
                    }
                    else {
                        parent.trigger('shapeChanging', shapeChangingArgs);
                        this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings);
                        this.setDimension(width, height);
                        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
                        if (degree) {
                            parent.activeObj.rotatedAngle = degree * (Math.PI / 180);
                            parent.notify('selection', { prop: 'updPtCollForShpRot', onPropertyChange: false, value: { obj: parent.activeObj } });
                        }
                        if (!isBlazor()) {
                            parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
                        }
                        else {
                            parent.updateToolbar(parent.element, 'quickAccessToolbar', 'shape');
                        }
                        parent.notify('selection', { prop: 'isShapeInserted', onPropertyChange: false, value: { bool: true } });
                        parent.notify('undo-redo', { prop: 'updateUrObj', onPropertyChange: false, value: { objColl: objColl } });
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                        parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
                        if (parent.isPublicMethod) {
                            parent.notify('undo-redo', { prop: 'updateUndoRedo', onPropertyChange: false });
                        }
                        parent.isPublicMethod = false;
                    }
                }
            }
        }
    }
    initShapeProps() {
        const parent = this.parent;
        parent.activeObj.shapeDegree = parent.transform.degree;
        parent.activeObj.shapeFlip = parent.transform.currFlipState;
        parent.activeObj.textFlip = parent.transform.currFlipState;
        parent.activeObj.flipObjColl = [];
    }
    setPointCollForLineAndArrow() {
        const parent = this.parent;
        if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow') {
            parent.activeObj.pointColl = this.getLinePoints(parent.activeObj.activePoint.startX, parent.activeObj.activePoint.startY, parent.activeObj.activePoint.endX, parent.activeObj.activePoint.endY);
            if (parent.activeObj.pointColl) {
                for (let i = 0, len = parent.activeObj.pointColl.length; i < len; i++) {
                    parent.activeObj.pointColl[i].ratioX = (parent.activeObj.pointColl[i].x -
                        parent.img.destLeft) / parent.img.destWidth;
                    parent.activeObj.pointColl[i].ratioY = (parent.activeObj.pointColl[i].y -
                        parent.img.destTop) / parent.img.destHeight;
                }
            }
        }
    }
    prevObjColl() {
        const parent = this.parent;
        const object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        this.prevObj = object['currObj'];
        this.prevObj.objColl = extend([], parent.objColl, [], true);
        this.prevObj.pointColl = extend([], parent.pointColl, [], true);
        this.prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        this.prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
    }
    drawShapeText(text, fontFamily, fontSize, bold, italic, strokeColor, x, y) {
        const parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            if (parent.currObjType.shape === 'freehanddraw') {
                this.apply();
                parent.upperCanvas.style.cursor = parent.cursor = 'default';
                parent.currObjType.shape = '';
            }
            parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
            parent.togglePen = false;
            this.redrawActObj();
            this.prevObjColl();
            this.refreshActiveObj();
            parent.activeObj.shape = parent.currObjType.shape = 'text';
            parent.currObjType.isCustomCrop = false;
            this.initializeTextShape(text, fontFamily, fontSize, bold, italic, strokeColor);
            parent.currObjType.isText = parent.currObjType.isInitialText = true;
            if (isNullOrUndefined(parent.activeObj.textSettings.fontSize)) {
                if (parent.img.destWidth > parent.img.destHeight) {
                    parent.activeObj.textSettings.fontSize = (parent.img.destWidth / 15);
                }
                else {
                    parent.activeObj.textSettings.fontSize = (parent.img.destHeight / 15);
                }
                if (parent.activeObj.textSettings.fontSize < 20) {
                    parent.activeObj.textSettings.fontSize = 20;
                }
            }
            if (parent.img.destWidth < 100) {
                parent.activeObj.textSettings.fontSize = Math.floor((parent.img.destWidth / 20));
            }
            else if (parent.img.destHeight < 100) {
                parent.activeObj.textSettings.fontSize = Math.floor((parent.img.destHeight / 20));
            }
            parent.activeObj.shapeDegree = parent.transform.degree;
            parent.activeObj.shapeFlip = parent.transform.currFlipState;
            parent.activeObj.flipObjColl = [];
            this.updateFontStyles();
            const width = this.upperContext.measureText(parent.activeObj.textSettings.text).width +
                parent.activeObj.textSettings.fontSize * 0.5;
            const height = parent.activeObj.textSettings.fontSize + parent.activeObj.textSettings.fontSize * 0.25;
            if (!isNullOrUndefined(x) && !isNullOrUndefined(y)) {
                parent.activeObj.activePoint.startX = x;
                parent.activeObj.activePoint.startY = y;
                parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + width;
                parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + height;
            }
            else {
                this.setCenterPoints(true, width, height);
            }
            const obj = { shapeSettingsObj: {} };
            parent.notify('selection', { prop: 'updatePrevShapeSettings', onPropertyChange: false, value: { obj: obj } });
            const shapeSettings = obj['shapeSettingsObj'];
            const shapeChangingArgs = { action: 'insert', previousShapeSettings: shapeSettings,
                currentShapeSettings: shapeSettings };
            if (isBlazor() && parent.events && parent.events.shapeChanging.hasDelegate === true) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                parent.dotNetRef.invokeMethodAsync('ShapeEventAsync', 'OnShape', shapeChangingArgs).then((shapeChangingArgs) => {
                    this.drawShapeTextEvent(shapeChangingArgs);
                    if (parent.isPublicMethod) {
                        parent.notify('undo-redo', { prop: 'updateUndoRedo', onPropertyChange: false });
                    }
                    parent.isPublicMethod = false;
                });
            }
            else {
                parent.trigger('shapeChanging', shapeChangingArgs);
                this.drawShapeTextEvent(shapeChangingArgs);
                if (parent.isPublicMethod) {
                    parent.notify('undo-redo', { prop: 'updateUndoRedo', onPropertyChange: false });
                }
                parent.isPublicMethod = false;
            }
        }
    }
    drawShapeTextEvent(shapeChangingArgs) {
        const parent = this.parent;
        this.updateShapeChangeEventArgs(shapeChangingArgs.currentShapeSettings);
        this.addLetter(parent.activeObj.textSettings.text);
        parent.activeObj.textFlip = parent.transform.currFlipState;
        this.updateFontRatio(parent.activeObj);
        parent.objColl.push(parent.activeObj);
        const prevCropObj = extend({}, parent.cropObj, {}, true);
        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
            value: { operation: 'shapeTransform', previousObj: this.prevObj, previousObjColl: this.prevObj.objColl,
                previousPointColl: this.prevObj.pointColl, previousSelPointColl: this.prevObj.selPointColl,
                previousCropObj: prevCropObj, previousText: null,
                currentText: null, previousFilter: null, isCircleCrop: null } });
        parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,
            value: { obj: parent.objColl[parent.objColl.length - 1] } });
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
        }
        else {
            parent.updateToolbar(parent.element, 'quickAccessToolbar', 'text');
        }
        parent.notify('selection', { prop: 'isShapeInserted', onPropertyChange: false, value: { bool: true } });
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',
                    isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
            parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
        }
        else {
            parent.updateToolbar(parent.element, 'text');
        }
    }
    initializeTextShape(text, fontFamily, fontSize, bold, italic, strokeColor) {
        const parent = this.parent;
        this.keyHistory = '';
        parent.upperCanvas.style.display = 'block';
        if (isNullOrUndefined(parent.activeObj.textSettings)) {
            parent.activeObj.textSettings = this.textSettings;
        }
        if (isNullOrUndefined(parent.activeObj.strokeSettings)) {
            parent.activeObj.strokeSettings = this.strokeSettings;
        }
        parent.activeObj.strokeSettings.strokeColor = strokeColor || parent.activeObj.strokeSettings.strokeColor;
        parent.activeObj.textSettings.text = text || parent.activeObj.textSettings.text;
        parent.activeObj.textSettings.fontFamily = fontFamily || parent.activeObj.textSettings.fontFamily;
        parent.activeObj.textSettings.fontSize = fontSize || parent.activeObj.textSettings.fontSize;
        parent.activeObj.textSettings.bold = bold || parent.activeObj.textSettings.bold;
        parent.activeObj.textSettings.italic = italic || parent.activeObj.textSettings.italic;
    }
    redrawActObj(x, y, isMouseDown) {
        let splitWords;
        const parent = this.parent;
        if (parent.activeObj.shape) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (parent.activeObj.horTopLine && (parent.activeObj.shape && splitWords[0] !== 'crop')) {
            if (parent.textArea.style.display === 'block') {
                parent.notify('selection', { prop: 'setTextBoxStylesToActObj', onPropertyChange: false });
                this.updateFontRatio(parent.activeObj, true);
                if (x && y) {
                    if ((x !== parent.activeObj.activePoint.startX) && (y !== parent.activeObj.activePoint.startY)) {
                        this.updateTextFromTextArea();
                    }
                }
                else {
                    this.updateTextFromTextArea();
                    parent.textArea.style.transform = '';
                    parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
                }
                this.refreshActiveObj();
            }
            else {
                this.applyActObj(isMouseDown);
            }
        }
    }
    apply(shape, obj, canvas) {
        const parent = this.parent;
        if (!parent.disabled) {
            if (parent.togglePen && !parent.currObjType.isCustomCrop) {
                const destLeft = parent.img.destLeft;
                const destTop = parent.img.destTop;
                const destWidth = parent.img.destWidth;
                const destHeight = parent.img.destHeight;
                parent.notify('draw', { prop: 'callUpdateCurrTransState', onPropertyChange: false });
                const temp = this.lowerContext.filter;
                this.lowerContext.filter = 'none';
                parent.togglePen = false;
                this.iterateObjColl();
                parent.notify('freehandDraw', { prop: 'freehandRedraw', onPropertyChange: false,
                    value: { context: this.lowerContext, points: null } });
                parent.togglePen = false;
                if (parent.isCircleCrop || (parent.currSelectionPoint &&
                    parent.currSelectionPoint.shape === 'crop-circle')) {
                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                        value: { context: this.lowerContext, isSave: null, isFlip: null } });
                }
                parent.img.destLeft = destLeft;
                parent.img.destTop = destTop;
                parent.img.destWidth = destWidth;
                parent.img.destHeight = destHeight;
                this.lowerContext.filter = temp;
            }
            else {
                canvas = canvas ? canvas : 'original';
                if (isNullOrUndefined(parent.activeObj.shape) && isNullOrUndefined(shape)) {
                    parent.currObjType.shape = '';
                }
                else {
                    parent.currObjType.shape = shape || parent.currObjType.shape;
                }
                if (parent.currObjType.shape !== '') {
                    this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                    if (parent.activeObj.shape === 'text') {
                        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: canvas, obj: obj, isCropRatio: null,
                                points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
                        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
                    }
                    else {
                        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: canvas, obj: obj } });
                    }
                    parent.activeObj.shape = parent.currObjType.shape.toLowerCase();
                    if (!shape && parent.currObjType.shape !== '' && !parent.currObjType.isCustomCrop) {
                        parent.objColl.push(extend({}, parent.activeObj, {}, true));
                    }
                    this.keyHistory = '';
                }
            }
        }
    }
    setCenterPoints(text, width, height) {
        const parent = this.parent;
        let renderWidth;
        let renderHeight;
        if (text && width && height) {
            renderWidth = width;
            renderHeight = height;
        }
        else {
            renderWidth = parent.activeObj.activePoint.width;
            renderHeight = parent.activeObj.activePoint.height;
        }
        parent.activeObj.activePoint.startX = (parent.lowerCanvas.width / 2) - renderWidth / 2;
        parent.activeObj.activePoint.startY = (parent.lowerCanvas.height / 2) - renderHeight / 2;
        parent.activeObj.activePoint.endX = (parent.lowerCanvas.width / 2) + renderWidth / 2;
        parent.activeObj.activePoint.endY = (parent.lowerCanvas.height / 2) + renderHeight / 2;
    }
    updSelChangeEventArgs(selectionSettings) {
        const parent = this.parent;
        parent.activeObj.activePoint.startX = selectionSettings.startX;
        parent.activeObj.activePoint.startY = selectionSettings.startY;
        parent.activeObj.activePoint.width = selectionSettings.width;
        parent.activeObj.activePoint.height = selectionSettings.height;
        parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
        parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
    }
    updateShapeChangeEventArgs(shapeSettings) {
        const parent = this.parent;
        parent.activeObj.currIndex = shapeSettings.id;
        parent.activeObj.activePoint.startX = shapeSettings.startX;
        parent.activeObj.activePoint.startY = shapeSettings.startY;
        parent.activeObj.activePoint.width = shapeSettings.width;
        parent.activeObj.activePoint.height = shapeSettings.height;
        parent.activeObj.activePoint.endX = parent.activeObj.activePoint.startX + parent.activeObj.activePoint.width;
        parent.activeObj.activePoint.endY = parent.activeObj.activePoint.startY + parent.activeObj.activePoint.height;
        parent.activeObj.strokeSettings.strokeColor = shapeSettings.strokeColor;
        parent.activeObj.strokeSettings.fillColor = shapeSettings.fillColor;
        switch (parent.activeObj.shape) {
            case 'ellipse':
                parent.activeObj.activePoint.width = shapeSettings.radius * 2;
                break;
            case 'line':
            case 'arrow':
                parent.activeObj.activePoint.width = shapeSettings.length;
                break;
            case 'text':
                parent.activeObj.keyHistory = parent.activeObj.textSettings.text = shapeSettings.text;
                parent.activeObj.textSettings.fontSize = shapeSettings.fontSize;
                parent.activeObj.strokeSettings.strokeColor = shapeSettings.color;
                parent.activeObj.textSettings.fontFamily = shapeSettings.fontFamily;
                break;
            case 'rectangle':
                break;
        }
        if (parent.activeObj.shape === 'text' && parent.activeObj.textSettings) {
            for (let i = 0; i < shapeSettings.fontStyle.length; i++) {
                switch (shapeSettings.fontStyle[i]) {
                    case 'bold':
                        parent.activeObj.textSettings.bold = true;
                        break;
                    case 'italic':
                        parent.activeObj.textSettings.italic = true;
                        break;
                    case 'underline':
                        parent.activeObj.textSettings.underline = true;
                        break;
                }
            }
        }
    }
    addLetter(letter) {
        const parent = this.parent;
        if (parent.textArea.style.display === 'none' && (parent.currObjType.isText || parent.activeObj.shape === 'text')) {
            if (letter === 'Backspace') {
                this.keyHistory = this.keyHistory.slice(0, -1);
            }
            else {
                this.keyHistory += letter;
            }
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            this.updateFontStyles();
            const width = this.upperContext.measureText(this.keyHistory).width
                + parent.activeObj.textSettings.fontSize * 0.5;
            const height = parent.activeObj.textSettings.fontSize + parent.activeObj.textSettings.fontSize * 0.25;
            this.upperContext.fillText(this.keyHistory, parent.activeObj.activePoint.startX, parent.activeObj.activePoint.startY +
                parent.activeObj.textSettings.fontSize);
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.currObjType.isText = true;
            parent.notify('selection', { prop: 'setActivePoint', onPropertyChange: false,
                value: { startX: width, startY: height } });
        }
    }
    redrawText() {
        const parent = this.parent;
        let fontStyle = '';
        if (parent.activeObj.textSettings.bold) {
            fontStyle += 'bold ';
        }
        if (parent.activeObj.textSettings.italic) {
            fontStyle += 'italic ';
        }
        this.upperContext.font = fontStyle + parent.activeObj.textSettings.fontSize + 'px ' + parent.activeObj.textSettings.fontFamily;
        const rows = parent.activeObj.keyHistory.split('\n');
        const text = parent.textArea.style.display === 'block' ? this.getMaxText(true) : this.getMaxText();
        const width = this.upperContext.measureText(text).width + parent.activeObj.textSettings.fontSize * 0.5;
        const height = rows.length * (parent.activeObj.textSettings.fontSize + parent.activeObj.textSettings.fontSize * 0.25);
        parent.notify('selection', { prop: 'setTextSelection', onPropertyChange: false,
            value: { width: width, height: height } });
        parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: parent.activeObj.activePoint, obj: parent.activeObj,
                isMouseMove: null, x: null, y: null } });
        parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,
            value: { obj: parent.activeObj } });
    }
    updateTextFromTextArea() {
        const parent = this.parent;
        let allowUndoRedo = false;
        const prevCropObj = extend({}, parent.cropObj, {}, true);
        const object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.parent.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        if (parent.activeObj.keyHistory !== parent.textArea.value) {
            allowUndoRedo = true;
        }
        parent.activeObj.keyHistory = parent.textArea.value;
        parent.textArea.style.display = 'none';
        parent.textArea.value = '';
        this.updateFontStyles();
        let width = this.upperContext.measureText(parent.activeObj.keyHistory).width +
            parent.activeObj.textSettings.fontSize * 0.5;
        let height = parent.activeObj.textSettings.fontSize + this.parent.activeObj.textSettings.fontSize * 0.25;
        const rows = parent.activeObj.keyHistory.split('\n');
        if (rows.length > 1) {
            height *= rows.length;
            const widthColl = [];
            for (let i = 0, len = rows.length; i < len; i++) {
                widthColl.push(this.upperContext.measureText(rows[i]).width +
                    parent.activeObj.textSettings.fontSize * 0.5);
            }
            width = Math.max(...widthColl);
        }
        parent.notify('selection', { prop: 'setTextSelection', onPropertyChange: false,
            value: { width: width, height: height } });
        parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: parent.activeObj.activePoint, obj: parent.activeObj,
                isMouseMove: null, x: null, y: null } });
        this.updImgRatioForActObj();
        if (allowUndoRedo) {
            this.apply(parent.activeObj.shape, parent.activeObj);
            parent.objColl.push(extend({}, parent.activeObj, {}, true));
            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'text', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: parent.activeObj.keyHistory,
                    currentText: parent.textArea.value, previousFilter: null, isCircleCrop: null } });
        }
        else {
            this.apply(parent.activeObj.shape, parent.activeObj);
            parent.objColl.push(extend({}, parent.activeObj, {}, true));
        }
    }
    iterateObjColl() {
        const parent = this.parent;
        for (let i = 0, len = parent.objColl.length; i < len; i++) {
            this.apply(parent.objColl[i].shape, parent.objColl[i]);
            this.refreshActiveObj();
        }
    }
    updImgRatioForActObj() {
        const parent = this.parent;
        parent.activeObj.imageRatio = { startX: ((parent.activeObj.activePoint.startX - parent.img.destLeft) /
                parent.img.destWidth),
            startY: ((parent.activeObj.activePoint.startY - parent.img.destTop) / parent.img.destHeight),
            endX: ((parent.activeObj.activePoint.endX - parent.img.destLeft) / parent.img.destWidth),
            endY: ((parent.activeObj.activePoint.endY - parent.img.destTop) / parent.img.destHeight),
            width: parent.img.destWidth / parent.activeObj.activePoint.width, height: parent.img.destHeight /
                parent.activeObj.activePoint.height };
        if (parent.activeObj.rotationCirclePointColl) {
            parent.activeObj.rotationCirclePointColl.ratioX = (parent.activeObj.rotationCirclePointColl.x -
                parent.img.destLeft) / parent.img.destWidth;
            parent.activeObj.rotationCirclePointColl.ratioY = (parent.activeObj.rotationCirclePointColl.y -
                parent.img.destTop) / parent.img.destHeight;
        }
        if (parent.activeObj.shape === 'path') {
            this.updatePathRatio(parent.activeObj);
        }
        else if (parent.activeObj.shape === 'arrow') {
            this.updateArrowRatio(parent.activeObj);
        }
    }
    zoomObjColl(preventApply) {
        const parent = this.parent;
        for (let i = 0, len = parent.objColl.length; i < len; i++) {
            let currObj = parent.objColl[i];
            currObj.activePoint.startX = (currObj.imageRatio.startX * parent.img.destWidth) + parent.img.destLeft;
            currObj.activePoint.startY = (currObj.imageRatio.startY * parent.img.destHeight) + parent.img.destTop;
            currObj.activePoint.endX = (currObj.imageRatio.endX * parent.img.destWidth) + parent.img.destLeft;
            currObj.activePoint.endY = (currObj.imageRatio.endY * parent.img.destHeight) + parent.img.destTop;
            currObj = this.updateWidthHeight(currObj);
            if (currObj.shape === 'text') {
                this.updateFontSize(currObj);
            }
            else if (currObj.shape === 'line' || currObj.shape === 'arrow') {
                currObj.pointColl = this.getLinePoints(currObj.activePoint.startX, currObj.activePoint.startY, currObj.activePoint.endX, currObj.activePoint.endY);
                for (let n = 0, len = currObj.pointColl.length; n < len; n++) {
                    currObj.pointColl[n].ratioX =
                        (currObj.pointColl[n].x - parent.img.destLeft) / parent.img.destWidth;
                    currObj.pointColl[n].ratioY =
                        (currObj.pointColl[n].y - parent.img.destTop) / parent.img.destHeight;
                }
                if (currObj.shape === 'arrow') {
                    this.updateArrowSize(currObj);
                }
            }
            else if (currObj.shape === 'path') {
                for (let l = 0, len = currObj.pointColl.length; l < len; l++) {
                    currObj.pointColl[l].x = (currObj.pointColl[l].ratioX * parent.img.destWidth)
                        + parent.img.destLeft;
                    currObj.pointColl[l].y = (currObj.pointColl[l].ratioY * parent.img.destHeight) +
                        parent.img.destTop;
                }
                this.updatePathRatio(currObj);
            }
            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint,
                    obj: currObj } });
            if (isNullOrUndefined(preventApply)) {
                const temp = this.lowerContext.filter;
                this.lowerContext.filter = 'none';
                this.apply(currObj.shape, currObj);
                this.refreshActiveObj();
                this.lowerContext.filter = temp;
            }
            if (currObj.shape !== 'line' && currObj.shape !== 'arrow' && currObj.shape !== 'path' && currObj.rotatedAngle !== 0) {
                this.setPointCollForShapeRotation(currObj);
                currObj.rotationCirclePoint.x =
                    (currObj.rotationCirclePoint.ratioX * parent.img.destWidth) + parent.img.destLeft;
                currObj.rotationCirclePoint.y =
                    (currObj.rotationCirclePoint.ratioY * parent.img.destHeight) + parent.img.destTop;
                currObj.rotationCirclePointColl.x =
                    (currObj.rotationCirclePointColl.ratioX * parent.img.destWidth) +
                        parent.img.destLeft;
                currObj.rotationCirclePointColl.y =
                    (currObj.rotationCirclePointColl.ratioY * parent.img.destHeight) +
                        parent.img.destTop;
            }
        }
    }
    redrawObj(degree) {
        const parent = this.parent;
        if (this.parent.objColl.length > 0) {
            if (degree === 'horizontal' || degree === 'vertical' || degree === 'Horizontal' || degree === 'Vertical' ||
                degree === 'horizontalVertical' || degree === 'verticalHorizontal') {
                this.updateCurrentActiveObjPoint(degree.toLowerCase());
            }
            else if (typeof (degree) === 'number') {
                this.updateCurrentActiveObjPoint(degree);
                const tempFilter = this.lowerContext.filter;
                this.lowerContext.filter = 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
                    'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' + 'invert(0%)';
                for (let i = 0, len = parent.objColl.length; i < len; i++) {
                    const splitWords = parent.objColl[i].shape.split('-');
                    if (splitWords[0] !== 'crop') {
                        this.apply(parent.objColl[i].shape, parent.objColl[i]);
                    }
                }
                this.lowerContext.filter = tempFilter;
            }
        }
    }
    updateCurrentActiveObjPoint(degree) {
        const parent = this.parent;
        let currActObjIndex;
        for (let index = 0, len = parent.objColl.length; index < len; index++) {
            const currObj = parent.objColl[index];
            if (parent.activeObj.shape === currObj.shape &&
                parent.activeObj.activePoint.startX === currObj.activePoint.startX &&
                parent.activeObj.activePoint.startY === currObj.activePoint.startY &&
                parent.activeObj.activePoint.endX === currObj.activePoint.endX &&
                parent.activeObj.activePoint.endY === currObj.activePoint.endY &&
                parent.activeObj.currIndex === currObj.currIndex) {
                currActObjIndex = index;
                break;
            }
        }
        if (degree === 'horizontal' || degree === 'vertical' || degree === 'Horizontal' || degree === 'Vertical' ||
            degree === 'horizontalvertical' || degree === 'verticalhorizontal') {
            if (degree === 'horizontal' || degree === 'Horizontal') {
                for (let i = 0, len = parent.objColl.length; i < len; i++) {
                    const currObj = parent.objColl[i];
                    if (currObj.shapeFlip !== parent.transform.currFlipState) {
                        if (currObj.activePoint.startX <= parent.img.destLeft + (parent.img.destWidth / 2)) {
                            currObj.activePoint.endX = (parent.img.destLeft + parent.img.destWidth) - (currObj.activePoint.startX -
                                parent.img.destLeft);
                            currObj.activePoint.startX = currObj.activePoint.endX - currObj.activePoint.width;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
                        }
                        else if (currObj.activePoint.startX >= parent.img.destLeft + (parent.img.destWidth / 2)) {
                            currObj.activePoint.startX = parent.img.destLeft + (parent.img.destLeft + parent.img.destWidth -
                                currObj.activePoint.endX);
                            currObj.activePoint.endX = currObj.activePoint.startX + currObj.activePoint.width;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint,
                                    obj: currObj } });
                        }
                        if (currObj.shape === 'line' || currObj.shape === 'arrow' || currObj.shape === 'path') {
                            this.flipLineArrowObj(currObj, 'horizontal');
                        }
                        else if (currObj.rotatedAngle !== 0) {
                            currObj.rotatedAngle = currObj.rotatedAngle + (Math.PI - currObj.rotatedAngle) * 2;
                            if (currObj.rotationCirclePointColl.x <= parent.img.destLeft + (parent.img.destWidth / 2)) {
                                currObj.rotationCirclePointColl.x = (parent.img.destLeft + parent.img.destWidth) -
                                    (currObj.rotationCirclePointColl.x - parent.img.destLeft);
                            }
                            else if (currObj.rotationCirclePointColl.x >= parent.img.destLeft + (parent.img.destWidth / 2)) {
                                currObj.rotationCirclePointColl.x = parent.img.destLeft +
                                    (parent.img.destLeft + parent.img.destWidth - currObj.rotationCirclePointColl.x);
                            }
                            currObj.rotationCirclePointColl.ratioX =
                                (currObj.rotationCirclePointColl.x - parent.img.destLeft) / parent.img.destWidth;
                        }
                        currObj.shapeFlip = parent.transform.currFlipState;
                        currObj.imageRatio = { startX: ((currObj.activePoint.startX - parent.img.destLeft) / parent.img.destWidth),
                            startY: ((currObj.activePoint.startY - parent.img.destTop) / parent.img.destHeight),
                            endX: ((currObj.activePoint.endX - parent.img.destLeft) / parent.img.destWidth),
                            endY: ((currObj.activePoint.endY - parent.img.destTop) / parent.img.destHeight),
                            width: parent.img.destWidth / currObj.activePoint.width,
                            height: parent.img.destHeight / currObj.activePoint.height };
                    }
                }
            }
            else if (degree === 'vertical' || degree === 'Vertical') {
                for (let i = 0; i < parent.objColl.length; i++) {
                    const currObj = parent.objColl[i];
                    if (currObj.shapeFlip !== parent.transform.currFlipState) {
                        if (currObj.activePoint.startY <= parent.img.destTop + (parent.img.destHeight / 2)) {
                            currObj.activePoint.endY = (parent.img.destTop + parent.img.destHeight) -
                                (currObj.activePoint.startY - parent.img.destTop);
                            currObj.activePoint.startY = currObj.activePoint.endY - currObj.activePoint.height;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint,
                                    obj: currObj } });
                        }
                        else if (currObj.activePoint.startY >= this.parent.lowerCanvas.height / 2) {
                            currObj.activePoint.startY = parent.img.destTop + (parent.img.destTop +
                                parent.img.destHeight - currObj.activePoint.endY);
                            currObj.activePoint.endY = currObj.activePoint.startY +
                                currObj.activePoint.height;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint,
                                    obj: currObj } });
                        }
                        if (currObj.shape === 'line' || currObj.shape === 'arrow' ||
                            currObj.shape === 'path') {
                            this.flipLineArrowObj(currObj, 'vertical');
                        }
                        else if (currObj.rotatedAngle !== 0) {
                            currObj.rotatedAngle = -currObj.rotatedAngle;
                            if (currObj.rotationCirclePointColl.y <= parent.img.destTop + (parent.img.destHeight / 2)) {
                                currObj.rotationCirclePointColl.y = (parent.img.destTop + parent.img.destHeight) -
                                    (currObj.rotationCirclePointColl.y - parent.img.destTop);
                            }
                            else if (currObj.rotationCirclePointColl.y >= parent.img.destTop +
                                (parent.img.destHeight / 2)) {
                                currObj.rotationCirclePointColl.y = parent.img.destTop + (parent.img.destTop +
                                    parent.img.destHeight - currObj.rotationCirclePointColl.y);
                            }
                            currObj.rotationCirclePointColl.ratioY =
                                (currObj.rotationCirclePointColl.y - parent.img.destTop) / parent.img.destHeight;
                        }
                        currObj.shapeFlip = parent.transform.currFlipState;
                        currObj.imageRatio = { startX: ((currObj.activePoint.startX - parent.img.destLeft) / parent.img.destWidth),
                            startY: ((currObj.activePoint.startY - parent.img.destTop) / parent.img.destHeight),
                            endX: ((currObj.activePoint.endX - parent.img.destLeft) / parent.img.destWidth),
                            endY: ((currObj.activePoint.endY - parent.img.destTop) / parent.img.destHeight),
                            width: parent.img.destWidth / currObj.activePoint.width,
                            height: parent.img.destHeight / currObj.activePoint.height };
                    }
                }
            }
            else if (degree === 'verticalhorizontal' || degree === 'horizontalvertical') {
                for (let i = 0, len = parent.objColl.length; i < len; i++) {
                    const currObj = parent.objColl[i];
                    if (currObj.shapeFlip !== parent.transform.currFlipState) {
                        if (currObj.activePoint.startX <= parent.img.destLeft + (parent.img.destWidth / 2)) {
                            currObj.activePoint.endX = (parent.img.destLeft + parent.img.destWidth) - (currObj.activePoint.startX -
                                parent.img.destLeft);
                            currObj.activePoint.startX = currObj.activePoint.endX - currObj.activePoint.width;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
                        }
                        else if (currObj.activePoint.startX >= parent.img.destLeft + (parent.img.destWidth / 2)) {
                            currObj.activePoint.startX = parent.img.destLeft + (parent.img.destLeft +
                                parent.img.destWidth - currObj.activePoint.endX);
                            currObj.activePoint.endX = currObj.activePoint.startX + currObj.activePoint.width;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
                        }
                        if (currObj.activePoint.startY <= parent.img.destTop + (parent.img.destHeight / 2)) {
                            currObj.activePoint.endY = (parent.img.destTop + parent.img.destHeight) -
                                (currObj.activePoint.startY - parent.img.destTop);
                            currObj.activePoint.startY = currObj.activePoint.endY -
                                currObj.activePoint.height;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
                        }
                        else if (currObj.activePoint.startY >= this.parent.lowerCanvas.height / 2) {
                            currObj.activePoint.startY = parent.img.destTop + (parent.img.destTop +
                                parent.img.destHeight - currObj.activePoint.endY);
                            currObj.activePoint.endY = currObj.activePoint.startY +
                                currObj.activePoint.height;
                            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint, obj: currObj } });
                        }
                        if (currObj.shape === 'line' || currObj.shape === 'arrow' || currObj.shape === 'path') {
                            this.flipLineArrowObj(currObj, degree);
                        }
                        currObj.shapeFlip = parent.transform.currFlipState;
                        currObj.imageRatio = { startX: ((currObj.activePoint.startX - parent.img.destLeft) / parent.img.destWidth),
                            startY: ((currObj.activePoint.startY - parent.img.destTop) / parent.img.destHeight),
                            endX: ((currObj.activePoint.endX - parent.img.destLeft) / parent.img.destWidth),
                            endY: ((currObj.activePoint.endY - parent.img.destTop) / parent.img.destHeight),
                            width: parent.img.destWidth / currObj.activePoint.width,
                            height: parent.img.destHeight / currObj.activePoint.height };
                    }
                }
            }
            if (currActObjIndex !== undefined) {
                parent.activeObj = extend({}, parent.objColl[currActObjIndex], {}, true);
            }
        }
        else if (degree === 90) {
            this.rotateObjColl();
        }
        else if (degree === -90) {
            for (let i = 0; i < 3; i++) {
                this.rotateObjColl();
            }
        }
        else if (typeof (degree) === 'number') {
            if (degree > 0) {
                this.rotateObjColl();
            }
            else {
                for (let i = 0; i < 3; i++) {
                    this.rotateObjColl();
                }
            }
        }
    }
    rotateObjColl() {
        const parent = this.parent;
        for (let i = 0, len = parent.objColl.length; i < len; i++) {
            let currObj = parent.objColl[i];
            currObj.activePoint.startY = parent.img.destTop + (parent.img.destHeight * currObj.imageRatio.startX);
            currObj.activePoint.endY = parent.img.destTop + (parent.img.destHeight * currObj.imageRatio.endX);
            currObj.activePoint.startX = (parent.img.destLeft + parent.img.destWidth) -
                (parent.img.destWidth * currObj.imageRatio.endY);
            currObj.activePoint.endX = (parent.img.destLeft + parent.img.destWidth) -
                (parent.img.destWidth * currObj.imageRatio.startY);
            currObj = this.updateWidthHeight(parent.objColl[i]);
            this.updateFontSize(currObj);
            if (currObj.shape === 'line' || currObj.shape === 'arrow' ||
                currObj.shape === 'path') {
                this.rotateLineArrowObj(currObj);
                if (currObj.shape === 'arrow') {
                    this.updateArrowSize(currObj);
                }
            }
            else if (currObj.rotatedAngle !== 0) {
                currObj.rotationCirclePointColl.y = parent.img.destTop + (parent.img.destHeight * currObj.rotationCirclePointColl.ratioX);
                currObj.rotationCirclePointColl.x = (parent.img.destLeft + parent.img.destWidth) -
                    (parent.img.destWidth * currObj.rotationCirclePointColl.ratioY);
                currObj.rotationCirclePointColl.ratioX = (currObj.rotationCirclePointColl.x
                    - parent.img.destLeft) / parent.img.destWidth;
                currObj.rotationCirclePointColl.ratioY = (currObj.rotationCirclePointColl.y
                    - parent.img.destTop) / parent.img.destHeight;
            }
        }
        for (let i = 0, len = parent.objColl.length; i < len; i++) {
            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: parent.objColl[i].activePoint, obj: parent.objColl[i] } });
        }
        // Update current image ratio for all objects
        for (let i = 0, len = parent.objColl.length; i < len; i++) {
            const currObj = parent.objColl[i];
            currObj.imageRatio = { startX: ((currObj.activePoint.startX - parent.img.destLeft) / parent.img.destWidth),
                startY: ((currObj.activePoint.startY - parent.img.destTop) / parent.img.destHeight),
                endX: ((currObj.activePoint.endX - parent.img.destLeft) / parent.img.destWidth),
                endY: ((currObj.activePoint.endY - parent.img.destTop) / parent.img.destHeight),
                width: parent.img.destWidth / currObj.activePoint.width,
                height: parent.img.destHeight / currObj.activePoint.height };
        }
    }
    rotateLineArrowObj(obj) {
        if (isNullOrUndefined(obj.pointColl)) {
            return;
        }
        const parent = this.parent;
        if (obj.pointColl.length > 0) {
            for (let n = 0; n < obj.pointColl.length; n++) {
                obj.pointColl[n].y = parent.img.destTop + (parent.img.destHeight * obj.pointColl[n].ratioX);
                obj.pointColl[n].x = (parent.img.destLeft + parent.img.destWidth) - (parent.img.destWidth *
                    obj.pointColl[n].ratioY);
            }
            for (let n = 0; n < obj.pointColl.length; n++) {
                obj.pointColl[n].ratioX = (obj.pointColl[n].x - parent.img.destLeft) / parent.img.destWidth;
                obj.pointColl[n].ratioY = (obj.pointColl[n].y - parent.img.destTop) / parent.img.destHeight;
            }
            let prevPoint;
            if (isNullOrUndefined(obj.pointColl[obj.pointColl.length - 2])) {
                prevPoint = { x: 0, y: 0 };
            }
            else {
                prevPoint = { x: obj.pointColl[obj.pointColl.length - 2].x, y: obj.pointColl[obj.pointColl.length - 2].y };
            }
            const diffX = obj.pointColl[obj.pointColl.length - 1].x - prevPoint.x;
            const diffY = obj.pointColl[obj.pointColl.length - 1].y - prevPoint.y;
            obj.activePoint.startX = obj.pointColl[0].x;
            obj.activePoint.startY = obj.pointColl[0].y;
            obj.activePoint.endX = obj.pointColl[obj.pointColl.length - 1].x + (diffX / 2);
            obj.activePoint.endY = obj.pointColl[obj.pointColl.length - 1].y + (diffY / 2);
            obj = this.updateWidthHeight(obj);
        }
    }
    flipLineArrowObj(obj, value) {
        if (isNullOrUndefined(obj.pointColl)) {
            return;
        }
        if (value.toLowerCase() === 'horizontal') {
            this.lineArrowHorizontalFlip(obj);
        }
        else if (value.toLowerCase() === 'vertical') {
            this.lineArrowVerticalFlip(obj);
        }
        else {
            this.lineArrowHorizontalFlip(obj);
            obj.shapeFlip = '';
            this.lineArrowVerticalFlip(obj);
        }
        obj.activePoint.startX = obj.pointColl[0].x;
        obj.activePoint.startY = obj.pointColl[0].y;
        obj.activePoint.endX = obj.pointColl[obj.pointColl.length - 1].x;
        obj.activePoint.endY = obj.pointColl[obj.pointColl.length - 1].y;
        if (obj.activePoint.startX > obj.activePoint.endX) {
            let temp = obj.activePoint.startX;
            obj.activePoint.startX = obj.activePoint.endX;
            obj.activePoint.endX = temp;
            temp = obj.activePoint.startY;
            obj.activePoint.startY = obj.activePoint.endY;
            obj.activePoint.endY = temp;
        }
    }
    lineArrowHorizontalFlip(obj) {
        const parent = this.parent;
        // Update flip value for point collection
        if (obj.shapeFlip !== parent.transform.currFlipState) {
            for (let l = 0, len = obj.pointColl.length; l < len; l++) {
                const currPoint = obj.pointColl[l];
                if (currPoint.x <= parent.img.destLeft + (parent.img.destWidth / 2)) {
                    currPoint.x = (parent.img.destLeft + parent.img.destWidth) - (currPoint.x
                        - parent.img.destLeft);
                }
                else if (currPoint.x >= parent.img.destLeft + (parent.img.destWidth / 2)) {
                    currPoint.x = parent.img.destLeft + (parent.img.destLeft + parent.img.destWidth -
                        currPoint.x);
                }
                currPoint.ratioX = (currPoint.x - parent.img.destLeft) / parent.img.destWidth;
                currPoint.ratioY = (currPoint.y - parent.img.destTop) / parent.img.destHeight;
            }
            if (obj.shape === 'arrow') {
                const value = obj.start;
                obj.start = obj.end;
                obj.end = value;
            }
            obj.shapeFlip = parent.transform.currFlipState;
        }
    }
    lineArrowVerticalFlip(obj) {
        const parent = this.parent;
        // Update flip value for point collection
        if (obj.shapeFlip !== parent.transform.currFlipState) {
            for (let l = 0, len = obj.pointColl.length; l < len; l++) {
                const currPoint = obj.pointColl[l];
                if (currPoint.y <= parent.img.destTop + (parent.img.destHeight / 2)) {
                    currPoint.y = (parent.img.destTop + parent.img.destHeight) -
                        (currPoint.y - parent.img.destTop);
                }
                else if (currPoint.y >= parent.img.destTop + (parent.img.destHeight / 2)) {
                    currPoint.y = parent.img.destTop + (parent.img.destTop + parent.img.destHeight -
                        currPoint.y);
                }
                currPoint.ratioX = (currPoint.x - parent.img.destLeft) / parent.img.destWidth;
                currPoint.ratioY = (currPoint.y - parent.img.destTop) / parent.img.destHeight;
            }
            obj.shapeFlip = parent.transform.currFlipState;
        }
    }
    getRotDegOfShape(obj) {
        let degree;
        if (obj.shapeDegree === 0) {
            degree = this.parent.transform.degree;
        }
        else {
            degree = this.parent.transform.degree - obj.shapeDegree;
        }
        if (degree < 0) {
            degree = 360 + degree;
        }
        return degree;
    }
    renderTextArea(x, y, actObj) {
        const parent = this.parent;
        const degree = this.getRotDegOfShape(parent.activeObj);
        this.transformTextArea();
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
        }
        else {
            parent.updateToolbar(parent.element, 'destroyQuickAccessToolbar');
        }
        if (parent.element.querySelector('#' + parent.element.id + '_duplicate')) {
            parent.element.querySelector('#' + parent.element.id + '_duplicate').classList.add('e-disabled');
        }
        if (parent.element.querySelector('#' + parent.element.id + '_remove')) {
            parent.element.querySelector('#' + parent.element.id + '_remove').classList.add('e-disabled');
        }
        if (parent.element.querySelector('#' + parent.element.id + '_editText')) {
            parent.element.querySelector('#' + parent.element.id + '_editText').classList.add('e-disabled');
        }
        parent.textArea.style.display = 'block';
        parent.textArea.style.left = x + 'px';
        parent.textArea.style.top = y + 'px';
        parent.textArea.style.fontFamily = actObj.textSettings.fontFamily;
        parent.textArea.style.fontSize = actObj.textSettings.fontSize + 'px';
        parent.textArea.style.color = actObj.strokeSettings.strokeColor;
        parent.textArea.style.fontWeight = actObj.textSettings.bold ? 'bold' : 'normal';
        parent.textArea.style.fontStyle = actObj.textSettings.italic ? 'italic' : 'normal';
        parent.textArea.style.border = '2px solid ' + parent.themeColl[parent.theme]['primaryColor'];
        parent.textArea.value = actObj.keyHistory;
        parent.textArea.style.overflow = 'hidden';
        parent.textArea.style.width = 'auto';
        parent.textArea.style.height = 'auto';
        parent.textArea.focus();
        const zoomFactor = parent.transform.zoomFactor;
        const { width, height } = actObj.activePoint;
        if (degree % 90 === 0 && degree % 180 !== 0 && degree !== 0) {
            parent.textArea.style.width = (zoomFactor === 0 ? height : height) + 'px';
            parent.textArea.style.height = (zoomFactor === 0 ? width : width) + 'px';
        }
        else {
            parent.textArea.style.width = (zoomFactor === 0 ? width : width) + 'px';
            parent.textArea.style.height = (zoomFactor === 0 ? height : height) + 'px';
        }
        this.setTextBoxWidth();
        const obj = { flipColl: null };
        parent.notify('transform', { prop: 'getFlipColl', onPropertyChange: false, value: { obj: obj } });
        if (obj['flipColl'].length <= 1) {
            this.setTextBoxHeight();
        }
        if (degree % 90 === 0 && degree % 180 !== 0) {
            if (parseFloat(parent.textArea.style.left) + parseFloat(parent.textArea.style.width) > parent.img.destTop +
                parent.img.destHeight) {
                this.alignTextAreaIntoCanvas();
            }
        }
        else {
            if (parseFloat(parent.textArea.style.left) + parseFloat(parent.textArea.style.width) > parent.img.destLeft +
                parent.img.destWidth) {
                this.alignTextAreaIntoCanvas();
            }
        }
        parent.notify('selection', { prop: 'clearUpperCanvas', onPropertyChange: false });
    }
    setTextBoxWidth(e) {
        const parent = this.parent;
        const text = this.getMaxText(true);
        if (parent.textArea.style.display === 'block') {
            this.updateFontStyles(true);
        }
        else {
            this.updateFontStyles();
        }
        const textAreaWidth = (this.upperContext.measureText(text).width + (parseFloat(parent.textArea.style.fontSize) / 2));
        const letterWidth = e ? this.upperContext.measureText(String.fromCharCode(e.which)).width : 0;
        const actObj = extend({}, parent.activeObj, {}, true);
        let flip = '';
        const degree = this.getRotDegOfShape(actObj);
        if (actObj.shapeFlip !== parent.transform.currFlipState) {
            flip = '';
        }
        else {
            flip = parent.transform.currFlipState;
        }
        if ((e && parseFloat(parent.textArea.style.width) < (textAreaWidth + letterWidth)) || isNullOrUndefined(e)) {
            if (degree === 0) {
                if (flip.toLowerCase() === 'horizontal') {
                    if ((parseFloat(parent.textArea.style.left) - parent.img.destLeft) - textAreaWidth - letterWidth > 0) {
                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                    }
                }
                else if ((parent.img.destWidth - (parseFloat(parent.textArea.style.left) -
                    parent.img.destLeft)) > (textAreaWidth + letterWidth)) {
                    parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                }
            }
            else if (degree === 90) {
                if (flip.toLowerCase() === 'vertical') {
                    if ((parseFloat(parent.textArea.style.top) - parent.img.destTop) - textAreaWidth - letterWidth > 0) {
                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                    }
                }
                else if ((parent.img.destHeight - (parseFloat(parent.textArea.style.top) -
                    parent.img.destTop)) > (textAreaWidth + letterWidth)) {
                    parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                }
            }
            else if (degree === 180) {
                const textAreaLeft = parseFloat(parent.textArea.style.left);
                const destLeft = parent.img.destLeft;
                if (flip.toLowerCase() === 'horizontal') {
                    const remainingWidth = parent.img.destWidth - (textAreaLeft - destLeft);
                    if (remainingWidth > textAreaWidth + letterWidth) {
                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                    }
                }
                else {
                    const distanceToLeft = textAreaLeft - destLeft;
                    if (distanceToLeft - textAreaWidth - letterWidth > 0) {
                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                    }
                }
            }
            else if (degree === 270) {
                const textAreaTop = parseFloat(parent.textArea.style.top);
                const destTop = parent.img.destTop;
                if (flip.toLowerCase() === 'vertical') {
                    const remainingHeight = parent.img.destHeight - (textAreaTop - destTop);
                    if (remainingHeight > textAreaWidth + letterWidth) {
                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                    }
                }
                else {
                    const distanceToTop = textAreaTop - destTop;
                    if (distanceToTop - textAreaWidth - letterWidth > 0) {
                        parent.textArea.style.width = (textAreaWidth + letterWidth) + 'px';
                    }
                }
            }
        }
    }
    setTextBoxHeight() {
        const parent = this.parent;
        let textAreaTop;
        const actObj = extend({}, parent.activeObj, {}, true);
        let flip = '';
        const degree = this.getRotDegOfShape(actObj);
        if (actObj.textFlip === parent.transform.currFlipState) {
            flip = '';
        }
        else if (actObj.textFlip === '') {
            flip = parent.transform.currFlipState;
        }
        else {
            flip = actObj.textFlip;
        }
        switch (degree) {
            case 0:
                if (flip.toLowerCase() === 'vertical') {
                    parent.textArea.style.maxHeight = (parent.img.destHeight - (parent.img.destHeight -
                        parseFloat(parent.textArea.style.top))) + 'px';
                }
                else {
                    textAreaTop = parseFloat(parent.textArea.style.top) - parent.img.destTop;
                    parent.textArea.style.maxHeight = (parent.img.destHeight - textAreaTop) + 'px';
                }
                break;
            case 90:
                if (flip.toLowerCase() === 'horizontal') {
                    parent.textArea.style.maxHeight = (parent.img.destWidth - (parseFloat(parent.textArea.style.left) -
                        parent.img.destLeft)) + 'px';
                }
                else {
                    parent.textArea.style.maxHeight = (parseFloat(parent.textArea.style.left) - parent.img.destLeft) + 'px';
                }
                break;
            case 180:
                if (flip.toLowerCase() === 'vertical') {
                    textAreaTop = parseFloat(parent.textArea.style.top) - parent.img.destTop;
                    parent.textArea.style.maxHeight = (parent.img.destHeight - textAreaTop) + 'px';
                }
                else {
                    parent.textArea.style.maxHeight = (parseFloat(parent.textArea.style.top) - parent.img.destTop) + 'px';
                }
                break;
            case 270:
                if (flip.toLowerCase() === 'horizontal') {
                    parent.textArea.style.maxHeight = (parseFloat(parent.textArea.style.left) - parent.img.destLeft) + 'px';
                }
                else {
                    parent.textArea.style.maxHeight = parent.img.destWidth - (parseFloat(parent.textArea.style.left)
                        - parent.img.destLeft) + 'px';
                }
                break;
        }
    }
    updatePathRatio(obj) {
        const parent = this.parent;
        for (let i = 0, len = obj.pointColl.length; i < len; i++) {
            const currPoint = obj.pointColl[i];
            currPoint.ratioX = (currPoint.x - parent.img.destLeft) / parent.img.destWidth;
            currPoint.ratioY = (currPoint.y - parent.img.destTop) / parent.img.destHeight;
        }
    }
    stopPathDrawing(e) {
        const parent = this.parent;
        if (parent.activeObj.shape === 'path') {
            const obj = { shape: null };
            parent.notify('selection', { prop: 'getCurrentDrawingShape', value: { obj: obj } });
            if (obj['shape'] === 'path') {
                const prevCropObj = extend({}, this.parent.cropObj, {}, true);
                const object = { currObj: {} };
                this.parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                const prevObj = object['currObj'];
                prevObj.objColl = extend([], this.parent.objColl, [], true);
                prevObj.pointColl = extend([], this.parent.pointColl, [], true);
                prevObj.afterCropActions = extend([], this.parent.afterCropActions, [], true);
                const selPointCollObj = { selPointColl: null };
                this.parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                    value: { obj: selPointCollObj } });
                prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
                parent.notify('selection', { prop: 'setCurrentDrawingShape', value: { value: '' } });
                parent.currObjType.isDragging = false;
                if (e.type !== 'touchstart') {
                    parent.activeObj.pointColl.pop();
                }
                this.updatePathRatio(parent.activeObj);
                parent.objColl.push(parent.activeObj);
                parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                    value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                        previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                        previousCropObj: prevCropObj, previousText: null,
                        currentText: null, previousFilter: null, isCircleCrop: null } });
                parent.objColl.pop();
                parent.notify('selection', { prop: 'mouseUpEventHandler', value: { e: e } });
                parent.notify('draw', { prop: 'setNewPath', value: { bool: true } });
                if (parent.objColl[parent.objColl.length - 1]) {
                    parent.selectShape(parent.objColl[parent.objColl.length - 1].currIndex);
                }
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
                }
                else {
                    parent.updateToolbar(parent.element, 'quickAccessToolbar', parent.activeObj.shape);
                }
            }
        }
    }
    findTextTarget(e) {
        const parent = this.parent;
        if (parent.activeObj.shape !== 'text') {
            this.stopPathDrawing(e);
            return;
        }
        let x;
        let y;
        if (e.type === 'dblclick') {
            x = e.clientX;
            y = e.clientY;
        }
        else if (e.type === 'touchstart') {
            x = e.touches[0].clientX;
            y = e.touches[0].clientY;
            parent.notify('selection', { prop: 'setTouchEndPoint', onPropertyChange: false,
                value: { x: e.touches[0].clientX, y: e.touches[0].clientY } });
        }
        parent.notify('toolbar', { prop: 'setPreventZoomBtn', onPropertyChange: false, value: { isPrevent: true } });
        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',
                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
        parent.notify('toolbar', { prop: 'setPreventZoomBtn', onPropertyChange: false, value: { isPrevent: false } });
        parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
        if (!isNullOrUndefined(x) && !isNullOrUndefined(y)) {
            const bbox = this.parent.lowerCanvas.getBoundingClientRect();
            x -= bbox.left;
            y -= bbox.top;
            let flip = '';
            const degree = this.getRotDegOfShape(parent.activeObj);
            if (parent.activeObj.textFlip === '') {
                if (parent.activeObj.textFlip === parent.transform.currFlipState) {
                    flip = '';
                }
                else {
                    flip = parent.transform.currFlipState;
                }
            }
            else {
                if (parent.activeObj.textFlip === parent.transform.currFlipState) {
                    flip = '';
                }
                else if (parent.transform.currFlipState === '') {
                    flip = parent.activeObj.textFlip;
                }
                else {
                    flip = parent.transform.currFlipState;
                }
            }
            let temp;
            if (parent.textArea.style.display === 'none') {
                temp = extend({}, parent.activeObj, {}, true);
                for (let i = 0; i < parent.objColl.length; i++) {
                    if (JSON.stringify(parent.activeObj) === JSON.stringify(parent.objColl[i])) {
                        parent.objColl.splice(i, 1);
                    }
                }
                this.refreshActiveObj();
                this.upperContext.clearRect(0, 0, this.parent.upperCanvas.width, this.parent.upperCanvas.height);
                this.lowerContext.clearRect(0, 0, this.parent.upperCanvas.width, this.parent.upperCanvas.height);
                parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
                if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                        value: { context: this.lowerContext, isSave: null, isFlip: null } });
                }
                parent.activeObj = temp;
                this.updateFontStyles();
                const actObj = extend({}, parent.activeObj, {}, true);
                if (x >= (actObj.activePoint.startX - (actObj.topLeftCircle.radius * 2)) &&
                    x <= (actObj.activePoint.endX + (actObj.topLeftCircle.radius * 2)) &&
                    y >= (actObj.activePoint.startY - (actObj.topLeftCircle.radius * 2)) &&
                    y <= (actObj.activePoint.endY + (actObj.topLeftCircle.radius * 2))) {
                    this.upperContext.clearRect(0, 0, this.parent.upperCanvas.width, this.parent.upperCanvas.height);
                    if (actObj.flipObjColl.length === 4) {
                        actObj.flipObjColl = [];
                        flip = '';
                        actObj.shapeFlip = '';
                    }
                    if (flip === '' && actObj.flipObjColl.length > 1) {
                        flip = actObj.flipObjColl[actObj.flipObjColl.length - 1];
                    }
                    if (actObj.flipObjColl.length <= 1) {
                        const points = this.setTextBoxPos(actObj, degree, flip, x, y);
                        x = points.x;
                        y = points.y;
                    }
                    else {
                        const points = this.setTextBoxPoints(actObj, degree, flip, x, y);
                        x = points.x;
                        y = points.y;
                    }
                    if (parent.activeObj.rotatedAngle !== 0) {
                        x = parent.activeObj.horTopLinePointColl[0].x;
                        y = parent.activeObj.horTopLinePointColl[0].y;
                    }
                    this.renderTextArea(x, y, actObj);
                }
                else {
                    this.applyActObj();
                }
            }
        }
        else if (parent.textArea.style.display === 'block' && this.selectedText() !== '' && e.type === 'mousedown') {
            const temp = parent.textArea.value;
            parent.textArea.value += 'a';
            parent.textArea.value = temp;
        }
        else if (parent.textArea.style.display === 'none') {
            parent.textArea.style.display = 'block';
        }
    }
    setTextBoxPos(actObj, degree, flip, x, y) {
        const point = { x: x, y: y };
        switch (degree) {
            case 0:
                if (flip.toLowerCase() === 'horizontal') {
                    point.x = actObj.activePoint.endX;
                    point.y = actObj.activePoint.startY;
                }
                else if (flip.toLowerCase() === 'vertical') {
                    point.x = actObj.activePoint.startX;
                    point.y = actObj.activePoint.endY;
                }
                else {
                    point.x = actObj.activePoint.startX;
                    point.y = actObj.activePoint.startY;
                }
                break;
            case 90:
                if (flip.toLowerCase() === 'horizontal') {
                    point.x = actObj.activePoint.startX;
                    point.y = actObj.activePoint.startY;
                }
                else if (flip.toLowerCase() === 'vertical') {
                    point.x = actObj.activePoint.endX;
                    point.y = actObj.activePoint.endY;
                }
                else {
                    point.x = actObj.activePoint.endX;
                    point.y = actObj.activePoint.startY;
                }
                break;
            case 180:
                if (flip.toLowerCase() === 'horizontal') {
                    point.x = actObj.activePoint.startX;
                    point.y = actObj.activePoint.endY;
                }
                else if (flip.toLowerCase() === 'vertical') {
                    point.x = actObj.activePoint.endX;
                    point.y = actObj.activePoint.startY;
                }
                else {
                    point.x = actObj.activePoint.endX;
                    point.y = actObj.activePoint.endY;
                }
                break;
            case 270:
                if (flip.toLowerCase() === 'horizontal') {
                    point.x = actObj.activePoint.endX;
                    point.y = actObj.activePoint.endY;
                }
                else if (flip.toLowerCase() === 'vertical') {
                    point.x = actObj.activePoint.startX;
                    point.y = actObj.activePoint.startY;
                }
                else {
                    point.x = actObj.activePoint.startX;
                    point.y = actObj.activePoint.endY;
                }
                break;
        }
        return point;
    }
    setTextBoxPoints(actObj, degree, flip, x, y) {
        const point = { x: x, y: y };
        switch (degree) {
            case 0:
                if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === 'horizontal') {
                    if (flip.toLowerCase() === 'horizontal') {
                        point.x = (actObj.activePoint.startX);
                        point.y = (actObj.activePoint.startY);
                    }
                    else if (flip.toLowerCase() === 'vertical') {
                        point.x = (actObj.activePoint.endX);
                        point.y = (actObj.activePoint.endY);
                    }
                }
                else {
                    if (flip.toLowerCase() === 'horizontal') {
                        point.x = (actObj.activePoint.endX);
                        point.y = (actObj.activePoint.endY);
                    }
                    else if (flip.toLowerCase() === 'vertical') {
                        point.x = (actObj.activePoint.endX);
                        point.y = (actObj.activePoint.startY);
                    }
                }
                break;
            case 90:
                if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === 'horizontal') {
                    if (flip.toLowerCase() === 'horizontal') {
                        point.x = (actObj.activePoint.endX);
                        point.y = (actObj.activePoint.endY);
                    }
                    else if (flip.toLowerCase() === 'vertical') {
                        point.x = (actObj.activePoint.startX);
                        point.y = (actObj.activePoint.endY);
                    }
                }
                else {
                    if (flip.toLowerCase() === 'horizontal') {
                        point.x = (actObj.activePoint.startX);
                        point.y = (actObj.activePoint.endY);
                    }
                    else if (flip.toLowerCase() === 'vertical') {
                        point.x = (actObj.activePoint.startX);
                        point.y = (actObj.activePoint.startY);
                    }
                }
                break;
            case 180:
                if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === 'horizontal') {
                    if (flip.toLowerCase() === 'horizontal') {
                        point.x = (actObj.activePoint.startX);
                        point.y = (actObj.activePoint.startY);
                    }
                    else if (flip.toLowerCase() === 'vertical') {
                        point.x = (actObj.activePoint.startX);
                        point.y = (actObj.activePoint.startY);
                    }
                }
                else {
                    if (flip.toLowerCase() === 'horizontal') {
                        point.x = (actObj.activePoint.startX);
                        point.y = (actObj.activePoint.startY);
                    }
                    else if (flip.toLowerCase() === 'vertical') {
                        point.x = (actObj.activePoint.startX);
                        point.y = (actObj.activePoint.endY);
                    }
                }
                break;
            case 270:
                if (actObj.flipObjColl[0] && actObj.flipObjColl[0].toLowerCase() === 'horizontal') {
                    if (flip.toLowerCase() === 'horizontal') {
                        point.x = (actObj.activePoint.startX);
                        point.y = (actObj.activePoint.startY);
                    }
                    else if (flip.toLowerCase() === 'vertical') {
                        point.x = (actObj.activePoint.endX);
                        point.y = (actObj.activePoint.startY);
                    }
                }
                else {
                    if (flip.toLowerCase() === 'horizontal') {
                        point.x = (actObj.activePoint.endX);
                        point.y = (actObj.activePoint.startY);
                    }
                    else if (flip.toLowerCase() === 'vertical') {
                        point.x = (actObj.activePoint.endX);
                        point.y = (actObj.activePoint.endY);
                    }
                }
                break;
        }
        return point;
    }
    selectedText() {
        const start = this.parent.textArea.selectionStart;
        const finish = this.parent.textArea.selectionEnd;
        return this.parent.textArea.value.substring(start, finish);
    }
    panObjColl(xDiff, yDiff, panRegion) {
        const parent = this.parent;
        for (let i = 0, len = parent.objColl.length; i < len; i++) {
            let currObj = parent.objColl[i];
            if (panRegion === '' || panRegion === 'vertical') {
                currObj.activePoint.startX += xDiff;
                currObj.activePoint.endX += xDiff;
                if (currObj.rotationCirclePointColl) {
                    currObj.rotationCirclePointColl.x += xDiff;
                }
                if (currObj.shape === 'path') {
                    for (let l = 0, len = currObj.pointColl.length; l < len; l++) {
                        currObj.pointColl[l].x += xDiff;
                    }
                }
            }
            else {
                currObj.activePoint.startX -= xDiff;
                currObj.activePoint.endX -= xDiff;
                if (currObj.rotationCirclePointColl) {
                    currObj.rotationCirclePointColl.x -= xDiff;
                }
                if (currObj.shape === 'path') {
                    for (let l = 0, len = currObj.pointColl.length; l < len; l++) {
                        currObj.pointColl[l].x -= xDiff;
                    }
                }
            }
            if (panRegion === '' || panRegion === 'horizontal') {
                currObj.activePoint.startY += yDiff;
                currObj.activePoint.endY += yDiff;
                if (currObj.rotationCirclePointColl) {
                    currObj.rotationCirclePointColl.y += yDiff;
                }
                if (currObj.shape === 'path') {
                    for (let l = 0; l < currObj.pointColl.length; l++) {
                        currObj.pointColl[l].y += yDiff;
                    }
                }
            }
            else {
                currObj.activePoint.startY -= yDiff;
                currObj.activePoint.endY -= yDiff;
                if (currObj.rotationCirclePointColl) {
                    currObj.rotationCirclePointColl.y -= yDiff;
                }
                if (currObj.shape === 'path') {
                    for (let l = 0; l < currObj.pointColl.length; l++) {
                        currObj.pointColl[l].y -= yDiff;
                    }
                }
            }
            currObj = this.updateWidthHeight(currObj);
            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: currObj.activePoint,
                    obj: currObj } });
            if (currObj.shape === 'line' || currObj.shape === 'arrow') {
                currObj.pointColl = this.getLinePoints(currObj.activePoint.startX, currObj.activePoint.startY, currObj.activePoint.endX, currObj.activePoint.endY);
                for (let j = 0, len = currObj.pointColl.length; j < len; j++) {
                    currObj.pointColl[j].ratioX =
                        (currObj.pointColl[j].x - parent.img.destLeft) / parent.img.destWidth;
                    currObj.pointColl[j].ratioY =
                        (currObj.pointColl[j].y - parent.img.destTop) / parent.img.destHeight;
                }
            }
            const temp = this.lowerContext.filter;
            this.lowerContext.filter = 'none';
            this.apply(currObj.shape, currObj);
            this.lowerContext.filter = temp;
            this.refreshActiveObj();
        }
    }
    updateFontStyles(isTextBox) {
        const parent = this.parent;
        this.upperContext.strokeStyle = parent.activeObj.strokeSettings.strokeColor;
        this.upperContext.fillStyle = parent.activeObj.strokeSettings.strokeColor;
        let textStyle = '';
        if (parent.activeObj.textSettings.bold) {
            textStyle = 'bold ';
        }
        if (parent.activeObj.textSettings.italic) {
            textStyle = 'italic ';
        }
        if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
            textStyle = 'italic bold ';
        }
        const fontSize = isTextBox ? parseFloat(parent.textArea.style.fontSize) : parent.activeObj.textSettings.fontSize;
        const fontFamily = parent.textArea.style.display === 'block' ? parent.textArea.style.fontFamily : parent.activeObj.textSettings.fontFamily;
        this.upperContext.font = textStyle + fontSize + 'px' + ' ' + fontFamily;
    }
    applyFontStyle(item) {
        const parent = this.parent;
        this.pushActItemIntoObj();
        const objColl = extend([], parent.objColl, [], true);
        parent.objColl.pop();
        if (parent.textArea.style.display === 'none') {
            this.updateFontRatio(parent.activeObj);
        }
        else {
            this.updateFontRatio(parent.activeObj, true);
        }
        switch (item) {
            case 'default':
                this.updateFontStyle(item, objColl, 'normal', 'normal');
                break;
            case 'bold':
                this.updateFontStyle(item, objColl, 'bold', 'normal');
                break;
            case 'italic':
                this.updateFontStyle(item, objColl, 'normal', 'italic');
                break;
            case 'bolditalic':
                this.updateFontStyle(item, objColl, 'bold', 'italic');
                break;
        }
    }
    updateFontStyle(item, objColl, fontWeight, fontStyle) {
        const parent = this.parent;
        if (parent.textArea.style.display === 'block') {
            const width = this.getTextAreaWidth(item);
            parent.textArea.style.width = width + 'px';
            parent.textArea.style.fontWeight = fontWeight;
            parent.textArea.style.fontStyle = fontStyle;
            this.updateObjColl(item, objColl);
        }
        else {
            this.textSettings.bold = parent.activeObj.textSettings.bold = fontWeight === 'normal' ? false : true;
            this.textSettings.italic = parent.activeObj.textSettings.italic = fontStyle === 'normal' ? false : true;
            this.redrawText();
            parent.notify('undo-redo', { prop: 'updateUrObj', onPropertyChange: false, value: { objColl: objColl } });
        }
    }
    updateArrowRatio(obj) {
        const parent = this.parent;
        const object = { arrowDimension: null };
        parent.notify('draw', { prop: 'getArrowDimension', onPropertyChange: false, value: { obj: object } });
        let length;
        if (Math.abs(obj.activePoint.width) > Math.abs(obj.activePoint.height)) {
            length = Math.abs(obj.activePoint.width);
        }
        else {
            length = Math.abs(obj.activePoint.height);
        }
        let dimension;
        const dimensions = ['bar', 'arrow', 'arrowSolid', 'circle', 'square'];
        for (dimension of dimensions) {
            const ratioX = length / object['arrowDimension'][dimension]['width'];
            const ratioY = length / object['arrowDimension'][dimension]['height'];
            object['arrowDimension'][dimension]['ratioX'] = ratioX;
            object['arrowDimension'][dimension]['ratioY'] = ratioY;
        }
    }
    updateArrowSize(obj) {
        const object = { arrowDimension: null };
        this.parent.notify('draw', { prop: 'getArrowDimension', onPropertyChange: false, value: { obj: object } });
        let length;
        if (Math.abs(obj.activePoint.width) > Math.abs(obj.activePoint.height)) {
            length = Math.abs(obj.activePoint.width);
        }
        else {
            length = Math.abs(obj.activePoint.height);
        }
        let dimension;
        const dimensions = ['bar', 'arrow', 'arrowSolid', 'circle', 'square'];
        for (dimension of dimensions) {
            const ratioX = object['arrowDimension'][dimension]['ratioX'];
            const ratioY = object['arrowDimension'][dimension]['ratioY'];
            object['arrowDimension'][dimension]['width'] = length / ratioX;
            object['arrowDimension'][dimension]['height'] = length / ratioY;
        }
    }
    updateFontRatio(obj, isTextArea) {
        const parent = this.parent;
        const text = this.getMaxText(isTextArea);
        const width = this.upperContext.measureText(text).width +
            parent.activeObj.textSettings.fontSize * 0.5;
        const height = (parent.activeObj.textSettings.fontSize + parent.activeObj.textSettings.fontSize * 0.25);
        const degree = this.getRotDegOfShape(obj);
        if (isNullOrUndefined(isTextArea)) {
            if (degree === 0 || Math.abs(degree) === 180) {
                obj.textSettings.fontRatio = width / obj.textSettings.fontSize;
            }
            else {
                obj.textSettings.fontRatio = height / obj.textSettings.fontSize;
            }
        }
        else if (isTextArea) {
            obj.textSettings.fontRatio = width / parseFloat(parent.textArea.style.fontSize);
        }
    }
    updateFontSize(obj) {
        const degree = this.getRotDegOfShape(obj);
        if (degree === 0 || Math.abs(degree) === 180) {
            obj.textSettings.fontSize = (obj.activePoint.width / obj.textSettings.fontRatio);
        }
        else {
            obj.textSettings.fontSize = (obj.activePoint.height / obj.textSettings.fontRatio);
        }
    }
    updateObjColl(item, objColl) {
        const parent = this.parent;
        const prevCropObj = extend({}, parent.cropObj, {}, true);
        const object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        prevObj.objColl = objColl;
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        const tempBold = parent.activeObj.textSettings.bold;
        const tempItalic = parent.activeObj.textSettings.italic;
        switch (item) {
            case 'default':
                parent.activeObj.textSettings.bold = false;
                parent.activeObj.textSettings.italic = false;
                break;
            case 'bold':
                parent.activeObj.textSettings.bold = true;
                parent.activeObj.textSettings.italic = false;
                break;
            case 'italic':
                parent.activeObj.textSettings.bold = false;
                parent.activeObj.textSettings.italic = true;
                break;
            case 'bolditalic':
                parent.activeObj.textSettings.bold = true;
                parent.activeObj.textSettings.italic = true;
                break;
        }
        parent.objColl.push(parent.activeObj);
        parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
            value: { operation: 'textAreaCustomization', previousObj: prevObj, previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj, previousText: null,
                currentText: null, previousFilter: null, isCircleCrop: null } });
        parent.objColl.pop();
        parent.activeObj.textSettings.bold = tempBold;
        parent.activeObj.textSettings.italic = tempItalic;
    }
    pushActItemIntoObj() {
        if (this.parent.textArea.style.display === 'none') {
            this.parent.objColl.push(this.parent.activeObj);
        }
        else {
            const temp = extend({}, this.parent.activeObj, {}, true);
            this.parent.notify('selection', { prop: 'setTextBoxStylesToActObj', onPropertyChange: false });
            this.parent.objColl.push(this.parent.activeObj);
            this.parent.activeObj = temp;
        }
    }
    clearActObj() {
        if (this.parent.textArea.style.display === 'none') {
            this.refreshActiveObj();
            this.applyActObj();
            this.refreshActiveObj();
            this.parent.currObjType.isCustomCrop = false;
        }
    }
    refreshActiveObj() {
        this.parent.activeObj = {};
        this.parent.activeObj.activePoint = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
        this.parent.activeObj.triangle = [];
        this.parent.activeObj.triangleRatio = [];
        this.parent.activeObj.flipObjColl = [];
        this.parent.activeObj.strokeSettings = this.strokeSettings;
        this.parent.activeObj.textSettings = this.textSettings;
        this.parent.activeObj.rotatedAngle = 0;
    }
    applyActObj(isMouseDown) {
        let isActObj = false;
        if (this.parent.activeObj.shape !== undefined && this.parent.activeObj.shape === 'text' && this.parent.activeObj.keyHistory === '') {
            this.refreshActiveObj();
            this.upperContext.clearRect(0, 0, this.parent.upperCanvas.width, this.parent.upperCanvas.height);
        }
        else {
            let splitWords;
            let isCropSelection = false;
            if (this.parent.activeObj.shape !== undefined) {
                splitWords = this.parent.activeObj.shape.split('-');
            }
            if (splitWords === undefined && this.parent.currObjType.isCustomCrop) {
                isCropSelection = true;
            }
            else if (splitWords !== undefined && splitWords[0] === 'crop') {
                isCropSelection = true;
            }
            if (this.parent.activeObj.shape && !isCropSelection && this.parent.activeObj.shape !== 'shape') {
                for (let i = 0; i < this.parent.objColl.length; i++) {
                    if (JSON.stringify(this.parent.activeObj) === JSON.stringify(this.parent.objColl[i])) {
                        isActObj = true;
                        break;
                    }
                }
                if (!isActObj) {
                    if (isNullOrUndefined(this.parent.activeObj.currIndex)) {
                        this.parent.activeObj.currIndex = 'shape_' + (this.parent.objColl.length + 1);
                    }
                    this.updImgRatioForActObj();
                    const splitWords = this.parent.activeObj.currIndex.split('_');
                    let tempObjColl = this.parent.objColl.splice(0, parseInt(splitWords[1], 10) - 1);
                    tempObjColl.push(extend({}, this.parent.activeObj, {}, true));
                    for (let i = 0; i < this.parent.objColl.length; i++) {
                        tempObjColl.push(this.parent.objColl[i]);
                    }
                    this.parent.objColl = tempObjColl;
                    tempObjColl = [];
                    this.refreshActiveObj();
                    this.lowerContext.clearRect(0, 0, this.parent.lowerCanvas.width, this.parent.lowerCanvas.height);
                    this.parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
                    this.parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
                    this.parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
                    this.parent.currObjType.shape = '';
                    this.refreshActiveObj();
                    if (this.parent.isCircleCrop) {
                        this.parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                            value: { context: this.lowerContext, isSave: null, isFlip: null } });
                    }
                    if (!isBlazor()) {
                        this.parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
                    }
                    else {
                        this.parent.updateToolbar(this.parent.element, 'destroyQuickAccessToolbar');
                    }
                    if (isNullOrUndefined(isMouseDown)) {
                        this.parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                        this.parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false, value: { prevActObj: null } });
                    }
                }
            }
        }
    }
    alignTextAreaIntoCanvas() {
        const parent = this.parent;
        const letters = parent.textArea.value;
        parent.textArea.value = '';
        for (let i = 0, len = letters.length; i < len; i++) {
            parent.textArea.value += letters[i];
            parent.textArea.style.height = 'auto';
            parent.textArea.style.height = parent.textArea.scrollHeight + 'px';
            this.setTextBoxWidth();
        }
    }
    transformTextArea() {
        const parent = this.parent;
        if (parent.activeObj.shape === 'text') {
            parent.textArea.style.transformOrigin = '0 0';
            const rotatedDegree = parent.activeObj.rotatedAngle * (180 / Math.PI);
            let scale = '';
            let degree = this.getRotDegOfShape(parent.activeObj);
            if (parent.activeObj.flipObjColl.length > 0) {
                // need to add scale value according to length.
                for (let i = 0; i < parent.activeObj.flipObjColl.length; i++) {
                    if (degree !== 0 && degree % 90 === 0 && degree !== 180) {
                        scale += parent.activeObj.flipObjColl[i].toLowerCase() === 'horizontal' ? 'scale(1, -1)' :
                            'scale(-1, 1)';
                    }
                    else {
                        scale += parent.activeObj.flipObjColl[i].toLowerCase() === 'horizontal' ? 'scale(-1, 1)' :
                            'scale(1, -1)';
                    }
                    degree += rotatedDegree;
                    if (parent.activeObj.flipObjColl[i].toLowerCase() === 'horizontal') {
                        parent.textArea.style.transform = 'rotate(' + degree + 'deg)' + scale;
                    }
                    else if (parent.activeObj.flipObjColl[i].toLowerCase() === 'vertical') {
                        parent.textArea.style.transform = 'rotate(' + degree + 'deg)' + scale;
                    }
                }
            }
            else {
                degree += rotatedDegree;
                parent.textArea.style.transform = 'rotate(' + degree + 'deg)';
            }
        }
    }
    getTextAreaWidth(item) {
        const parent = this.parent;
        const tempBold = parent.activeObj.textSettings.bold;
        const tempItalic = parent.activeObj.textSettings.italic;
        switch (item) {
            case 'default':
                parent.activeObj.textSettings.bold = false;
                parent.activeObj.textSettings.italic = false;
                break;
            case 'bold':
                parent.activeObj.textSettings.bold = true;
                parent.activeObj.textSettings.italic = false;
                break;
            case 'italic':
                parent.activeObj.textSettings.bold = false;
                parent.activeObj.textSettings.italic = true;
                break;
            case 'bolditalic':
                parent.activeObj.textSettings.bold = true;
                parent.activeObj.textSettings.italic = true;
                break;
        }
        this.updateFontStyles();
        let width;
        if (parent.textArea.style.display === 'none') {
            width = this.upperContext.measureText(parent.activeObj.keyHistory).width +
                parent.activeObj.textSettings.fontSize * 0.5;
        }
        else {
            width = this.upperContext.measureText(parent.textArea.value).width +
                parent.activeObj.textSettings.fontSize * 0.5;
        }
        parent.activeObj.textSettings.bold = tempBold;
        parent.activeObj.textSettings.italic = tempItalic;
        return width;
    }
    getObjDetails(obj) {
        const parent = this.parent;
        const shapeDetails = {};
        shapeDetails.id = obj.currIndex;
        shapeDetails.type = parent.toPascalCase(obj.shape);
        shapeDetails.startX = obj.activePoint.startX;
        shapeDetails.startY = obj.activePoint.startY;
        switch (obj.shape) {
            case 'rectangle':
                shapeDetails.width = obj.activePoint.width;
                shapeDetails.height = obj.activePoint.height;
                shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
                shapeDetails.fillColor = obj.strokeSettings.fillColor;
                shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
                break;
            case 'ellipse':
                shapeDetails.radius = obj.activePoint.width / 2;
                shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
                shapeDetails.fillColor = obj.strokeSettings.fillColor;
                shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
                break;
            case 'line':
            case 'arrow':
                shapeDetails.length = obj.activePoint.width;
                shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
                shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
                break;
            case 'text':
                shapeDetails.text = obj.keyHistory;
                shapeDetails.fontSize = obj.textSettings.fontSize;
                shapeDetails.color = obj.strokeSettings.strokeColor;
                shapeDetails.fontStyle = [];
                if (obj.textSettings.bold) {
                    shapeDetails.fontStyle.push('bold');
                }
                if (obj.textSettings.italic) {
                    shapeDetails.fontStyle.push('italic');
                }
                break;
            case 'path':
                shapeDetails.strokeColor = obj.strokeSettings.strokeColor;
                shapeDetails.strokeWidth = obj.strokeSettings.strokeWidth;
                break;
        }
        return shapeDetails;
    }
    getFreehandDrawDetails(index) {
        const parent = this.parent;
        const shapeDetails = {};
        shapeDetails.id = parent.pointColl[index].id;
        shapeDetails.type = ShapeType.FreehandDraw;
        shapeDetails.points = extend([], parent.pointColl[index].points);
        shapeDetails.strokeColor = parent.pointColl[index].strokeColor;
        shapeDetails.strokeWidth = parent.pointColl[index].strokeWidth;
        return shapeDetails;
    }
    getShapeSetting(id, obj) {
        const parent = this.parent;
        let shapeDetails;
        if (!parent.disabled && parent.isImageLoaded) {
            this.applyActObj();
            if (id.split('_')[0] === 'shape') {
                let obj;
                for (let i = 0, len = parent.objColl.length; i < len; i++) {
                    if (parent.objColl[i].currIndex === id) {
                        obj = extend({}, parent.objColl[i], {}, true);
                        break;
                    }
                }
                shapeDetails = this.getObjDetails(obj);
            }
            else if (id.split('_')[0] === 'pen') {
                shapeDetails = this.getFreehandDrawDetails(parseInt(id.split('_')[1], 10) - 1);
            }
        }
        obj['shapeDetails'] = shapeDetails;
    }
    getShapeSettings(obj) {
        const parent = this.parent;
        const shapeDetailsColl = [];
        if (!parent.disabled && parent.isImageLoaded) {
            this.applyActObj();
            for (let i = 0, len = parent.objColl.length; i < len; i++) {
                const shapeDetails = this.getObjDetails(parent.objColl[i]);
                shapeDetailsColl.push(shapeDetails);
            }
            for (let i = 0; i < parent.freehandCounter; i++) {
                const shapeDetails = this.getFreehandDrawDetails(i);
                shapeDetailsColl.push(shapeDetails);
            }
        }
        obj['shapeDetailsColl'] = shapeDetailsColl;
    }
    isPointsInRange(x, y, obj) {
        let inRange = false;
        if (!isNullOrUndefined(x) && !isNullOrUndefined(y) && x >= this.parent.img.destLeft && y >= this.parent.img.destTop &&
            x <= this.parent.img.destLeft + this.parent.img.destWidth && y <= this.parent.img.destTop + this.parent.img.destHeight) {
            inRange = true;
        }
        obj['inRange'] = inRange;
    }
    alignRotateFlipColl(collection, isRotateFlipCollection, obj) {
        collection = this.popForDefaultTransformedState(collection);
        collection = this.popForDefaultFlipState(collection);
        collection = this.popForDefaultRotateState(collection);
        if (collection.length === 0 && isRotateFlipCollection) {
            this.parent.transform.degree = 0;
            this.parent.transform.currFlipState = '';
        }
        obj['collection'] = collection;
        return collection;
    }
    popForDefaultTransformedState(collection) {
        let rotateRight = 0;
        let rotateleft = 0;
        let horizontal = 0;
        let vertical = 0;
        for (let i = 0; i < collection.length; i++) {
            if (collection[i] === 90 || collection[i] === 'rotateRight') {
                rotateRight++;
                rotateleft = 0;
                horizontal = 0;
                vertical = 0;
                if (rotateRight === 4) {
                    collection.pop();
                    collection.pop();
                    collection.pop();
                    collection.pop();
                }
            }
            else if (collection[i] === -90 || collection[i] === 'rotateLeft') {
                rotateleft++;
                rotateRight = 0;
                horizontal = 0;
                vertical = 0;
                if (rotateleft === 4) {
                    collection.pop();
                    collection.pop();
                    collection.pop();
                    collection.pop();
                }
            }
            else if (collection[i] === 'horizontal' || collection[i] === 'Horizontal'
                || collection[i] === 'horizontalflip') {
                horizontal++;
                rotateleft = 0;
                rotateRight = 0;
                vertical = 0;
                if (horizontal === 2) {
                    collection.pop();
                    collection.pop();
                }
            }
            else if (collection[i] === 'vertical' || collection[i] === 'Vertical'
                || collection[i] === 'verticalflip') {
                vertical++;
                horizontal = 0;
                rotateleft = 0;
                rotateRight = 0;
                if (vertical === 2) {
                    collection.pop();
                    collection.pop();
                }
            }
        }
        return collection;
    }
    popForDefaultFlipState(collection) {
        for (let i = 0; i < collection.length; i++) {
            if (!isNullOrUndefined(collection[i + 3])) {
                if ((collection[i] === 'horizontal' || collection[i] === 'Horizontal'
                    || collection[i] === 'horizontalFlip')
                    && (collection[i + 1] === 'vertical' || collection[i + 1] === 'Vertical'
                        || collection[i] === 'verticalFlip') &&
                    (collection[i + 2] === 'horizontal' || collection[i + 2] === 'Horizontal'
                        || collection[i] === 'horizontalFlip') &&
                    (collection[i + 3] === 'vertical' || collection[i + 3] === 'Vertical'
                        || collection[i] === 'verticalFlip')) {
                    collection.pop();
                    collection.pop();
                    collection.pop();
                    collection.pop();
                }
                else if ((collection[i] === 'vertical' || collection[i] === 'Vertical'
                    || collection[i] === 'verticalFlip')
                    && (collection[i + 1] === 'horizontal' || collection[i + 1] === 'Horizontal'
                        || collection[i + 1] === 'horizontalFlip') &&
                    (collection[i + 2] === 'vertical' || collection[i + 2] === 'Vertical' || collection[i] === 'verticalFlip') &&
                    (collection[i + 3] === 'horizontal' || collection[i + 3] === 'Horizontal' || collection[i] === 'horizontalFlip')) {
                    collection.pop();
                    collection.pop();
                    collection.pop();
                    collection.pop();
                }
            }
        }
        return collection;
    }
    popForDefaultRotateState(collection) {
        for (let i = 0; i < collection.length; i++) {
            if (!isNullOrUndefined(collection[i + 1])) {
                if ((collection[i] === 90 || collection[i] === 'rotateRight') &&
                    (collection[i + 1] === -90 || collection[i] === 'rotateLeft')) {
                    collection.pop();
                    collection.pop();
                }
                else if ((collection[i] === -90 || collection[i] === 'rotateLeft') &&
                    (collection[i + 1] === 90 || collection[i] === 'rotateRight')) {
                    collection.pop();
                    collection.pop();
                }
            }
        }
        return collection;
    }
    selectShape(id, obj) {
        const parent = this.parent;
        let isSelected = false;
        if (!parent.disabled && parent.isImageLoaded) {
            this.applyActObj();
            if (id.split('_')[0] === 'shape') {
                let obj;
                for (let i = 0, len = parent.objColl.length; i < len; i++) {
                    if (parent.objColl[i].currIndex === id) {
                        obj = extend({}, parent.objColl[i], {}, true);
                        break;
                    }
                }
                if (isNullOrUndefined(obj)) {
                    isSelected = false;
                }
                else {
                    isSelected = true;
                    parent.activeObj = obj;
                    const object = { canvasFilter: null };
                    parent.notify('toolbar', { prop: 'getCanvasFilter', onPropertyChange: false, value: { obj: object } });
                    this.lowerContext.filter = object['canvasFilter'];
                    parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,
                        value: { obj: parent.activeObj } });
                    if (!isBlazor()) {
                        if (parent.activeObj.shape === 'text') {
                            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'text',
                                    isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                        }
                        else if (parent.activeObj.shape === 'pen') {
                            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'pen',
                                    isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                        }
                        else {
                            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                                    isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                        }
                        parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
                        parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
                    }
                    else {
                        parent.updateToolbar(parent.element, parent.activeObj.shape);
                        if (parent.activeObj.shape === 'path') {
                            parent.updateToolbar(this.parent.element, 'path', 'pathQuickAccessToolbar');
                        }
                        else {
                            parent.updateToolbar(parent.element, 'quickAccessToolbar', parent.activeObj.shape);
                        }
                    }
                }
            }
            else if (id.split('_')[0] === 'pen') {
                const object = { bool: false };
                parent.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: object } });
                if (object['bool']) {
                    parent.okBtn();
                }
                const obj = { isIndex: false };
                parent.notify('freehand-draw', { prop: 'isFHDIdx', value: { index: parseInt(id.split('_')[1], 10) - 1, obj: obj } });
                if (obj['isIndex']) {
                    isSelected = true;
                    parent.notify('freehand-draw', { prop: 'selectFhd', value: { id: id } });
                    if (!isBlazor()) {
                        parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: true } });
                        parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
                    }
                    else {
                        parent.updateToolbar(parent.element, 'pen');
                        parent.updateToolbar(parent.element, 'quickAccessToolbar', 'pen');
                    }
                }
                else {
                    isSelected = false;
                }
            }
        }
        obj['isSelected'] = isSelected;
    }
    deleteShape(id) {
        const parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            this.applyActObj();
            if (id.split('_')[0] === 'shape') {
                for (let i = 0, len = parent.objColl.length; i < len; i++) {
                    if (parent.objColl[i].currIndex === id) {
                        parent.objColl.splice(i, 1);
                        break;
                    }
                }
            }
            else if (id.split('_')[0] === 'pen') {
                parent.notify('freehand-draw', { prop: 'handle-freehand-draw', value: { id: id } });
            }
            const object = { canvasFilter: null };
            parent.notify('toolbar', { prop: 'getCanvasFilter', onPropertyChange: false, value: { obj: object } });
            this.lowerContext.filter = object['canvasFilter'];
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            }
            else {
                parent.updateToolbar(parent.element, 'imageLoaded');
            }
        }
    }
    getMaxText(isTextBox, text, obj) {
        if (isNullOrUndefined(text)) {
            text = isTextBox ? this.parent.textArea.value : this.parent.activeObj.keyHistory;
        }
        let maxi;
        const rows = text.split('\n');
        let maxStr = rows[0].length;
        let maxText = rows[0];
        for (let i = 1; i < rows.length; i++) {
            maxi = rows[i].length;
            if (maxi > maxStr) {
                maxText = rows[i];
                maxStr = maxi;
            }
        }
        if (obj) {
            obj['maxText'] = maxText;
        }
        return maxText;
    }
    getLinePoints(x1, y1, x2, y2) {
        let points = [];
        let i;
        let j;
        if (x1 === x2) {
            if (y1 < y2) {
                i = [x1, y1];
                j = [x2, y2];
            }
            else {
                j = [x1, y1];
                i = [x2, y2];
            }
            const m = this.getSlope(i, j, true);
            const b = this.getIntercept(i, m);
            for (let y = i[1]; y <= j[1]; y++) {
                const x = m * y + b;
                points.push({ x: x, y: y });
            }
        }
        else {
            if (x1 < x2) {
                i = [x1, y1];
                j = [x2, y2];
            }
            else {
                j = [x1, y1];
                i = [x2, y2];
            }
            const m = this.getSlope(i, j, false);
            const b = this.getIntercept(i, m);
            for (let x = i[0]; x <= j[0]; x++) {
                const y = m * x + b;
                points.push({ x: x, y: y });
            }
        }
        if (Math.floor(x1) === Math.floor(x2) || (points.length < 10 && (y2 - y1 > 10 || y1 - y2 > 10))) {
            points = [];
            const lesserY = Math.min(y1, y2);
            for (let i = 0; i < Math.abs(Math.floor(y2) - Math.floor(y1)); i++) {
                points.push({ x: x1, y: lesserY + i });
            }
            if (points.length > 1) {
                let prev;
                if (isNullOrUndefined(points[points.length - 2])) {
                    prev = { x: 0, y: 0 };
                }
                else {
                    prev = points[points.length - 2];
                }
                const diffX = points[points.length - 1]['x'] - prev.x;
                const diffY = points[points.length - 1]['y'] - prev.y;
                points.push({ x: points[points.length - 1]['x'] + (diffX / 2), y: points[points.length - 1]['y'] + (diffY / 2) });
            }
        }
        else if (Math.floor(y1) === Math.floor(y2) || (points.length < 10 && (x2 - x1 > 10 || x1 - x2 > 10))) {
            points = [];
            const lesserX = Math.min(x1, x2);
            for (let i = 0; i < Math.abs(Math.floor(x2) - Math.floor(x1)); i++) {
                points.push({ x: lesserX + i, y: y1 });
            }
            if (points.length > 1) {
                let prev;
                if (isNullOrUndefined(points[points.length - 2])) {
                    prev = { x: 0, y: 0 };
                }
                else {
                    prev = points[points.length - 2];
                }
                const diffX = points[points.length - 1]['x'] - prev.x;
                const diffY = points[points.length - 1]['y'] - prev.y;
                points.push({ x: points[points.length - 1]['x'] + (diffX / 2), y: points[points.length - 1]['y'] + (diffY / 2) });
            }
        }
        return points;
    }
    getSlope(a, b, isSameAxis) {
        let slope;
        if (isSameAxis) {
            if (a[1] === b[1]) {
                return null;
            }
            slope = (b[0] - a[0]) / (b[1] - a[1]);
        }
        else {
            if (a[0] === b[0]) {
                return null;
            }
            slope = (b[1] - a[1]) / (b[0] - a[0]);
        }
        return slope;
    }
    getIntercept(point, getSlope) {
        if (getSlope === null) {
            return point[0];
        }
        return point[1] - getSlope * point[0];
    }
    setPointCollForShapeRotation(obj) {
        const center = { x: obj.activePoint.startX + (obj.activePoint.width / 2), y: obj.activePoint.startY +
                (obj.activePoint.height / 2) };
        const p1 = { x: Math.cos(obj.rotatedAngle) * (obj.activePoint.startX - center.x) - Math.sin(obj.rotatedAngle) *
                (obj.activePoint.startY - center.y) + center.x,
            y: Math.sin(obj.rotatedAngle) * (obj.activePoint.startX - center.x) + Math.cos(obj.rotatedAngle) *
                (obj.activePoint.startY - center.y) + center.y };
        const p2 = { x: Math.cos(obj.rotatedAngle) * (obj.activePoint.endX - center.x) - Math.sin(obj.rotatedAngle) *
                (obj.activePoint.startY - center.y) + center.x,
            y: Math.sin(obj.rotatedAngle) * (obj.activePoint.endX - center.x) + Math.cos(obj.rotatedAngle) * (obj.activePoint.startY
                - center.y) + center.y };
        const p3 = { x: Math.cos(obj.rotatedAngle) * (obj.activePoint.startX - center.x) - Math.sin(obj.rotatedAngle) *
                (obj.activePoint.endY - center.y) + center.x,
            y: Math.sin(obj.rotatedAngle) * (obj.activePoint.startX - center.x) + Math.cos(obj.rotatedAngle) * (obj.activePoint.endY
                - center.y) + center.y };
        const p4 = { x: Math.cos(obj.rotatedAngle) * (obj.activePoint.endX - center.x) - Math.sin(obj.rotatedAngle) *
                (obj.activePoint.endY - center.y) + center.x,
            y: Math.sin(obj.rotatedAngle) * (obj.activePoint.endX - center.x) + Math.cos(obj.rotatedAngle) * (obj.activePoint.endY
                - center.y) + center.y };
        obj.horTopLinePointColl = this.getLinePoints(p1.x, p1.y, p2.x, p2.y);
        obj.horBottomLinePointColl = this.getLinePoints(p3.x, p3.y, p4.x, p4.y);
        obj.verLeftLinePointColl = this.getLinePoints(p1.x, p1.y, p3.x, p3.y);
        obj.verRightLinePointColl = this.getLinePoints(p2.x, p2.y, p4.x, p4.y);
        obj.verLeftLinePointColl.reverse();
        obj.verRightLinePointColl.reverse();
        // Updating ratio for point collection
        for (let i = 0; i < obj.horTopLinePointColl.length; i++) {
            obj.horTopLinePointColl[i].ratioX = (obj.horTopLinePointColl[i].x -
                this.parent.img.destLeft) / this.parent.img.destWidth;
            obj.horTopLinePointColl[i].ratioY = (obj.horTopLinePointColl[i].y -
                this.parent.img.destTop) / this.parent.img.destHeight;
        }
        for (let i = 0; i < obj.horBottomLinePointColl.length; i++) {
            obj.horBottomLinePointColl[i].ratioX = (obj.horBottomLinePointColl[i].x -
                this.parent.img.destLeft) / this.parent.img.destWidth;
            obj.horBottomLinePointColl[i].ratioY = (obj.horBottomLinePointColl[i].y -
                this.parent.img.destTop) / this.parent.img.destHeight;
        }
        for (let i = 0; i < obj.verLeftLinePointColl.length; i++) {
            obj.verLeftLinePointColl[i].ratioX = (obj.verLeftLinePointColl[i].x -
                this.parent.img.destLeft) / this.parent.img.destWidth;
            obj.verLeftLinePointColl[i].ratioY = (obj.verLeftLinePointColl[i].y -
                this.parent.img.destTop) / this.parent.img.destHeight;
        }
        for (let i = 0; i < obj.verRightLinePointColl.length; i++) {
            obj.verRightLinePointColl[i].ratioX = (obj.verRightLinePointColl[i].x -
                this.parent.img.destLeft) / this.parent.img.destWidth;
            obj.verRightLinePointColl[i].ratioY = (obj.verRightLinePointColl[i].y -
                this.parent.img.destTop) / this.parent.img.destHeight;
        }
        if (this.parent.upperCanvas.style.cursor !== 'move') {
            const object = { rotationCirclePoint: null };
            this.parent.notify('selection', { prop: 'getTransRotationPoint', value: { obj: obj, object: object } });
            const rotationCirclePoint = object['rotationCirclePoint'];
            if (rotationCirclePoint) {
                obj.rotationCirclePointColl = { x: Math.cos(obj.rotatedAngle) * (rotationCirclePoint.x - center.x) -
                        Math.sin(obj.rotatedAngle) * (rotationCirclePoint.y - center.y) + center.x,
                    y: Math.sin(obj.rotatedAngle) * (rotationCirclePoint.x - center.x) + Math.cos(obj.rotatedAngle)
                        * (rotationCirclePoint.y - center.y) + center.y };
                obj.rotationCirclePointColl.ratioX = (obj.rotationCirclePointColl.x - this.parent.img.destLeft) /
                    this.parent.img.destWidth;
                obj.rotationCirclePointColl.ratioY = (obj.rotationCirclePointColl.y - this.parent.img.destTop) /
                    this.parent.img.destHeight;
            }
        }
    }
    getSquarePointForRotatedShape(obj, object) {
        const point = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
        const center = { x: obj.activePoint.startX + (obj.activePoint.width / 2), y: obj.activePoint.startY +
                (obj.activePoint.height / 2) };
        const p1 = { x: Math.cos(obj.rotatedAngle) * (obj.activePoint.startX - center.x) - Math.sin(obj.rotatedAngle)
                * (obj.activePoint.startY - center.y) + center.x,
            y: Math.sin(obj.rotatedAngle) * (obj.activePoint.startX - center.x) + Math.cos(obj.rotatedAngle) * (obj.activePoint.startY
                - center.y) + center.y };
        const p2 = { x: Math.cos(obj.rotatedAngle) * (obj.activePoint.endX - center.x) - Math.sin(obj.rotatedAngle) *
                (obj.activePoint.startY - center.y) + center.x,
            y: Math.sin(obj.rotatedAngle) * (obj.activePoint.endX - center.x) + Math.cos(obj.rotatedAngle) * (obj.activePoint.startY
                - center.y) + center.y };
        const p3 = { x: Math.cos(obj.rotatedAngle) * (obj.activePoint.startX - center.x) - Math.sin(obj.rotatedAngle) *
                (obj.activePoint.endY - center.y) + center.x,
            y: Math.sin(obj.rotatedAngle) * (obj.activePoint.startX - center.x) + Math.cos(obj.rotatedAngle) * (obj.activePoint.endY
                - center.y) + center.y };
        const p4 = { x: Math.cos(obj.rotatedAngle) * (obj.activePoint.endX - center.x) - Math.sin(obj.rotatedAngle) *
                (obj.activePoint.endY - center.y) + center.x,
            y: Math.sin(obj.rotatedAngle) * (obj.activePoint.endX - center.x) + Math.cos(obj.rotatedAngle) *
                (obj.activePoint.endY - center.y) + center.y };
        point.startX = p1.x;
        point.startY = p1.y;
        point.endX = p1.x;
        point.endY = p1.y;
        if (point.startX > p2.x) {
            point.startX = p2.x;
        }
        if (point.startX > p3.x) {
            point.startX = p3.x;
        }
        if (point.startX > p4.x) {
            point.startX = p4.x;
        }
        if (point.startY > p2.y) {
            point.startY = p2.y;
        }
        if (point.startY > p3.y) {
            point.startY = p3.y;
        }
        if (point.startY > p4.y) {
            point.startY = p4.y;
        }
        if (point.endX < p2.x) {
            point.endX = p2.x;
        }
        if (point.endX < p3.x) {
            point.endX = p3.x;
        }
        if (point.endX < p4.x) {
            point.endX = p4.x;
        }
        if (point.endY < p2.y) {
            point.endY = p2.y;
        }
        if (point.endY < p3.y) {
            point.endY = p3.y;
        }
        if (point.endY < p4.y) {
            point.endY = p4.y;
        }
        point.width = point.endX - point.startX;
        point.height = point.endY - point.startY;
        if (object) {
            object['activePoint'] = point;
        }
        return point;
    }
}

class Transform {
    constructor(parent) {
        this.isReverseFlip = false; // True when rotate method is called from iteration
        this.disablePan = false; // auto enable / disable pan while zooming
        this.isReverseRotate = false; // True when rotate method is called from iteration
        this.flipColl = []; // To store flip order
        this.prevZoomValue = 1;
        this.cropDimension = { width: 0, height: 0 };
        this.isPreventSelect = false;
        this.parent = parent;
        this.addEventListener();
    }
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    }
    addEventListener() {
        this.parent.on('transform', this.transform, this);
        this.parent.on('destroyed', this.destroy, this);
    }
    removeEventListener() {
        this.parent.off('transform', this.transform);
        this.parent.off('destroyed', this.destroy);
    }
    transform(args) {
        this.initTransformPvtVar();
        switch (args.prop) {
            case 'rotateImage':
                this.rotateImage(args.value['degree']);
                break;
            case 'flipImage':
                this.flipImage(args.value['direction']);
                break;
            case 'setDestPointsForFlipState':
                this.setDestPointsForFlipState();
                break;
            case 'zoomAction':
                this.zoomAction(args.value['zoomFactor'], args.value['zoomPoint']);
                break;
            case 'disableZoomOutBtn':
                this.disableZoomOutBtn(args.value['isZoomOut']);
                break;
            case 'rotatedFlip':
                this.rotatedFlip();
                break;
            case 'drawPannedImage':
                this.drawPannedImage(args.value['xDiff'], args.value['yDiff']);
                break;
            case 'drawPannImage':
                this.drawPannImage(args.value['point']);
                break;
            case 'performTransformation':
                this.performTransformation(args.value['text']);
                break;
            case 'updateTransform':
                this.updateTransform(args.value['text']);
                break;
            case 'rotatePan':
                this.rotatePan(args.value['isCropSelection'], args.value['isDefaultZoom']);
                break;
            case 'drawRotatedImage':
                this.drawRotatedImage(args.value['degree']);
                break;
            case 'limitPan':
                this.limitPan();
                break;
            case 'updateFlipActiveObj':
                this.updateFlipActiveObj(args.value['panRegion']);
                break;
            case 'resetZoom':
                this.resetZoom();
                break;
            case 'pan':
                this.pan(args.value['value']);
                break;
            case 'zoom':
                this.zoom(args.value['zoomFactor'], args.value['zoomPoint']);
                break;
            case 'setCurrPanRegion':
                this.setCurrPanRegion(args.value['region'], args.value['type'], args.value['obj']);
                break;
            case 'rotate':
                this.rotate(args.value['degree'], args.value['obj']);
                break;
            case 'flip':
                this.flip(args.value['direction']);
                break;
            case 'update':
                this.update();
                break;
            case 'calcMaxDimension':
                this.calcMaxDimension(args.value['width'], args.value['height'], args.value['obj']);
                break;
            case 'updatePanPoints':
                this.updatePanPoints(args.value['panRegion'], args.value['obj']);
                break;
            case 'getPanMove':
                args.value['obj']['panMove'] = this.panMove;
                break;
            case 'setPanMove':
                this.panMove = args.value['point'];
                break;
            case 'getTempPanMove':
                args.value['obj']['tempPanMove'] = this.tempPanMove;
                break;
            case 'setTempPanMove':
                this.tempPanMove = args.value['point'];
                break;
            case 'setReverseFlip':
                this.isReverseFlip = args.value['isReverseFlip'];
                break;
            case 'setDisablePan':
                this.disablePan = args.value['bool'];
                break;
            case 'setCurrDestinationPoint':
                this.currDestPoint = args.value['point'];
                this.currDestPoint.startX -= this.parent.cropObj.totalPannedPoint.x;
                this.currDestPoint.startY -= this.parent.cropObj.totalPannedPoint.y;
                break;
            case 'setReverseRotate':
                this.isReverseRotate = args.value['bool'];
                break;
            case 'getFlipColl':
                args.value['obj']['flipColl'] = this.flipColl;
                break;
            case 'setFlipColl':
                this.flipColl = args.value['flipColl'];
                break;
            case 'getPreviousZoomValue':
                args.value['obj']['previousZoomValue'] = this.prevZoomValue;
                break;
            case 'setPreviousZoomValue':
                this.prevZoomValue = args.value['previousZoomValue'];
                break;
            case 'getCropDimension':
                args.value['obj']['cropDimension'] = this.cropDimension;
                break;
            case 'setCropDimension':
                this.cropDimension.width = args.value['width'];
                this.cropDimension.height = args.value['height'];
                break;
            case 'getPreventSelect':
                args.value['obj']['bool'] = this.isPreventSelect;
                break;
            case 'setPreventSelect':
                this.isPreventSelect = args.value['bool'];
                break;
            case 'reset':
                this.reset();
                break;
        }
    }
    getModuleName() {
        return 'transform';
    }
    initTransformPvtVar() {
        if (this.parent.lowerCanvas) {
            this.lowerContext = this.parent.lowerCanvas.getContext('2d');
        }
        if (this.parent.upperCanvas) {
            this.upperContext = this.parent.upperCanvas.getContext('2d');
        }
    }
    reset() {
        this.zoomBtnHold = null;
        this.tempPanMove = null;
        this.panMove = null;
        this.disablePan = false;
        this.currDestPoint = null;
        this.isReverseRotate = false;
        this.flipColl = [];
        this.transCurrObj = null;
        this.prevZoomValue = 1;
        this.isPreventSelect = false;
    }
    rotateImage(degree) {
        const parent = this.parent;
        const transitionArgs = { cancel: false, previousDegree: parent.transform.degree,
            currentDegree: Math.abs(parent.transform.degree + degree) === 360 ? 0 : parent.transform.degree + degree };
        if (!this.isPreventSelect && isBlazor() && parent.events && parent.events.rotating.hasDelegate === true) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            parent.dotNetRef.invokeMethodAsync('RotateEventAsync', 'OnRotate', transitionArgs).then((args) => {
                this.rotateEvent(args, degree);
            });
        }
        else {
            if (!this.isPreventSelect) {
                parent.trigger('rotating', transitionArgs);
            }
            this.rotateEvent(transitionArgs, degree);
        }
    }
    rotateEvent(transitionArgs, degree) {
        const parent = this.parent;
        if (!transitionArgs.cancel) {
            let prevObj;
            if (isNullOrUndefined(this.transCurrObj)) {
                const object = { currObj: {} };
                parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
                prevObj = object['currObj'];
                prevObj.objColl = extend([], parent.objColl, null, true);
                prevObj.pointColl = extend({}, parent.pointColl, null, true);
                prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
                const selPointCollObj = { selPointColl: null };
                parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                    value: { obj: selPointCollObj } });
                prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            }
            parent.afterCropActions.push(degree === 90 ? 'rotateRight' : 'rotateLeft');
            let splitWords = [];
            let activeObjShape;
            if (parent.activeObj.activePoint && parent.activeObj.shape) {
                if (parent.activeObj.shape !== undefined) {
                    splitWords = parent.activeObj.shape.split('-');
                }
                if (parent.currObjType.isCustomCrop || splitWords[0] === 'crop') {
                    activeObjShape = parent.currObjType.isCustomCrop ? 'custom' : splitWords[1];
                    parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
                    parent.objColl.push(parent.activeObj);
                    parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                }
            }
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: true } });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            this.drawRotatedImage(degree);
            parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
            parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
            if (parent.isCircleCrop) {
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: this.lowerContext, isSave: null, isFlip: null } });
            }
            if (activeObjShape) {
                this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
                parent.objColl.pop();
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
            }
            parent.isUndoRedo = false;
            const obj = { collection: parent.rotateFlipColl };
            parent.notify('shape', { prop: 'alignRotateFlipColl', onPropertyChange: false,
                value: { collection: parent.rotateFlipColl, isRotateFlipCollection: true, obj: obj } });
            parent.rotateFlipColl = obj['collection'];
            if (parent.cropObj.activeObj.shape && !this.isPreventSelect) {
                this.isPreventSelect = true;
                parent.select('custom');
                this.isPreventSelect = false;
                parent.setProperties({ zoomSettings: { zoomFactor: 1 } }, true);
                this.prevZoomValue = parent.zoomSettings.zoomFactor;
            }
        }
    }
    drawRotatedImage(degree) {
        const parent = this.parent;
        if (degree === 0) {
            parent.transform.degree = 0;
        }
        else {
            parent.transform.degree += degree;
        }
        if (Math.abs(parent.transform.degree) === 360) {
            parent.transform.degree = 0;
        }
        parent.notify('draw', { prop: 'setDestPoints', onPropertyChange: false });
        const tempObjColl = extend([], parent.objColl, [], true);
        const tempActiveObj = extend({}, parent.activeObj, {}, true);
        parent.objColl = [];
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        if (!this.isReverseRotate) {
            parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
        }
        this.rotateDegree(degree);
        if (!this.isReverseRotate) {
            parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                value: { type: 'reverse', isPreventDestination: null, isRotatePan: null } });
            parent.rotateFlipColl.push(degree);
        }
        parent.objColl = extend([], tempObjColl, [], true);
        parent.activeObj = extend({}, tempActiveObj, {}, true);
        if (parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
        parent.notify('shape', { prop: 'redrawObj', onPropertyChange: false, value: { degree: degree } });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        if (degree > 0) {
            parent.notify('freehand-draw', { prop: 'rotateFhdColl', onPropertyChange: false });
        }
        else {
            for (let i = 0; i < 3; i++) {
                parent.notify('freehand-draw', { prop: 'rotateFhdColl', onPropertyChange: false });
            }
        }
        parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
            value: { context: this.lowerContext, points: null } });
        this.updateCurrSelectionPoint(degree);
    }
    rotateDegree(degree) {
        const parent = this.parent;
        this.lowerContext.save();
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.lowerContext.translate(parent.lowerCanvas.width / 2, parent.lowerCanvas.height / 2);
        this.lowerContext.rotate(Math.PI / 180 * degree);
        this.lowerContext.translate(-parent.lowerCanvas.width / 2, -parent.lowerCanvas.height / 2);
        const temp = this.lowerContext.filter;
        this.parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        this.lowerContext.drawImage(this.parent.baseImg, this.parent.img.srcLeft, this.parent.img.srcTop, this.parent.img.srcWidth, this.parent.img.srcHeight, this.parent.img.destLeft, this.parent.img.destTop, this.parent.img.destWidth, this.parent.img.destHeight);
        this.lowerContext.filter = temp;
        this.lowerContext.translate(parent.lowerCanvas.width / 2, parent.lowerCanvas.height / 2);
        this.lowerContext.rotate(Math.PI / 180 * -degree);
        this.lowerContext.translate(-parent.lowerCanvas.width / 2, -parent.lowerCanvas.height / 2);
        this.lowerContext.restore();
    }
    updateCurrSelectionPoint(degree) {
        const parent = this.parent;
        if (parent.currSelectionPoint && this.currDestPoint) {
            const activeObj = extend({}, parent.activeObj, {}, true);
            const objColl = extend([], parent.objColl, [], true);
            const srcPoints = { startX: parent.img.srcLeft, startY: parent.img.srcTop, width: parent.img.srcWidth,
                height: parent.img.srcHeight };
            const destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                height: parent.img.destHeight };
            parent.objColl = [];
            parent.objColl.push(extend({}, parent.currSelectionPoint, {}, true));
            if (isNullOrUndefined(parent.objColl[0].imageRatio)) {
                parent.activeObj = parent.objColl[0];
                parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
                parent.objColl[0] = parent.activeObj;
            }
            parent.img.srcLeft = 0;
            parent.img.srcTop = 0;
            parent.img.srcWidth = parent.baseImg.width;
            parent.img.srcHeight = parent.baseImg.height;
            parent.img.destLeft = this.currDestPoint.startX;
            parent.img.destTop = this.currDestPoint.startY;
            parent.img.destWidth = this.currDestPoint.width;
            parent.img.destHeight = this.currDestPoint.height;
            if (typeof (degree) === 'number') {
                parent.notify('draw', { prop: 'setDestPoints', onPropertyChange: false });
                parent.notify('draw', { prop: 'setClientTransDim', onPropertyChange: false,
                    value: { isPreventDimension: null } });
            }
            parent.notify('shape', { prop: 'redrawObj', onPropertyChange: false, value: { degree: degree } });
            parent.currSelectionPoint = extend({}, parent.objColl[0], {}, true);
            this.currDestPoint = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
                height: parent.img.destHeight };
            parent.objColl = objColl;
            parent.activeObj = activeObj;
            parent.img.srcLeft = srcPoints.startX;
            parent.img.srcTop = srcPoints.startY;
            parent.img.srcWidth = srcPoints.width;
            parent.img.srcHeight = srcPoints.height;
            parent.img.destLeft = destPoints.startX;
            parent.img.destTop = destPoints.startY;
            parent.img.destWidth = destPoints.width;
            parent.img.destHeight = destPoints.height;
        }
    }
    flipImage(direction) {
        const parent = this.parent;
        const transitionArgs = { direction: direction, cancel: false,
            previousDirection: parent.toPascalCase(parent.transform.currFlipState) };
        if (!this.isPreventSelect && isBlazor() && parent.events && parent.events.flipping.hasDelegate === true) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            parent.dotNetRef.invokeMethodAsync('FlipEventAsync', 'OnFlip', transitionArgs).then((args) => {
                this.flipEvent(args, direction);
            });
        }
        else {
            if (!this.isPreventSelect) {
                parent.trigger('flipping', transitionArgs);
            }
            this.flipEvent(transitionArgs, direction);
        }
    }
    flipEvent(transitionArgs, direction) {
        const parent = this.parent;
        if (transitionArgs.cancel) {
            return;
        }
        let prevObj;
        if (isNullOrUndefined(this.transCurrObj)) {
            const object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            prevObj = object['currObj'];
            prevObj.objColl = extend([], parent.objColl, null, true);
            prevObj.pointColl = extend({}, parent.pointColl, null, true);
            prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
            const selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        }
        parent.afterCropActions.push(direction.toLowerCase() === 'horizontal' ? 'horizontalflip' : 'verticalflip');
        let splitWords = [];
        let activeObjShape;
        if (parent.activeObj.activePoint) {
            if (parent.activeObj.shape !== undefined) {
                splitWords = parent.activeObj.shape.split('-');
            }
            if (parent.currObjType.isCustomCrop || splitWords[0] === 'crop') {
                activeObjShape = parent.currObjType.isCustomCrop ? 'custom' : splitWords[1];
                parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
                parent.objColl.push(parent.activeObj);
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            }
        }
        parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
            value: { x: null, y: null, isMouseDown: true } });
        parent.clearContext(this.lowerContext);
        parent.clearContext(this.upperContext);
        const tempObjColl = extend([], parent.objColl, [], true);
        const tempActiveObj = extend({}, parent.activeObj, {}, true);
        parent.objColl = [];
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        if (!this.isReverseFlip) {
            parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
        }
        const lowercaseDirection = direction.toLowerCase();
        this.updateFlipState(lowercaseDirection);
        if (lowercaseDirection === 'horizontal') {
            parent.transform.currFlipState = (parent.transform.currFlipState.toLowerCase() === 'horizontal') ? '' : 'horizontal';
        }
        else {
            parent.transform.currFlipState = (parent.transform.currFlipState.toLowerCase() === 'vertical') ? '' : 'vertical';
        }
        const selObj = { isSelected: null };
        parent.notify('draw', { prop: 'getRotatedFlipCropSelection', onPropertyChange: false, value: { bool: selObj } });
        if (selObj['isSelected']) {
            parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
            parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
        }
        const temp = this.lowerContext.filter;
        parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        this.lowerContext.filter = temp;
        parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
        this.updateFlipState(direction.toLowerCase());
        if (!this.isReverseFlip) {
            parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                value: { type: 'reverse', isPreventDestination: null, isRotatePan: null } });
            this.updateFlipColl(direction.toLocaleLowerCase());
            parent.rotateFlipColl.push(direction.toLowerCase());
        }
        if (parent.rotateFlipColl.length === 1) {
            const panObj = { panRegion: '' };
            parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false,
                value: { panObj: panObj } });
            if (panObj['panRegion'] === '') {
                parent.notify('draw', { prop: 'setClientTransDim', onPropertyChange: false,
                    value: { isPreventDimension: null } });
            }
            else {
                this.setDestPointsForFlipState();
            }
        }
        if (parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
        parent.objColl = extend([], tempObjColl, [], true);
        parent.activeObj = extend({}, tempActiveObj, {}, true);
        for (let i = 0, len = parent.objColl.length; i < len; i++) {
            const flipObjColl = parent.objColl[i].flipObjColl;
            if (flipObjColl.length === 0) {
                flipObjColl.push(direction);
            }
            else if (flipObjColl[flipObjColl.length - 1] === direction) {
                flipObjColl.pop();
            }
            else {
                flipObjColl.push(direction);
            }
        }
        parent.notify('shape', { prop: 'redrawObj', onPropertyChange: false, value: { degree: direction.toLowerCase() } });
        const tempFilter = this.lowerContext.filter;
        this.lowerContext.filter = 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
            'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' + 'invert(0%)';
        parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
        if (direction.toLowerCase() === 'horizontal' || direction.toLowerCase() === 'vertical') {
            parent.notify('freehand-draw', { prop: 'flipFHDColl', onPropertyChange: false,
                value: { value: direction.toLowerCase() } });
            parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                value: { context: this.lowerContext, points: null } });
        }
        else {
            parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                value: { context: this.lowerContext, points: null } });
        }
        this.lowerContext.filter = tempFilter;
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        this.updateCurrSelectionPoint(direction.toLowerCase());
        parent.isUndoRedo = false;
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.upperContext } });
        if (parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
        if (activeObjShape) {
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
            parent.objColl.pop();
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
        }
        const obj = { collection: parent.rotateFlipColl };
        parent.notify('shape', { prop: 'alignRotateFlipColl', onPropertyChange: false,
            value: { collection: parent.rotateFlipColl, isRotateFlipCollection: true, obj: obj } });
        parent.rotateFlipColl = obj['collection'];
        if (parent.cropObj.activeObj.shape && !this.isPreventSelect) {
            this.isPreventSelect = true;
            parent.select('custom');
            this.isPreventSelect = false;
            parent.setProperties({ zoomSettings: { zoomFactor: 1 } }, true);
            this.prevZoomValue = parent.zoomSettings.zoomFactor;
        }
    }
    updateFlipState(direction) {
        const degree = this.parent.transform.degree;
        if (direction === 'horizontal') {
            if (degree % 90 === 0 && degree % 180 !== 0) {
                this.verticalFlip();
            }
            else {
                this.horizontalFlip();
            }
        }
        else if (direction === 'vertical') {
            if (degree % 90 === 0 && degree % 180 !== 0) {
                this.horizontalFlip();
            }
            else {
                this.verticalFlip();
            }
        }
    }
    horizontalFlip() {
        this.lowerContext.translate(this.lowerContext.canvas.width, 0);
        this.lowerContext.scale(-1, 1);
        this.upperContext.translate(this.upperContext.canvas.width, 0);
        this.upperContext.scale(-1, 1);
    }
    verticalFlip() {
        this.lowerContext.translate(0, this.lowerContext.canvas.height);
        this.lowerContext.scale(1, -1);
        this.upperContext.translate(0, this.upperContext.canvas.height);
        this.upperContext.scale(1, -1);
    }
    updateFlipColl(direction) {
        if (this.isPreventSelect) {
            return;
        }
        if (this.flipColl.length === 0 || this.flipColl[this.flipColl.length - 1] !== direction) {
            this.flipColl.push(direction);
        }
        else {
            this.flipColl.pop();
        }
        if (this.flipColl.length >= 4) {
            const lastFourItems = this.flipColl.slice(-4);
            if ((lastFourItems[0] === 'horizontal' && lastFourItems[1] === 'vertical' &&
                lastFourItems[2] === 'horizontal' && lastFourItems[3] === 'vertical') ||
                (lastFourItems[0] === 'vertical' && lastFourItems[1] === 'horizontal' &&
                    lastFourItems[2] === 'vertical' && lastFourItems[3] === 'horizontal')) {
                this.flipColl.splice(-4);
            }
        }
    }
    setDestPointsForFlipState() {
        const parent = this.parent;
        const panObj = { panRegion: '' };
        parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false,
            value: { panObj: panObj } });
        if (panObj['panRegion'] !== '') {
            if (panObj['panRegion'] === 'horizontal') {
                parent.img.destLeft = parent.lowerCanvas.clientWidth - (parent.img.destWidth + parent.img.destLeft);
            }
            else if (panObj['panRegion'] === 'vertical') {
                parent.img.destTop = parent.lowerCanvas.clientHeight - (parent.img.destHeight + parent.img.destTop);
            }
            else {
                parent.img.destLeft = parent.lowerCanvas.clientWidth - (parent.img.destWidth + parent.img.destLeft);
                parent.img.destTop = parent.lowerCanvas.clientHeight - (parent.img.destHeight + parent.img.destTop);
            }
        }
    }
    zoomAction(zoomFactor, zoomPoint) {
        const parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            if (parent.zoomSettings.zoomFactor >= parent.zoomSettings.maxZoomFactor && zoomFactor > 0 ||
                (parent.zoomSettings.zoomFactor > parent.zoomSettings.minZoomFactor && zoomFactor < 0 && this.disableZoomOutBtn(true)) ||
                (parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor && zoomFactor < 0)) {
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'zoom-up-handler', onPropertyChange: false });
                }
                return;
            }
            parent.notify('draw', { prop: 'setImageEdited', onPropertyChange: false });
            const tempZoomFactor = zoomFactor;
            zoomFactor = tempZoomFactor > 0 ? 0.1 : -0.1;
            for (let i = 0; i < Math.abs(tempZoomFactor / 0.1); i++) {
                if (this.prevZoomValue === 1) {
                    this.prevZoomValue += zoomFactor > 0 ? zoomFactor * 10 : (zoomFactor * 10) / 10;
                }
                else if (this.prevZoomValue > 1) {
                    this.prevZoomValue += (zoomFactor * 10);
                }
                else if (this.prevZoomValue < 1) {
                    this.prevZoomValue += (zoomFactor * 10) / 10;
                    const powerOften = Math.pow(10, 1);
                    this.prevZoomValue = (Math.round(this.prevZoomValue * powerOften) / powerOften);
                }
            }
            zoomFactor = tempZoomFactor;
            parent.setProperties({ zoomSettings: { zoomFactor: this.prevZoomValue } }, true);
            let splitWords;
            this.tempActiveObj = null;
            this.isShape = false;
            if (parent.activeObj.shape !== undefined) {
                if (parent.activeObj.shape === 'shape') {
                    parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                }
                else {
                    splitWords = parent.activeObj.shape.split('-');
                }
            }
            if (splitWords !== undefined && splitWords[0] === 'crop') {
                this.tempActiveObj = extend({}, parent.activeObj, {}, true);
                parent.isCropTab = true;
            }
            else if (parent.activeObj.shape && splitWords[0] !== 'crop') {
                this.isShape = true;
            }
            const obj = { zoomType: null };
            parent.notify('selection', { prop: 'getZoomType', onPropertyChange: false, value: { obj: obj } });
            if (isNullOrUndefined(zoomPoint)) {
                if (parent.isCropTab && this.tempActiveObj) {
                    zoomPoint = { x: parent.activeObj.activePoint.startX + (parent.activeObj.activePoint.width / 2),
                        y: parent.activeObj.activePoint.startY + (parent.activeObj.activePoint.height / 2) };
                }
                else {
                    zoomPoint = { x: parent.lowerCanvas.clientWidth / 2, y: parent.lowerCanvas.clientHeight / 2 };
                }
                if (obj['zoomType'] === 'MouseWheel' || obj['zoomType'] === 'Pinch') {
                    zoomPoint = { x: parent.zoomSettings.zoomPoint.x, y: parent.zoomSettings.zoomPoint.y };
                }
            }
            const previousZoomFactor = parent.zoomSettings.zoomFactor - (zoomFactor * 10);
            const zoomEventArgs = { zoomPoint: zoomPoint, cancel: false, previousZoomFactor: previousZoomFactor,
                currentZoomFactor: parent.zoomSettings.zoomFactor, zoomTrigger: obj['zoomType'] };
            if (!parent.isCropToolbar && isBlazor() && parent.events && parent.events.zooming.hasDelegate === true) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                parent.dotNetRef.invokeMethodAsync('ZoomEventAsync', 'OnZoom', zoomEventArgs).then((args) => {
                    this.zoomEvent(args, zoomFactor);
                });
            }
            else {
                if (!parent.isCropToolbar) {
                    parent.trigger('zooming', zoomEventArgs);
                }
                this.zoomEvent(zoomEventArgs, zoomFactor);
            }
        }
    }
    zoomEvent(zoomEventArgs, zoomFactor) {
        const parent = this.parent;
        if (zoomEventArgs.cancel) {
            return;
        }
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'close-contextual-toolbar', onPropertyChange: false });
        }
        else if (parent.element.querySelector('.e-contextual-toolbar-wrapper') && !parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.contains('e-hidden')) {
            parent.updateToolbar(parent.element, 'closeContextualToolbar');
        }
        parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
            value: { x: null, y: null, isMouseDown: true } });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        const object = { canvasFilter: this.parent.canvasFilter };
        this.lowerContext.filter = object['canvasFilter'];
        parent.upperCanvas.style.cursor = parent.cursor = 'default';
        let objColl = extend([], parent.objColl, [], true);
        if (!parent.isCropTab) {
            if (parent.transform.degree !== 0) {
                parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                    value: { x: null, y: null, isMouseDown: null } });
                parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
                this.rotatePan(true, true);
            }
            else if (parent.transform.currFlipState !== '') {
                parent.panPoint.totalPannedPoint = { x: 0, y: 0 };
            }
            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
        }
        if (parent.transform.degree === 0) {
            this.drawZoomImgToCanvas(zoomFactor, this.tempActiveObj);
            const panObj = { panRegion: '' };
            parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false,
                value: { panObj: panObj } });
            if (panObj['panRegion'] !== '') {
                parent.notify('crop', { prop: 'setTempFlipPanPoint', onPropertyChange: false, value: { point: parent.panPoint.totalPannedPoint, isAdd: true } });
                objColl = extend([], parent.objColl, [], true);
                parent.objColl = [];
                const destLeft = parent.img.destLeft;
                const destTop = parent.img.destTop;
                this.setDestPointsForFlipState();
                this.rotatedFlip();
                parent.img.destLeft = destLeft;
                parent.img.destTop = destTop;
                parent.objColl = objColl;
                parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
                parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
                parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
            }
            if (parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor && !parent.isCropTab) {
                parent.panPoint.totalPannedPoint = { x: 0, y: 0 };
            }
        }
        else {
            parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
            parent.panPoint.totalPannedClientPoint = { x: 0, y: 0 };
            parent.panPoint.totalPannedInternalPoint = { x: 0, y: 0 };
            this.rotateZoom(zoomFactor);
            const panObj = { panRegion: '' };
            parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false,
                value: { panObj: panObj } });
            if (panObj['panRegion'] !== '') {
                const temp = this.lowerContext.filter;
                this.lowerContext.filter = 'none';
                parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
                parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
                this.lowerContext.filter = temp;
            }
        }
        const powerOften = Math.pow(10, 1);
        if (parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor ||
            (Math.round(parent.transform.zoomFactor * powerOften) / powerOften) === 2) {
            clearInterval(this.zoomBtnHold);
            this.zoomBtnHold = 0;
        }
        const panObj = { panRegion: '' };
        parent.notify('crop', { prop: 'getCurrFlipState', onPropertyChange: false,
            value: { panObj: panObj } });
        if (panObj['panRegion'] === '') {
            const temp = this.lowerContext.filter;
            this.lowerContext.filter = 'none';
            parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
            parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
            this.lowerContext.filter = temp;
        }
        if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        if (this.tempActiveObj) {
            parent.activeObj = extend({}, this.tempActiveObj, {}, true);
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
            if (parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor) {
                parent.currSelectionPoint = null;
            }
        }
        parent.isUndoRedo = false;
        let zoomOut;
        if (!isBlazor()) {
            zoomOut = document.querySelector('#' + parent.element.id + '_zoomOut');
            if (zoomOut && parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor) {
                zoomOut.classList.add('e-disabled');
                zoomOut.parentElement.classList.add('e-overlay');
            }
            else if (zoomOut) {
                zoomOut.classList.remove('e-disabled');
                zoomOut.parentElement.classList.remove('e-overlay');
            }
        }
        else {
            zoomOut = parent.element.querySelector('#zoomout');
            if (zoomOut && parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor) {
                zoomOut.classList.add('e-overlay');
            }
            else if (zoomOut) {
                zoomOut.classList.remove('e-overlay');
            }
        }
        this.autoEnablePan();
        if (this.tempActiveObj) {
            parent.activeObj = extend({}, this.tempActiveObj, {}, true);
        }
        if (parent.activeObj.shape === 'crop-custom') {
            parent.currObjType.isCustomCrop = true;
        }
        const panBtn = parent.element.querySelector('.e-img-pan .e-btn');
        if (panBtn && parent.togglePan) {
            panBtn.classList.add('e-selected-btn');
        }
        else if (panBtn) {
            panBtn.classList.remove('e-selected-btn');
        }
        if (this.isShape) {
            parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], {}, true);
            parent.objColl.pop();
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,
                    points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
                parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
            }
        }
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'enable-disable-btns', onPropertyChange: false });
        }
        else {
            parent.updateToolbar(parent.element, 'enableDisableToolbarBtn');
        }
        parent.notify('selection', { prop: 'setZoomType', onPropertyChange: false, value: { zoomType: 'Toolbar' } });
    }
    disableZoomOutBtn(isZoomOut) {
        const parent = this.parent;
        let isDisabled = false;
        let zoomOut;
        if (!isNullOrUndefined(isZoomOut)) {
            parent.transform.zoomFactor -= 0.1;
        }
        if (!isBlazor()) {
            zoomOut = document.querySelector('#' + parent.element.id + '_zoomOut');
        }
        else {
            zoomOut = this.parent.element.querySelector('#zoomout');
        }
        const destLeft = parent.img.destLeft;
        const destTop = parent.img.destTop;
        const destWidth = parent.img.destWidth;
        const destHeight = parent.img.destHeight;
        if (parent.activeObj.shape) {
            this.setZoomDimension(-0.1, parent.activeObj);
            if (!isNullOrUndefined(zoomOut)) {
                if (parent.img.destLeft > parent.activeObj.activePoint.startX || parent.img.destTop > parent.activeObj.activePoint.startY
                    || parent.img.destLeft + parent.img.destWidth < parent.activeObj.activePoint.endX || parent.img.destTop +
                    parent.img.destHeight < parent.activeObj.activePoint.endY || parent.zoomSettings.zoomFactor ===
                    parent.zoomSettings.minZoomFactor) {
                    if (!isBlazor()) {
                        zoomOut.classList.add('e-disabled');
                        zoomOut.parentElement.classList.add('e-overlay');
                    }
                    else {
                        zoomOut.classList.add('e-overlay');
                    }
                    isDisabled = true;
                }
                else {
                    if (!isBlazor()) {
                        zoomOut.classList.remove('e-disabled');
                        zoomOut.parentElement.classList.remove('e-overlay');
                    }
                    else {
                        zoomOut.classList.remove('e-overlay');
                    }
                    isDisabled = false;
                }
            }
        }
        else {
            this.setZoomDimension(-0.1, null);
        }
        if (!isNullOrUndefined(isZoomOut)) {
            parent.transform.zoomFactor += 0.1;
        }
        parent.img.destLeft = destLeft;
        parent.img.destTop = destTop;
        parent.img.destWidth = destWidth;
        parent.img.destHeight = destHeight;
        return isDisabled;
    }
    drawZoomImgToCanvas(value, selectionObj) {
        const parent = this.parent;
        const powerOften = Math.pow(10, 1);
        if ((Math.round(parent.transform.zoomFactor * powerOften) / powerOften) === 0.1 && value === -0.1) {
            parent.transform.zoomFactor = 0;
        }
        else {
            parent.transform.zoomFactor += value;
        }
        parent.transform[parent.isCropTab ? 'cropZoomFactor' : 'defaultZoomFactor'] = parent.transform.zoomFactor;
        let maxDimension = { width: 0, height: 0 };
        if (parent.isCropTab) {
            maxDimension = this.cropZoom(value, selectionObj);
        }
        else {
            maxDimension = this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight);
            maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
            maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
            parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
            parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height) / 2;
        }
        parent.notify('draw', { prop: 'draw-image-to-canvas', value: { dimension: maxDimension } });
        maxDimension.width = this.cropDimension.width;
        maxDimension.height = this.cropDimension.height;
        maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
        maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
        parent.notify('draw', { prop: 'setZoomCropWidth', value: { width: maxDimension.width, height: maxDimension.height } });
    }
    rotatedFlip() {
        const parent = this.parent;
        this.isReverseFlip = true;
        let tempCurrFlipState = parent.transform.currFlipState;
        const tempFlipColl = this.flipColl;
        const tempObjColl = extend([], parent.objColl, [], true);
        const tempActiveObj = extend({}, parent.activeObj, {}, true);
        this.flipColl = [];
        parent.objColl = [];
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,
            value: { type: 'initial', isPreventDestination: null, context: null, isPreventCircleCrop: null } });
        const temp = this.lowerContext.filter;
        parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        this.lowerContext.filter = temp;
        parent.notify('draw', { prop: 'currTransState', onPropertyChange: false,
            value: { type: 'reverse', isPreventDestination: true, context: null, isPreventCircleCrop: null } });
        if (tempCurrFlipState === '' && parent.transform.currFlipState !== '') {
            tempCurrFlipState = parent.transform.currFlipState;
        }
        parent.transform.currFlipState = tempCurrFlipState;
        this.flipColl = tempFlipColl;
        parent.objColl = extend([], tempObjColl, [], true);
        this.lowerContext.filter = 'none';
        parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
        this.lowerContext.filter = temp;
        if (tempActiveObj.activePoint.width !== 0) {
            parent.activeObj = extend({}, tempActiveObj, {}, true);
        }
        this.isReverseFlip = false;
    }
    rotateZoom(value) {
        const parent = this.parent;
        const powerOften = Math.pow(10, 1);
        if ((Math.round(parent.transform.zoomFactor * powerOften) / powerOften) === 0.1 && value === -0.1) {
            parent.transform.zoomFactor = 0;
        }
        else {
            parent.transform.zoomFactor += value;
        }
        if (parent.isCropTab) {
            parent.transform.cropZoomFactor = parent.transform.zoomFactor;
        }
        else {
            parent.transform.defaultZoomFactor = parent.transform.zoomFactor;
        }
        const tempObjColl = extend([], parent.objColl, [], true);
        const tempActiveObj = extend({}, parent.activeObj, {}, true);
        parent.objColl = [];
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
            value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
        parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: true } });
        parent.notify('draw', { prop: 'setDestPoints', onPropertyChange: false });
        const temp = this.lowerContext.filter;
        parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        this.lowerContext.filter = temp;
        parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: false } });
        parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
            value: { type: 'reverse', isPreventDestination: null, isRotatePan: null } });
        parent.objColl = tempObjColl;
        parent.activeObj = tempActiveObj;
        const maxDimension = { width: this.cropDimension.width, height: this.cropDimension.height };
        maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
        maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
        parent.notify('draw', { prop: 'setZoomCropWidth', value: { width: maxDimension.width, height: maxDimension.height } });
    }
    autoEnablePan() {
        if (this.parent.transform.zoomFactor <= 0) {
            this.parent.togglePan = false;
            this.parent.notify('selection', { prop: 'setDragCanvas', value: { bool: false } });
            this.parent.pan(false);
            this.disablePan = false;
        }
        else {
            this.parent.pan(!this.disablePan);
        }
    }
    cropZoom(value, selectionObj) {
        const parent = this.parent;
        let destLeft = parent.img.destLeft;
        let destTop = parent.img.destTop;
        let maxDimension = { width: 0, height: 0 };
        if (parent.img.srcLeft === 0 || parent.img.srcTop === 0) {
            if (isNullOrUndefined(selectionObj)) {
                maxDimension = this.setZoomDimension(value, null);
            }
            else {
                maxDimension = this.setZoomDimension(value, selectionObj);
            }
        }
        else {
            if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
                maxDimension = this.calcMaxDimension(parent.img.srcHeight, parent.img.srcWidth);
            }
            else {
                maxDimension = this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight);
            }
            maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
            maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
        }
        parent.img.destLeft = destLeft - ((maxDimension.width - parent.img.destWidth) / 2);
        parent.img.destTop = destTop - ((maxDimension.height - parent.img.destHeight) / 2);
        destLeft = parent.img.destLeft;
        destTop = parent.img.destTop;
        if (selectionObj) {
            if (parent.img.destLeft > selectionObj.activePoint.startX) {
                parent.img.destLeft = selectionObj.activePoint.startX;
                if (parent.transform.degree === 0) {
                    parent.panPoint.totalPannedPoint.x -= (destLeft - parent.img.destLeft);
                }
            }
            if (parent.img.destTop > selectionObj.activePoint.startY) {
                parent.img.destTop = selectionObj.activePoint.startY;
                if (parent.transform.degree === 0) {
                    parent.panPoint.totalPannedPoint.y -= (destTop - parent.img.destTop);
                }
            }
            if (parent.img.destLeft + maxDimension.width < selectionObj.activePoint.endX) {
                parent.img.destLeft = selectionObj.activePoint.endX - maxDimension.width;
                if (parent.transform.degree === 0) {
                    parent.panPoint.totalPannedPoint.x -= (destLeft - parent.img.destLeft);
                }
            }
            if (parent.img.destTop + maxDimension.height < selectionObj.activePoint.endY) {
                parent.img.destTop = selectionObj.activePoint.endY - maxDimension.height;
                if (parent.transform.degree === 0) {
                    parent.panPoint.totalPannedPoint.y -= (destTop - parent.img.destTop);
                }
            }
        }
        return maxDimension;
    }
    setZoomDimension(value, selectionObj) {
        const parent = this.parent;
        let maxDimension = { width: 0, height: 0 };
        if (parent.transform.degree % 90 === 0 && parent.transform.degree % 180 !== 0) {
            maxDimension = this.calcMaxDimension(parent.img.srcHeight, parent.img.srcWidth);
        }
        else {
            maxDimension = this.calcMaxDimension(parent.img.srcWidth, parent.img.srcHeight);
        }
        maxDimension.width += (maxDimension.width * parent.transform.zoomFactor);
        maxDimension.height += (maxDimension.height * parent.transform.zoomFactor);
        parent.img.destLeft += ((parent.img.destWidth - maxDimension.width) / 2);
        parent.img.destTop += ((parent.img.destHeight - maxDimension.height) / 2);
        // While zoom out limit image to draw inside the selection range
        if (value < 0 && selectionObj) {
            const startX = selectionObj.activePoint.startX;
            const startY = selectionObj.activePoint.startY;
            const width = selectionObj.activePoint.width;
            const height = selectionObj.activePoint.height;
            const maxDestLeft = parent.img.destLeft + maxDimension.width;
            const maxDestTop = parent.img.destTop + maxDimension.height;
            if (parent.img.destLeft > startX) {
                parent.img.destLeft = startX;
            }
            if (parent.img.destTop > startY) {
                parent.img.destTop = startY;
            }
            if (maxDestLeft < startX + width) {
                parent.img.destLeft = startX + width - maxDimension.width;
            }
            if (maxDestTop < startY + height) {
                parent.img.destTop = startY + height - maxDimension.height;
            }
        }
        else if (value < 0 && isNullOrUndefined(selectionObj)) {
            if (parent.img.destLeft > 0) {
                parent.img.destLeft = 0;
            }
            if (parent.img.destTop > 0) {
                parent.img.destTop = 0;
            }
            if (parent.img.destLeft + maxDimension.width < parent.lowerCanvas.width) {
                parent.img.destLeft = parent.lowerCanvas.width - parent.img.destWidth;
            }
            if (parent.img.destTop + maxDimension.height < parent.lowerCanvas.height) {
                parent.img.destTop = parent.lowerCanvas.height - parent.img.destHeight;
            }
        }
        return maxDimension;
    }
    drawPannedImage(xDiff, yDiff) {
        const parent = this.parent;
        const obj = { panDown: null };
        parent.notify('selection', { prop: 'getPanDown', onPropertyChange: false, value: { obj: obj } });
        const panEventArgs = { startPoint: obj['panDown'], endPoint: this.panMove, cancel: false };
        if (isBlazor() && isNullOrUndefined(this.parent.eventType) && parent.events && parent.events.onPanStart.hasDelegate === true) {
            this.parent.eventType = 'pan';
            this.parent.panEventArgs = panEventArgs;
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            parent.dotNetRef.invokeMethodAsync('PanEventAsync', 'OnPanStart', panEventArgs).then((args) => {
                this.panEvent(args, xDiff, yDiff);
            });
        }
        else {
            parent.trigger('panning', panEventArgs);
            this.panEvent(panEventArgs, xDiff, yDiff);
        }
    }
    panEvent(panEventArgs, xDiff, yDiff) {
        if (panEventArgs.cancel) {
            return;
        }
        const parent = this.parent;
        let isObjCreated = false;
        if (parent.activeObj.shape && parent.activeObj.shape === 'shape') {
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        }
        if (isNullOrUndefined(parent.activeObj.shape)) {
            isObjCreated = true;
            parent.activeObj.activePoint = { startX: parent.img.destLeft, startY: parent.img.destTop,
                endX: parent.img.destLeft + parent.img.destWidth, endY: parent.img.destTop + parent.img.destHeight };
            const startX = parent.activeObj.activePoint.startX;
            const startY = parent.activeObj.activePoint.startY;
            const endX = parent.activeObj.activePoint.endX;
            const endY = parent.activeObj.activePoint.endY;
            if (startX < 0) {
                parent.activeObj.activePoint.startX = 0;
            }
            if (startY < 0) {
                parent.activeObj.activePoint.startY = 0;
            }
            if (endX > parent.lowerCanvas.width) {
                parent.activeObj.activePoint.endX =
                    parent.lowerCanvas.width;
            }
            if (endY > parent.lowerCanvas.height) {
                parent.activeObj.activePoint.endY =
                    parent.lowerCanvas.height;
            }
            parent.activeObj.activePoint.width = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.startX;
            parent.activeObj.activePoint.height = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.startY;
            parent.activeObj.shape = 'crop-custom';
            const obj = { strokeSettings: {} };
            parent.notify('shape', { prop: 'getStrokeSettings', onPropertyChange: false,
                value: { obj: obj } });
            parent.activeObj.strokeSettings = obj['strokeSettings'];
            parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: parent.activeObj.activePoint, obj: parent.activeObj,
                    isMouseMove: null, x: null, y: null } });
            parent.isCropTab = true;
        }
        if (parent.transform.degree === 0) {
            let point;
            if (isNullOrUndefined(xDiff) && isNullOrUndefined(yDiff)) {
                point = this.updatePanPoints('');
            }
            else {
                point = { x: xDiff, y: yDiff };
            }
            parent.panPoint.totalPannedPoint.x += point.x;
            parent.panPoint.totalPannedPoint.y += point.y;
            const tempSelectionObj = extend({}, parent.activeObj, {}, true);
            const temp = this.lowerContext.filter;
            this.drawPannImage(point);
            this.lowerContext.filter = temp;
            this.tempPanMove = extend({}, this.panMove, {}, true);
            parent.activeObj = extend({}, tempSelectionObj, {}, true);
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (parent.activeObj.shape) {
                parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
            }
        }
        else {
            const tempFlipState = parent.transform.currFlipState;
            parent.isCropTab = true;
            if (isNullOrUndefined(xDiff) && isNullOrUndefined(yDiff)) {
                parent.panPoint.currentPannedPoint = this.updatePanPoints('');
            }
            else {
                parent.panPoint.currentPannedPoint = { x: xDiff, y: yDiff };
            }
            parent.transform.currFlipState = tempFlipState;
            this.rotatePan();
            parent.isCropTab = false;
            this.tempPanMove = extend({}, this.panMove, {}, true);
        }
        if (isObjCreated) {
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            parent.isCropTab = false;
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
    }
    drawPannImage(point) {
        const parent = this.parent;
        const filter = this.lowerContext.filter;
        const destPoints = { startX: parent.img.destLeft, startY: parent.img.destTop, width: parent.img.destWidth,
            height: parent.img.destHeight };
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
            value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
        parent.img.destLeft = destPoints.startX;
        parent.img.destTop = destPoints.startY;
        parent.img.destWidth = destPoints.width;
        parent.img.destHeight = destPoints.height;
        this.setDestPointsForFlipState();
        parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        if ((parent.currSelectionPoint && parent.currSelectionPoint.shape === 'crop-circle') || parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: true } });
        }
        this.lowerContext.filter = filter;
        parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
            value: { type: 'reverse', isPreventDestination: null, isRotatePan: null } });
        parent.img.destLeft = destPoints.startX;
        parent.img.destTop = destPoints.startY;
        parent.img.destWidth = destPoints.width;
        parent.img.destHeight = destPoints.height;
        const temp = this.lowerContext.filter;
        this.lowerContext.filter = 'none';
        parent.notify('shape', { prop: 'panObjColl', onPropertyChange: false,
            value: { xDiff: point.x, yDiff: point.y, panRegion: '' } });
        parent.notify('freehand-draw', { prop: 'panFHDColl', onPropertyChange: false,
            value: { xDiff: point.x, yDiff: point.y, panRegion: '' } });
        this.lowerContext.filter = temp;
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        if (parent.isCircleCrop) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: true } });
        }
    }
    resetZoom() {
        const parent = this.parent;
        if (parent.transform.defaultZoomFactor !== 0) {
            const isUndoRedo = parent.isUndoRedo;
            const object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            this.transCurrObj = object['currObj'];
            this.transCurrObj.objColl = extend([], parent.objColl, null, true);
            this.transCurrObj.pointColl = extend({}, parent.pointColl, null, true);
            this.transCurrObj.afterCropActions = extend([], parent.afterCropActions, [], true);
            const selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            this.transCurrObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            parent.isUndoRedo = parent.isCropToolbar = true;
            if (parent.transform.defaultZoomFactor > 0) {
                this.zoomAction(-parent.transform.defaultZoomFactor);
            }
            else {
                this.zoomAction(Math.abs(parent.transform.defaultZoomFactor));
            }
            parent.isCropToolbar = false;
            parent.isUndoRedo = isUndoRedo;
        }
    }
    performTransformation(text) {
        const parent = this.parent;
        const tempZoomFactor = parent.transform.defaultZoomFactor;
        const isUndoRedo = parent.isUndoRedo;
        const prevCropObj = extend({}, parent.cropObj, {}, true);
        this.resetZoom();
        this.updateTransform(text);
        for (let i = 0, len = parent.objColl.length; i < len; i++) {
            if (parent.objColl[i].flipObjColl.length > 0) {
                const flipObjColl = { collection: parent.objColl[i].flipObjColl };
                parent.notify('shape', { prop: 'alignRotateFlipColl', onPropertyChange: false,
                    value: { collection: parent.objColl[i].flipObjColl, isRotateFlipCollection: null, obj: flipObjColl } });
                parent.objColl[i].flipObjColl = flipObjColl['collection'];
                if (parent.objColl[i].flipObjColl.length === 0) {
                    parent.objColl[i].shapeFlip = '';
                }
            }
        }
        if (tempZoomFactor !== 0) {
            parent.isUndoRedo = true;
            this.zoomAction(tempZoomFactor);
            parent.isUndoRedo = isUndoRedo;
            let state = '';
            if (text === 'rotateleft' || text === 'rotateright') {
                state = 'rotate';
            }
            else if (text === 'horizontalflip' || text === 'verticalflip') {
                state = 'flip';
            }
            parent.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: state, previousObj: this.transCurrObj, previousObjColl: this.transCurrObj.objColl,
                    previousPointColl: this.transCurrObj.pointColl, previousSelPointColl: this.transCurrObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
            this.transCurrObj = null;
        }
    }
    updateTransform(text) {
        switch (text.toLowerCase()) {
            case 'rotateleft':
                this.rotateImage(-90);
                break;
            case 'rotateright':
                this.rotateImage(90);
                break;
            case 'horizontalflip':
                this.flipImage(Direction.Horizontal);
                break;
            case 'verticalflip':
                this.flipImage(Direction.Vertical);
                break;
        }
    }
    rotatePan(isCropSelection, isDefaultZoom) {
        const parent = this.parent;
        this.isReverseRotate = true;
        const tempDegree = parent.transform.degree;
        let rotatePanActiveObj;
        const object = { selPointColl: null };
        if (parent.activeObj.activePoint && parent.activeObj.shape) {
            rotatePanActiveObj = extend({}, parent.activeObj, {}, true);
        }
        const tempObjColl = extend([], parent.objColl, [], true);
        const tempPointColl = extend([], parent.pointColl, [], true);
        parent.objColl = [];
        parent.pointColl = [];
        parent.freehandCounter = 0;
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: object } });
        const cropSelPointColl = object['selPointColl'];
        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
            value: { obj: { selPointColl: [] } } });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: true } });
        parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
            value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
        const initialDestLeft = parent.img.destLeft;
        const initialDestTop = parent.img.destTop;
        if (parent.isCropTab) {
            parent.img.destLeft += parent.panPoint.totalPannedInternalPoint.x;
            parent.img.destTop += parent.panPoint.totalPannedInternalPoint.y;
        }
        parent.notify('crop', { prop: 'updateRotatePan', onPropertyChange: false });
        if (parent.isCropTab) {
            parent.panPoint.totalPannedInternalPoint.x = parent.img.destLeft - initialDestLeft;
            parent.panPoint.totalPannedInternalPoint.y = parent.img.destTop - initialDestTop;
        }
        const temp = this.lowerContext.filter;
        parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
        this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
        parent.notify('draw', { prop: 'setRotateZoom', onPropertyChange: false, value: { isRotateZoom: false } });
        parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
            value: { type: 'reverse', isPreventDestination: true, isRotatePan: true } });
        const destLeft = parent.img.destLeft;
        const destTop = parent.img.destTop;
        parent.img.destLeft += parent.panPoint.totalPannedClientPoint.x;
        parent.img.destTop += parent.panPoint.totalPannedClientPoint.y;
        parent.img.destLeft += parent.panPoint.currentPannedPoint.x;
        parent.img.destTop += parent.panPoint.currentPannedPoint.y;
        parent.panPoint.totalPannedClientPoint.x = parent.img.destLeft - destLeft;
        parent.panPoint.totalPannedClientPoint.y =
            parent.img.destTop - destTop;
        parent.objColl = tempObjColl;
        parent.pointColl = tempPointColl;
        parent.freehandCounter = parent.pointColl.length;
        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
            value: { obj: { selPointColl: cropSelPointColl } } });
        parent.transform.degree = tempDegree;
        this.lowerContext.filter = 'none';
        if (isCropSelection) {
            if (isDefaultZoom) {
                parent.panPoint.totalPannedClientPoint.x = -parent.panPoint.totalPannedClientPoint.x;
                parent.panPoint.totalPannedClientPoint.y = -parent.panPoint.totalPannedClientPoint.y;
                parent.panPoint.currentPannedPoint = extend({}, parent.panPoint.totalPannedClientPoint, {}, true);
                parent.panPoint.totalPannedClientPoint = { x: 0, y: 0 };
                parent.img.destLeft += parent.panPoint.currentPannedPoint.x;
                parent.img.destTop += parent.panPoint.currentPannedPoint.y;
            }
            else {
                parent.panPoint.currentPannedPoint = extend({}, parent.panPoint.totalPannedClientPoint, {}, true);
            }
        }
        parent.notify('shape', { prop: 'panObjColl', onPropertyChange: false,
            value: { xDiff: parent.panPoint.currentPannedPoint.x, yDiff: parent.panPoint.currentPannedPoint.y, panRegion: '' } });
        parent.notify('freehand-draw', { prop: 'panFHDColl', onPropertyChange: false,
            value: { xDiff: parent.panPoint.currentPannedPoint.x, yDiff: parent.panPoint.currentPannedPoint.y, panRegion: '' } });
        this.lowerContext.filter = temp;
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.activeObj = extend({}, rotatePanActiveObj, {}, true);
        if (parent.activeObj.activePoint) {
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj, isCropRatio: null,
                    points: null, isPreventDrag: true, saveContext: null, isPreventSelection: null } });
        }
        this.isReverseRotate = false;
    }
    limitPan() {
        const parent = this.parent;
        if (parent.activeObj.activePoint) {
            if (parent.img.destLeft > parent.activeObj.activePoint.startX) {
                parent.img.destLeft = parent.activeObj.activePoint.startX;
            }
            if (parent.img.destTop > parent.activeObj.activePoint.startY) {
                parent.img.destTop = parent.activeObj.activePoint.startY;
            }
            if (parent.img.destLeft + parent.img.destWidth < parent.activeObj.activePoint.endX) {
                parent.img.destLeft = parent.activeObj.activePoint.endX - parent.img.destWidth;
            }
            if (parent.img.destTop + parent.img.destHeight < parent.activeObj.activePoint.endY) {
                parent.img.destTop = parent.activeObj.activePoint.endY - parent.img.destHeight;
            }
        }
    }
    updateFlipActiveObj(panRegion) {
        const parent = this.parent;
        if (panRegion === 'horizontal') {
            if (parent.activeObj.activePoint.startX > parent.lowerCanvas.width / 2) {
                parent.activeObj.activePoint.endX = (parent.lowerCanvas.width / 2) -
                    (parent.activeObj.activePoint.startX - (parent.lowerCanvas.width / 2));
            }
            else {
                parent.activeObj.activePoint.endX = (parent.lowerCanvas.width / 2) + ((parent.lowerCanvas.width / 2) -
                    parent.activeObj.activePoint.startX);
            }
            parent.activeObj.activePoint.startX = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.width;
        }
        else if (panRegion === 'vertical') {
            if (parent.activeObj.activePoint.startX > parent.lowerCanvas.width / 2) {
                parent.activeObj.activePoint.endY = (parent.lowerCanvas.height / 2) -
                    (parent.activeObj.activePoint.startY - (parent.lowerCanvas.height / 2));
            }
            else {
                parent.activeObj.activePoint.endY = (parent.lowerCanvas.height / 2) +
                    ((parent.lowerCanvas.height / 2) - parent.activeObj.activePoint.startY);
            }
            parent.activeObj.activePoint.startY = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.height;
        }
        else if (panRegion === 'verticalHorizontal' || panRegion === 'horizontalVertical') {
            if (parent.activeObj.activePoint.startX > parent.lowerCanvas.width / 2) {
                parent.activeObj.activePoint.endX = (parent.lowerCanvas.width / 2) -
                    (parent.activeObj.activePoint.startX - (parent.lowerCanvas.width / 2));
                parent.activeObj.activePoint.endY = (parent.lowerCanvas.height / 2) -
                    (parent.activeObj.activePoint.startY - (parent.lowerCanvas.height / 2));
            }
            else {
                parent.activeObj.activePoint.endX = (parent.lowerCanvas.width / 2) + ((parent.lowerCanvas.width / 2) -
                    parent.activeObj.activePoint.startX);
                parent.activeObj.activePoint.endY = (parent.lowerCanvas.height / 2) +
                    ((parent.lowerCanvas.height / 2) - parent.activeObj.activePoint.startY);
            }
            parent.activeObj.activePoint.startX = parent.activeObj.activePoint.endX - parent.activeObj.activePoint.width;
            parent.activeObj.activePoint.startY = parent.activeObj.activePoint.endY - parent.activeObj.activePoint.height;
        }
        parent.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: parent.activeObj.activePoint, obj: parent.activeObj,
                isMouseMove: null, x: null, y: null } });
    }
    pan(value) {
        const parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            if (value) {
                parent.togglePan = true;
                parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                    value: { x: null, y: null, isMouseDown: null } });
                parent.notify('selection', { prop: 'setDragCanvas', value: { bool: true } });
                parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = 'grab';
                parent.notify('selection', { prop: 'setPanDown', onPropertyChange: false, value: { panDown: null } });
            }
            else {
                parent.togglePan = parent.currObjType.isCustomCrop = false;
                parent.notify('selection', { prop: 'setDragCanvas', value: { bool: false } });
                parent.lowerCanvas.style.cursor = parent.upperCanvas.style.cursor = parent.cursor = 'default';
            }
        }
    }
    zoom(zoomFactor, zoomPoint) {
        const parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            const value = this.getCurrentZoomFactor(zoomFactor);
            if (isNullOrUndefined(zoomPoint)) {
                this.zoomAction(value, zoomPoint);
            }
            else {
                const type = value > 0 ? 'zoomIn' : 'zoomOut';
                for (let i = 0; i < (Math.abs(value) * 10); i++) {
                    parent.notify('draw', { prop: 'performPointZoom', onPropertyChange: false,
                        value: { x: zoomPoint.x, y: zoomPoint.y, type: type } });
                }
            }
        }
    }
    getCurrentZoomFactor(zoomFactor) {
        return (zoomFactor - this.prevZoomValue) * 0.1;
    }
    setCurrPanRegion(region, type, obj) {
        let panRegion = region;
        if (region === '') {
            if (type === 'horizontal') {
                panRegion = 'horizontal';
            }
            else if (type === 'vertical') {
                panRegion = 'vertical';
            }
        }
        else if (region === 'horizontal') {
            if (type === 'horizontal') {
                panRegion = 'horizontalVertical';
            }
            else if (type === 'vertical') {
                panRegion = 'verticalHorizontal';
            }
            else if (type === 90) {
                panRegion = 'vertical';
            }
            else if (type === -90) {
                panRegion = 'horizontal';
            }
        }
        else if (region === 'vertical') {
            if (type === 'horizontal') {
                panRegion = 'horizontalVertical';
            }
            else if (type === 'vertical') {
                panRegion = 'verticalHorizontal';
            }
            else if (type === 90) {
                panRegion = 'horizontal';
            }
            else if (type === -90) {
                panRegion = 'vertical';
            }
        }
        else {
            if (type === 'horizontal') {
                panRegion = 'vertical';
            }
            else if (type === 'vertical') {
                panRegion = 'horizontal';
            }
        }
        obj['panRegion'] = panRegion;
    }
    rotate(degree, obj) {
        const parent = this.parent;
        const isRotate = false;
        if (!parent.disabled && parent.isImageLoaded && (degree % 90 === 0)) {
            this.rotateImage(degree);
        }
        obj['isRotate'] = isRotate;
    }
    flip(direction) {
        const parent = this.parent;
        if (!parent.disabled && parent.isImageLoaded) {
            this.flipImage(direction);
        }
    }
    update() {
        const parent = this.parent;
        let toolbarHeight = 0;
        let isActiveObj = false;
        const freehandObj = { bool: false };
        if (parent.isImageLoaded) {
            if ((parent.element.querySelector('#' + parent.element.id + '_contextualToolbar') &&
                !parent.element.querySelector('#' + parent.element.id + '_contextualToolbar').parentElement.classList.contains('e-hide')) ||
                (parent.element.querySelector('#' + parent.element.id + '_headWrapper')
                    && !parent.element.querySelector('#' + parent.element.id + '_headWrapper').parentElement.classList.contains('e-hide'))) {
                parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
                parent.okBtn();
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
                    parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
                }
                else {
                    parent.updateToolbar(parent.element, 'imageLoaded');
                }
            }
            parent.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: freehandObj } });
            if (freehandObj['bool']) {
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
                }
                else {
                    parent.updateToolbar(parent.element, 'destroyQuickAccessToolbar');
                }
            }
            if (parent.activeObj.shape !== undefined) {
                isActiveObj = true;
                if (parent.textArea.style.display === 'block') {
                    parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                        value: { x: null, y: null, isMouseDown: null } });
                    if (!isBlazor()) {
                        parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
                    }
                    else {
                        parent.updateToolbar(parent.element, 'destroyQuickAccessToolbar');
                    }
                }
                else {
                    parent.notify('shape', { prop: 'updImgRatioForActObj', onPropertyChange: false });
                    parent.objColl.push(parent.activeObj);
                }
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            }
        }
        const tempFilter = this.lowerContext.filter;
        const canvasWrapper = document.querySelector('#' + parent.element.id + '_canvasWrapper');
        if (canvasWrapper) {
            canvasWrapper.style.width = parent.element.offsetWidth - 2 + 'px';
        }
        parent.lowerCanvas.width = parent.upperCanvas.width = parent.element.offsetWidth - 2;
        if (parent.toolbarTemplate) {
            toolbarHeight = parent.element.querySelector('#' + parent.element.id + '_toolbarArea').clientHeight;
        }
        else if (parent.element.querySelector('#' + parent.element.id + '_toolbar')) {
            toolbarHeight = parent.element.querySelector('#' + parent.element.id + '_toolbar').clientHeight;
        }
        parent.notify('toolbar', { prop: 'setToolbarHeight', value: { height: toolbarHeight } });
        if (Browser.isDevice) {
            if (canvasWrapper) {
                canvasWrapper.style.height = parent.element.offsetHeight - (2 * toolbarHeight) - 5 + 'px';
            }
            parent.lowerCanvas.height = parent.upperCanvas.height = parent.element.offsetHeight - (2 * toolbarHeight) - 5;
        }
        else {
            if (canvasWrapper) {
                canvasWrapper.style.height = parent.element.offsetHeight - toolbarHeight - 3 + 'px';
            }
            parent.lowerCanvas.height = parent.upperCanvas.height = parent.element.offsetHeight - toolbarHeight - 3;
        }
        this.lowerContext.filter =
            'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
                'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' + 'invert(0%)';
        parent.notify('filter', { prop: 'setAdjustmentValue', onPropertyChange: false, value: { adjustmentValue: this.lowerContext.filter } });
        parent.canvasFilter = this.lowerContext.filter;
        this.parent.initialAdjustmentValue = this.lowerContext.filter;
        parent.clearContext(this.lowerContext);
        this.parent.clearContext(this.upperContext);
        if (parent.isImageLoaded) {
            parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: null } });
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.lowerContext.filter = tempFilter;
            parent.initialAdjustmentValue = tempFilter;
            parent.canvasFilter = this.lowerContext.filter;
            if (parent.isImageLoaded) {
                showSpinner(parent.element);
                parent.element.style.opacity = '0.5';
            }
            this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (canvasWrapper) {
                canvasWrapper.style.width = parent.element.offsetWidth - 2 + 'px';
                canvasWrapper.style.height = parent.element.offsetHeight + 'px';
                const obj = { toolbarHeight: !isBlazor() ? 0 : parent.toolbarHeight };
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'getToolbarHeight', value: { obj: obj } });
                }
                if (Browser.isDevice) {
                    canvasWrapper.style.height = (parseFloat(canvasWrapper.style.height) - (2 * obj['toolbarHeight'])) - 3 + 'px';
                }
                else {
                    canvasWrapper.style.height = (parseFloat(canvasWrapper.style.height) - obj['toolbarHeight']) - 3 + 'px';
                }
            }
            const obj = { width: 0, height: 0 };
            parent.notify('transform', { prop: 'calcMaxDimension', onPropertyChange: false,
                value: { width: parent.img.srcWidth, height: parent.img.srcHeight, obj: obj } });
            const maxDimension = obj;
            if (parent.transform.defaultZoomFactor > 0) {
                maxDimension.width += (maxDimension.width * parent.transform.defaultZoomFactor);
                maxDimension.height += (maxDimension.height * parent.transform.defaultZoomFactor);
            }
            parent.img.destLeft = (parent.lowerCanvas.clientWidth - maxDimension.width) / 2;
            parent.img.destTop = (parent.lowerCanvas.clientHeight - maxDimension.height) / 2;
            if (parent.transform.degree === 0 && parent.transform.currFlipState === '') {
                if (parent.transform.defaultZoomFactor > 0) {
                    parent.img.destLeft += parent.panPoint.totalPannedPoint.x;
                    parent.img.destTop += parent.panPoint.totalPannedPoint.y;
                }
                parent.notify('draw', { prop: 'draw-image-to-canvas', value: { dimension: maxDimension } });
            }
            else {
                parent.notify('draw', { prop: 'draw-image-to-canvas', value: { dimension: maxDimension } });
                parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                    value: { type: 'initial', isPreventDestination: null, isRotatePan: null } });
                const temp = this.lowerContext.filter;
                parent.notify('filter', { prop: 'updateBrightFilter', onPropertyChange: false });
                this.lowerContext.drawImage(parent.baseImg, parent.img.srcLeft, parent.img.srcTop, parent.img.srcWidth, parent.img.srcHeight, parent.img.destLeft, parent.img.destTop, parent.img.destWidth, parent.img.destHeight);
                this.lowerContext.filter = temp;
                parent.notify('draw', { prop: 'updateCurrTransState', onPropertyChange: false,
                    value: { type: 'reverse', isPreventDestination: null, isRotatePan: null } });
            }
            parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
            parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
            if (parent.isCircleCrop) {
                parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                    value: { context: this.lowerContext, isSave: null, isFlip: null } });
            }
            hideSpinner(parent.element);
            parent.element.style.opacity = '1';
            const obj1 = { defToolbarItems: null };
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'getDefToolbarItems', value: { obj: obj1 } });
                if (obj1['defToolbarItems'] && obj1['defToolbarItems'].length > 0 && document.getElementById(parent.element.id + '_toolbar')) {
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    const toolbar = getComponent(parent.element.id + '_toolbar', 'toolbar');
                    toolbar.refreshOverflow();
                    if (parent.element.querySelector('.e-contextual-toolbar-wrapper')) {
                        parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
                    }
                }
            }
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
            if (isActiveObj) {
                parent.activeObj = extend({}, parent.objColl[parent.objColl.length - 1], null, true);
                parent.objColl.pop();
                if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
                    parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
                    if (parent.activeObj.shape === 'rectangle' || parent.activeObj.shape === 'ellipse' || parent.activeObj.shape === 'text' ||
                        parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow' || parent.activeObj.shape === 'path') {
                        if (!isBlazor()) {
                            parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
                        }
                        else {
                            parent.updateToolbar(parent.element, 'quickAccessToolbar', parent.activeObj.shape);
                        }
                    }
                }
            }
            if (freehandObj['bool']) {
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: true } });
                }
                else {
                    parent.updateToolbar(parent.element, 'quickAccessToolbar', 'pen');
                }
            }
            if ((parent.transform.degree !== 0 || parent.transform.currFlipState !== '') && parent.transform.defaultZoomFactor > 0) {
                const totalPannedPoint = extend({}, parent.panPoint.totalPannedPoint, null, true);
                const totalPannedInternalPoint = extend({}, parent.panPoint.totalPannedInternalPoint, null, true);
                const totalPannedClientPoint = extend({}, parent.panPoint.totalPannedClientPoint, null, true);
                parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                    value: { zoomFactor: .1, zoomPoint: null } });
                parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                    value: { zoomFactor: -.1, zoomPoint: null } });
                if (parent.transform.degree === 0) {
                    parent.img.destLeft += totalPannedPoint.x;
                    parent.img.destTop += totalPannedPoint.y;
                    parent.panPoint.totalPannedPoint = totalPannedPoint;
                    parent.notify('draw', { prop: 'updateFlipPan', value: { tempSelectionObj: null } });
                }
                else {
                    parent.panPoint.totalPannedInternalPoint = totalPannedInternalPoint;
                    parent.panPoint.totalPannedClientPoint = totalPannedClientPoint;
                    parent.panPoint.currentPannedPoint = { x: 0, y: 0 };
                    parent.isCropTab = true;
                    parent.notify('transform', { prop: 'rotatePan', onPropertyChange: false,
                        value: { isCropSelection: null, isDefaultZoom: null } });
                    parent.isCropTab = false;
                }
            }
            else if (parent.transform.degree !== 0 && parent.transform.cropZoomFactor > 0) {
                parent.transform.zoomFactor = 0;
                parent.transform.cropZoomFactor = null;
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'enable-disable-btns', onPropertyChange: false });
                }
                else {
                    parent.updateToolbar(parent.element, 'enableDisableToolbarBtn');
                }
            }
        }
    }
    calcMaxDimension(width, height, obj) {
        const object = { toolbarHeight: 0 };
        if (!isBlazor()) {
            this.parent.notify('toolbar', { prop: 'getToolbarHeight', value: { obj: object } });
        }
        else {
            object['toolbarHeight'] = this.parent.toolbarHeight;
        }
        let canvasMaxWidth = this.parent.element.clientWidth;
        let canvasMaxHeight = this.parent.element.clientHeight - object['toolbarHeight'];
        canvasMaxHeight = Browser.isDevice ? canvasMaxHeight - object['toolbarHeight'] : canvasMaxHeight;
        if (canvasMaxWidth > 30) {
            canvasMaxWidth -= 30;
        }
        if (canvasMaxHeight > 30) {
            canvasMaxHeight -= 30;
        }
        const widthScale = canvasMaxWidth / width;
        const heightScale = canvasMaxHeight / height;
        let cssMaxWidth = Math.min(width, canvasMaxWidth);
        let cssMaxHeight = Math.min(height, canvasMaxHeight);
        if (widthScale < 1 && widthScale < heightScale) {
            cssMaxWidth = width * widthScale;
            cssMaxHeight = height * widthScale;
        }
        else if (heightScale < 1 && heightScale < widthScale) {
            cssMaxWidth = width * heightScale;
            cssMaxHeight = height * heightScale;
        }
        const cropObj = { bool: null };
        this.parent.notify('crop', { prop: 'getPreventScaling', onPropertyChange: false,
            value: { obj: cropObj } });
        if (cropObj['bool'] && this.parent.cropObj.activeObj.activePoint &&
            this.parent.cropObj.activeObj.activePoint.width !== 0 && this.parent.cropObj.activeObj.activePoint.height !== 0) {
            cssMaxWidth = this.parent.cropObj.activeObj.activePoint.width;
            cssMaxHeight = this.parent.cropObj.activeObj.activePoint.height;
        }
        if (obj) {
            obj['width'] = cssMaxWidth;
            obj['height'] = cssMaxHeight;
        }
        return { width: cssMaxWidth, height: cssMaxHeight };
    }
    updatePanPoints(panRegion, obj) {
        const parent = this.parent;
        const tempActObj = extend({}, parent.activeObj, {}, true);
        const tempDestLeft = parent.img.destLeft;
        const tempDestTop = parent.img.destTop;
        if (isNullOrUndefined(this.tempPanMove)) {
            this.tempPanMove = { x: this.panMove.x, y: this.panMove.y };
        }
        let xDiff = this.panMove.x - this.tempPanMove.x;
        let yDiff = this.panMove.y - this.tempPanMove.y;
        switch (panRegion) {
            case '':
                parent.img.destLeft += xDiff;
                parent.img.destTop += yDiff;
                break;
            case 'horizontal':
                this.updateFlipActiveObj(panRegion);
                xDiff = this.tempPanMove.x - this.panMove.x;
                parent.img.destLeft += xDiff;
                parent.img.destTop += yDiff;
                break;
            case 'vertical':
                this.updateFlipActiveObj(panRegion);
                yDiff = this.tempPanMove.y - this.panMove.y;
                parent.img.destLeft += xDiff;
                parent.img.destTop += yDiff;
                break;
            case 'horizontalVertical':
                this.updateFlipActiveObj(panRegion);
                xDiff = this.tempPanMove.x - this.panMove.x;
                parent.img.destLeft += xDiff;
                parent.img.destTop -= yDiff;
                break;
            case 'verticalHorizontal':
                this.updateFlipActiveObj(panRegion);
                yDiff = this.tempPanMove.y - this.panMove.y;
                parent.img.destLeft -= xDiff;
                parent.img.destTop += yDiff;
                break;
        }
        this.limitPan();
        parent.activeObj = tempActObj;
        if (obj) {
            obj['x'] = parent.img.destLeft - tempDestLeft;
            obj['y'] = parent.img.destTop - tempDestTop;
        }
        return { x: parent.img.destLeft - tempDestLeft, y: parent.img.destTop - tempDestTop };
    }
}

class UndoRedo {
    constructor(parent) {
        this.undoRedoStep = 0;
        this.undoRedoColl = [];
        this.appliedUndoRedoColl = [];
        this.tempUndoRedoColl = [];
        this.tempUndoRedoStep = 0;
        this.parent = parent;
        this.addEventListener();
    }
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    }
    addEventListener() {
        this.parent.on('undo-redo', this.undoRedo, this);
        this.parent.on('destroyed', this.destroy, this);
    }
    removeEventListener() {
        this.parent.off('undo-redo', this.undoRedo);
        this.parent.off('destroyed', this.destroy);
    }
    initializeUrPvtProp() {
        if (this.parent.lowerCanvas) {
            this.lowerContext = this.parent.lowerCanvas.getContext('2d');
        }
        if (this.parent.upperCanvas) {
            this.upperContext = this.parent.upperCanvas.getContext('2d');
        }
    }
    undoRedo(args) {
        this.initializeUrPvtProp();
        switch (args.prop) {
            case 'updateUndoRedoColl':
                this.updateUrc(args.value['operation'], args.value['previousObj'], args.value['previousObjColl'], args.value['previousPointColl'], args.value['previousSelPointColl'], args.value['previousCropObj'], args.value['previousText'], args.value['currentText'], args.value['previousFilter'], args.value['isCircleCrop']);
                break;
            case 'refreshUrc':
                this.refreshUrc(args.value['bool']);
                break;
            case 'updateCurrUrc':
                this.updateCurrUrc(args.value['type']);
                break;
            case 'call-undo':
                this.callUndo();
                break;
            case 'call-redo':
                this.callRedo();
                break;
            case 'undo':
                this.undo();
                break;
            case 'redo':
                this.redo();
                break;
            case 'updateUrObj':
                this.updateUrObj(args.value['objColl']);
                break;
            case 'updateUndoRedo':
                this.updateUndoRedo();
                break;
            case 'getAppliedUndoRedoColl':
                args.value['obj']['appliedUndoRedoColl'] = this.appliedUndoRedoColl;
                break;
            case 'getUndoRedoStep':
                args.value['obj']['undoRedoStep'] = this.undoRedoStep;
                break;
            case 'setUndoRedoStep':
                this.undoRedoStep = args.value['step'];
                break;
            case 'undoDefault':
                this.undoDefault(args.value['obj']);
                break;
            case 'reset':
                this.reset();
                break;
        }
    }
    getModuleName() {
        return 'undo-redo';
    }
    reset() {
        this.tempCurrSelPoint = null;
        this.undoRedoStep = 0;
        this.undoRedoColl = [];
        this.appliedUndoRedoColl = [];
        this.tempActObj = null;
        this.tempUndoRedoColl = [];
        this.tempUndoRedoStep = 0;
    }
    refreshUrc(refreshToolbar) {
        const parent = this.parent;
        refreshToolbar = refreshToolbar ? refreshToolbar : false;
        if (refreshToolbar) {
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'setEnableDisableUndoRedo', value: { isPrevent: true } });
            }
            this.tempUndoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
            this.tempUndoRedoStep = this.undoRedoStep;
        }
        else if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'setEnableDisableUndoRedo', value: { isPrevent: false } });
        }
        this.undoRedoColl = this.undoRedoColl.slice(0, this.undoRedoStep);
        this.appliedUndoRedoColl = this.appliedUndoRedoColl.slice(0, this.undoRedoStep);
        parent.isUndoRedo = parent.currObjType.isUndoAction = false;
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'enable-disable-btns' });
        }
        else {
            parent.updateToolbar(parent.element, 'enableDisableToolbarBtn');
        }
    }
    updateCurrUrc(type) {
        const parent = this.parent;
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'setEnableDisableUndoRedo', value: { isPrevent: false } });
        }
        if (type === 'ok') {
            parent.notify('draw', { prop: 'setShapeTextInsert', onPropertyChange: false, value: { bool: false } });
            const collection = this.tempUndoRedoColl.length > 0 ?
                extend([], this.tempUndoRedoColl, [], true) :
                extend([], this.undoRedoColl, [], true);
            const prevObj = this.undoRedoColl[this.undoRedoColl.length - 1];
            if (isNullOrUndefined(this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1])) {
                if (this.undoRedoColl[0]) {
                    prevObj.previousCropObj = collection[0].previousCropObj;
                    prevObj.previousObj = collection[0].previousObj;
                    prevObj.previousObjColl = collection[0].previousObjColl;
                    prevObj.previousPointColl = collection[0].previousPointColl;
                    prevObj.previousText = collection[0].previousText;
                }
            }
            else {
                prevObj.previousCropObj = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1].currentCropObj;
                prevObj.previousObj = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1].currentObj;
                prevObj.previousObjColl = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1].currentObjColl;
                prevObj.previousPointColl = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1].currentPointColl;
                prevObj.previousText = this.appliedUndoRedoColl[this.appliedUndoRedoColl.length - 1].currentText;
            }
            if (prevObj) {
                const obj = this.getZeroZoomObjPointValue(prevObj.currentObjColl, prevObj.currentPointColl);
                prevObj.currentObjColl = obj['obj'];
                prevObj.currentPointColl = obj['point'];
                this.appliedUndoRedoColl.push(prevObj);
            }
            this.tempUndoRedoColl = [];
            this.tempUndoRedoStep = 0;
        }
        else if (this.tempUndoRedoColl.length > 0) {
            this.appliedUndoRedoColl = extend([], this.tempUndoRedoColl, [], true);
            this.undoRedoStep = this.tempUndoRedoStep;
            this.tempUndoRedoColl = [];
            this.tempUndoRedoStep = 0;
        }
        if (this.appliedUndoRedoColl.length > 16) {
            this.appliedUndoRedoColl.splice(0, 1);
        }
        this.undoRedoColl = [];
        this.undoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
        if (type === 'ok') {
            this.undoRedoStep = this.undoRedoColl.length;
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'enable-disable-btns' });
            }
            else {
                parent.updateToolbar(parent.element, 'enableDisableToolbarBtn');
            }
        }
        if (parent.transform.zoomFactor > 0) {
            parent.togglePan = true;
            parent.notify('selection', { prop: 'setDragCanvas', value: { bool: true } });
        }
    }
    cancelCropSelection() {
        const parent = this.parent;
        let isCropSelection = false;
        let splitWords;
        if (parent.activeObj.shape) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (parent.currObjType.isCustomCrop || (splitWords && splitWords[0] === 'crop')) {
            isCropSelection = true;
        }
        if (isCropSelection) {
            parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });
        }
        if (this.tempUndoRedoColl.length !== 0 || this.tempUndoRedoStep !== 0) {
            this.appliedUndoRedoColl = extend([], this.tempUndoRedoColl, [], true);
            this.undoRedoColl = extend([], this.tempUndoRedoColl, [], true);
            this.undoRedoStep = this.tempUndoRedoStep;
            this.tempUndoRedoColl = [];
            this.tempUndoRedoStep = 0;
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'setEnableDisableUndoRedo', value: { isPrevent: false } });
            }
        }
    }
    refreshToolbarActions() {
        const parent = this.parent;
        if (!isBlazor()) {
            if (parent.activeObj.shape) {
                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                        isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                parent.notify('toolbar', { prop: 'update-toolbar-items', onPropertyChange: false });
            }
            else {
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            }
        }
        else if (isNullOrUndefined(parent.activeObj.shape)) {
            parent.updateToolbar(parent.element, 'imageLoaded');
        }
    }
    applyCurrentChanges() {
        const parent = this.parent;
        parent.currObjType.isFiltered = false;
        if (parent.transform.zoomFactor === 0) {
            parent.togglePan = false;
            parent.notify('selection', { prop: 'setDragCanvas', value: { bool: false } });
        }
        if (parent.element.querySelector('.e-contextual-toolbar-wrapper') && !isBlazor()) {
            parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
        }
        if (parent.togglePen) {
            parent.togglePen = false;
            parent.upperCanvas.style.cursor = parent.cursor = 'default';
            this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        }
        if (this.appliedUndoRedoColl.length > 0) {
            this.undoRedoColl = extend([], this.appliedUndoRedoColl, [], true);
        }
    }
    callUndo() {
        this.applyCurrentChanges();
        this.undo();
    }
    callRedo() {
        this.applyCurrentChanges();
        this.redo();
    }
    undo() {
        const parent = this.parent;
        this.cancelCropSelection();
        if (!parent.disabled && parent.isImageLoaded) {
            if (this.undoRedoStep > 0) {
                this.refreshToolbarActions();
                if (parent.activeObj.activePoint && parent.activeObj.activePoint.width !== 0) {
                    this.tempActObj = parent.activeObj;
                }
                parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                this.undoRedoStep--;
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'enable-disable-btns' });
                    if (parent.element.querySelector('.e-contextual-toolbar-wrapper')) {
                        parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
                    }
                }
                else {
                    parent.updateToolbar(parent.element, 'enableDisableToolbarBtn');
                }
                parent.isUndoRedo = true;
                const obj = this.undoRedoColl[this.undoRedoStep];
                if (this.undoRedoColl.length === this.undoRedoStep) {
                    parent.currObjType.isUndoAction = false;
                }
                else {
                    parent.currObjType.isUndoAction = true;
                }
                if (obj.operation !== 'textAreaCustomization' && parent.textArea.style.display === 'block') {
                    parent.textArea.style.display = 'none';
                }
                parent.notify('draw', { prop: 'setCancelAction', onPropertyChange: false, value: { bool: true } });
                let activeObj;
                parent.cropObj = extend({}, obj.previousCropObj, {}, true);
                parent.afterCropActions = obj.previousObj.afterCropActions;
                this.lowerContext.filter = obj.previousObj.filter;
                parent.canvasFilter = this.lowerContext.filter;
                switch (obj.operation) {
                    case 'shapeTransform':
                        this.shapeTransform(obj.previousObjColl);
                        break;
                    case 'freehanddraw':
                    case 'freehand-draw':
                        this.updateFreehandDraw(obj.previousPointColl);
                        break;
                    case 'freehanddrawCustomized':
                        this.updateFreehandDrawCustomized(obj.previousPointColl);
                        break;
                    case 'deleteFreehandDrawing':
                    case 'deleteObj':
                        this.updateDelete(obj.operation, obj.previousObjColl, obj.previousPointColl);
                        break;
                    case 'textAreaCustomization':
                        this.updateTextAreaCustomization(activeObj, obj.previousObjColl);
                        break;
                    case 'text':
                        this.updateText(obj.previousObjColl, true);
                        break;
                    default:
                        this.undoDefault(obj);
                        parent.notify('filter', { prop: 'set-adjustment', value: { operation: obj.operation } });
                        parent.notify('filter', { prop: 'update-filter', value: { operation: obj.operation, filter: obj.filter } });
                        break;
                }
                if (obj.operation === 'crop') {
                    if (obj.previousObj.currSelectionPoint) {
                        parent.currSelectionPoint = extend({}, obj.previousObj.currSelectionPoint, {}, true);
                        if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
                            parent.currSelectionPoint = null;
                        }
                    }
                    parent.updateCropTransformItems();
                    parent.select('custom');
                    if (parent.isCircleCrop) {
                        parent.isCircleCrop = false;
                        this.tempCurrSelPoint = extend({}, parent.currSelectionPoint, {}, true);
                        parent.currSelectionPoint = null;
                    }
                    parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: null } });
                }
                if ((this.undoRedoColl[this.undoRedoStep - 1]
                    && this.undoRedoColl[this.undoRedoStep - 1].isCircleCrop)) {
                    parent.isCircleCrop = true;
                    parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                        value: { context: this.lowerContext, isSave: null, isFlip: null } });
                }
                this.endUndoRedo(obj.operation, true);
            }
        }
    }
    redo() {
        const parent = this.parent;
        this.cancelCropSelection();
        if (!parent.disabled && parent.isImageLoaded) {
            if (this.undoRedoStep < this.appliedUndoRedoColl.length) {
                this.refreshToolbarActions();
                this.undoRedoStep++;
                if (!isBlazor()) {
                    parent.notify('toolbar', { prop: 'enable-disable-btns' });
                }
                else {
                    parent.updateToolbar(parent.element, 'enableDisableToolbarBtn');
                }
                parent.isUndoRedo = true;
                const obj = this.undoRedoColl[this.undoRedoStep - 1];
                if (this.undoRedoColl.length === this.undoRedoStep) {
                    parent.currObjType.isUndoAction = false;
                }
                else {
                    parent.currObjType.isUndoAction = true;
                }
                if (obj.operation !== 'textAreaCustomization' && parent.textArea.style.display === 'block') {
                    parent.textArea.style.display = 'none';
                }
                parent.notify('draw', { prop: 'setCancelAction', onPropertyChange: false, value: { bool: true } });
                parent.cropObj = extend({}, obj.currentCropObj, {}, true);
                parent.afterCropActions = obj.currentObj.afterCropActions;
                this.lowerContext.filter = obj.currentObj.filter;
                if (!isBlazor() && parent.element.querySelector('.e-contextual-toolbar-wrapper')) {
                    parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
                }
                parent.canvasFilter = this.lowerContext.filter;
                let activeObj;
                switch (obj.operation) {
                    case 'shapeTransform':
                        this.shapeTransform(obj.currentObjColl);
                        break;
                    case 'freehanddraw':
                    case 'freehand-draw':
                        this.updateFreehandDraw(obj.currentPointColl);
                        break;
                    case 'freehanddrawCustomized':
                        this.updateFreehandDrawCustomized(obj.currentPointColl);
                        break;
                    case 'deleteFreehandDrawing':
                    case 'deleteObj':
                        this.updateDelete(obj.operation, obj.currentObjColl, obj.currentPointColl);
                        break;
                    case 'textAreaCustomization':
                        this.updateTextAreaCustomization(activeObj, obj.currentObjColl);
                        break;
                    case 'text':
                        this.updateText(obj.currentObjColl, false);
                        break;
                    default:
                        parent.objColl = [];
                        parent.pointColl = [];
                        parent.freehandCounter = 0;
                        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                            value: { obj: { selPointColl: [] } } });
                        parent.notify('draw', { prop: 'setCurrentObj', onPropertyChange: false, value: { obj: obj.currentObj } });
                        parent.img.destLeft = obj.currentObj.destPoints.startX;
                        parent.img.destTop = obj.currentObj.destPoints.startY;
                        activeObj = extend({}, parent.activeObj, {}, true);
                        parent.objColl = extend([], obj.currentObjColl, [], true);
                        parent.pointColl = extend([], obj.currentPointColl, [], true);
                        parent.freehandCounter = parent.pointColl.length;
                        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                            value: { obj: { selPointColl: extend([], obj.currentSelPointColl, [], true) } } });
                        this.lowerContext.filter = 'none';
                        parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
                        parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
                        this.lowerContext.filter = obj.currentObj.filter;
                        parent.activeObj = activeObj;
                        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                        if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
                            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
                        }
                        parent.notify('filter', { prop: 'set-adjustment', value: { operation: obj.operation } });
                        parent.notify('filter', { prop: 'update-filter', value: { operation: obj.operation } });
                        break;
                }
                if (obj.operation === 'crop' && obj.isCircleCrop) {
                    parent.isCircleCrop = true;
                    parent.currSelectionPoint = extend({}, this.tempCurrSelPoint, {}, true);
                    this.tempCurrSelPoint = null;
                }
                if (obj.operation === 'crop' && !obj.isCircleCrop) {
                    parent.isCircleCrop = false;
                }
                if (obj.operation === 'crop' && obj.currentObj.currSelectionPoint) {
                    parent.currSelectionPoint = extend({}, obj.currentObj.currSelectionPoint, {}, true);
                }
                if (parent.currSelectionPoint && isNullOrUndefined(parent.currSelectionPoint.shape)) {
                    parent.currSelectionPoint = null;
                }
                this.endUndoRedo(obj.operation, false);
            }
        }
    }
    shapeTransform(objColl) {
        const parent = this.parent;
        parent.objColl = extend([], objColl, [], true);
        parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.isUndoRedo = true;
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
    }
    updateFreehandDraw(pointColl) {
        const parent = this.parent;
        parent.pointColl = pointColl;
        parent.freehandCounter = parent.pointColl.length;
        parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.isUndoRedo = true;
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
    }
    updateFreehandDrawCustomized(pointColl) {
        const parent = this.parent;
        parent.pointColl = pointColl;
        parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.isUndoRedo = true;
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
    }
    updateDelete(operation, objColl, pointColl) {
        const parent = this.parent;
        if (operation === 'deleteFreehandDrawing') {
            parent.pointColl = pointColl;
            parent.freehandCounter = parent.pointColl.length;
            parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
        }
        else if (operation === 'deleteObj') {
            parent.objColl = objColl;
            parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
        }
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.isUndoRedo = true;
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
    }
    updateTextAreaCustomization(activeObj, objColl) {
        const parent = this.parent;
        parent.objColl = extend([], objColl, [], true);
        parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: true } });
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.isUndoRedo = true;
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
        for (let i = 0, len = objColl.length; i < len; i++) {
            if (this.tempActObj) {
                if (this.tempActObj.currIndex === objColl[i].currIndex) {
                    activeObj = extend({}, objColl[i], {}, true);
                    parent.objColl.splice(i, 1);
                    break;
                }
            }
            else {
                activeObj = extend({}, objColl[objColl.length - 1], {}, true);
                parent.objColl.splice(i, 1);
                break;
            }
        }
        if (activeObj) {
            this.updateTextBox(activeObj);
        }
        if (parent.textArea.style.display === 'block') {
            parent.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: null } });
        }
    }
    updateText(objColl, allowActiveObj) {
        const parent = this.parent;
        if (this.tempActObj) {
            parent.activeObj = extend({}, this.tempActObj, {}, true);
        }
        if (objColl.length === 0 && parent.objColl.length === 1) {
            this.tempActObj = extend({}, parent.objColl[0], {}, true);
        }
        else {
            for (let i = 0; i < parent.objColl.length; i++) {
                if (parent.objColl[i] && isNullOrUndefined(objColl[i])) {
                    this.tempActObj = extend({}, parent.objColl[i], {}, true);
                    break;
                }
                if (objColl[i].currIndex !== parent.objColl[i].currIndex) {
                    this.tempActObj = extend({}, parent.objColl[i], {}, true);
                    break;
                }
            }
        }
        if (allowActiveObj) {
            parent.activeObj = extend({}, this.tempActObj, {}, true);
        }
        parent.objColl = extend([], objColl, [], true);
        parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: true } });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.isUndoRedo = true;
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
    }
    updateTextBox(obj) {
        const parent = this.parent;
        this.upperContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        this.lowerContext.clearRect(0, 0, parent.lowerCanvas.width, parent.lowerCanvas.height);
        parent.notify('draw', { prop: 'redrawImgWithObj', onPropertyChange: false });
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
        }
        else {
            parent.updateToolbar(parent.element, 'destroyQuickAccessToolbar');
        }
        parent.textArea.style.display = 'block';
        parent.textArea.style.fontFamily = obj.textSettings.fontFamily;
        parent.textArea.style.fontSize = obj.textSettings.fontSize + 'px';
        parent.textArea.style.color = obj.strokeSettings.strokeColor;
        parent.textArea.style.fontWeight = obj.textSettings.bold ? 'bold' : 'normal';
        parent.textArea.style.fontStyle = obj.textSettings.italic ? 'italic' : 'normal';
        parent.textArea.style.border = '2px solid ' + parent.themeColl[parent.theme]['primaryColor'];
        parent.textArea.value = obj.keyHistory;
        parent.activeObj = extend({}, obj, {}, true);
        parent.notify('shape', { prop: 'updateFontStyles', onPropertyChange: false,
            value: { isTextBox: null } });
        parent.textArea.style.width = parent.activeObj.activePoint.width + 'px';
    }
    undoDefault(obj) {
        this.lowerContext.filter = obj.previousObj.filter;
        const parent = this.parent;
        parent.objColl = [];
        parent.pointColl = [];
        parent.freehandCounter = 0;
        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
            value: { obj: { selPointColl: [] } } });
        parent.notify('draw', { prop: 'setCurrentObj', onPropertyChange: false, value: { obj: obj.previousObj } });
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.img.destLeft = obj.previousObj.destPoints.startX;
        parent.img.destTop = obj.previousObj.destPoints.startY;
        const activeObj = extend({}, parent.activeObj, {}, true);
        parent.objColl = extend([], obj.previousObjColl, [], true);
        parent.pointColl = extend([], obj.previousPointColl, [], true);
        parent.freehandCounter = parent.pointColl.length;
        parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
            value: { obj: { selPointColl: extend([], obj.previousSelPointColl, [], true) } } });
        this.lowerContext.filter = 'none';
        parent.notify('shape', { prop: 'zoomObjColl', onPropertyChange: false, value: { isPreventApply: null } });
        parent.notify('freehand-draw', { prop: 'zoomFHDColl', onPropertyChange: false, value: { isPreventApply: null } });
        this.lowerContext.filter = obj.previousObj.filter;
        parent.activeObj = activeObj;
        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
        if (parent.activeObj.activePoint.width !== 0 && parent.activeObj.activePoint.height !== 0) {
            parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate' } });
        }
    }
    endUndoRedo(operation, isUndo) {
        const parent = this.parent;
        parent.notify('draw', { prop: 'clearOuterCanvas', onPropertyChange: false, value: { context: this.lowerContext } });
        if (parent.isCircleCrop && ((isUndo && operation !== 'crop') || !isUndo)) {
            parent.notify('crop', { prop: 'cropCircle', onPropertyChange: false,
                value: { context: this.lowerContext, isSave: null, isFlip: null } });
        }
        if (parent.transform.zoomFactor > 0) {
            parent.notify('selection', { prop: 'setDragCanvas', value: { bool: true } });
        }
        parent.notify('draw', { prop: 'setCancelAction', onPropertyChange: false, value: { bool: false } });
        if (!isBlazor()) {
            if (parent.activeObj.shape && parent.activeObj.shape.split('-')[0] === 'crop') {
                parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                        isApplyBtn: true, isCropping: true, isZooming: null, cType: null } });
            }
            else {
                parent.notify('toolbar', { prop: 'refresh-main-toolbar', onPropertyChange: false });
            }
            parent.notify('toolbar', { prop: 'enable-disable-btns' });
        }
        else if (isNullOrUndefined(parent.activeObj.shape) || parent.activeObj.shape.split('-')[0] !== 'crop') {
            parent.updateToolbar(parent.element, 'imageLoaded');
            parent.updateToolbar(parent.element, 'enableDisableToolbarBtn');
        }
        if (document.getElementById(parent.element.id + '_quickAccessToolbarArea')) {
            document.getElementById(parent.element.id + '_quickAccessToolbarArea').style.display = 'none';
        }
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'enable-disable-btns' });
        }
        else {
            parent.updateToolbar(parent.element, 'enableDisableToolbarBtn');
        }
        if (parent.transform.degree !== 0) {
            parent.notify('transform', { prop: 'drawPannedImage', onPropertyChange: false,
                value: { xDiff: 0, yDiff: 0 } });
        }
        parent.notify('filter', { prop: 'setAdjustmentValue', onPropertyChange: false, value: { adjustmentValue: this.lowerContext.filter } });
        parent.currObjType.isCustomCrop = false;
    }
    updateUrc(operation, previousObj, previousObjColl, previousPointColl, previousSelPointColl, previousCropObj, previousText, currentText, previousFilter, isCircleCrop) {
        const parent = this.parent;
        const obj = { isInitialLoaded: false };
        if (parent.currObjType.isUndoAction) {
            this.refreshUrc(true);
        }
        parent.notify('draw', { prop: 'isInitialLoaded', onPropertyChange: false, value: { object: obj } });
        if (!obj['isInitialLoaded'] && parent.allowUndoRedo) {
            const object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            const currentObj = object['currObj'];
            currentObj.objColl = extend([], parent.objColl, [], true);
            currentObj.pointColl = extend([], parent.pointColl, [], true);
            currentObj.afterCropActions = extend([], parent.afterCropActions, [], true);
            const selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            currentObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            if (operation === 'crop') {
                currentObj.currSelectionPoint = extend({}, parent.currSelectionPoint, {}, true);
            }
            this.undoRedoColl.push({ operation: operation, previousObj: previousObj, currentObj: currentObj,
                previousObjColl: previousObjColl, currentObjColl: currentObj.objColl,
                previousPointColl: previousPointColl, currentPointColl: currentObj.pointColl,
                previousSelPointColl: previousSelPointColl, currentSelPointColl: currentObj.selPointColl,
                previousCropObj: previousCropObj, currentCropObj: extend({}, parent.cropObj, {}, true),
                previousText: previousText, currentText: currentText, filter: previousFilter, isCircleCrop: isCircleCrop });
            if (!isBlazor()) {
                parent.notify('toolbar', { prop: 'enable-disable-btns', onPropertyChange: false });
            }
            else {
                parent.updateToolbar(parent.element, 'enableDisableToolbarBtn');
            }
        }
    }
    updateUrObj(objColl) {
        const parent = this.parent;
        if (parent.allowUndoRedo) {
            if (parent.currObjType.isUndoAction) {
                this.refreshUrc(true);
            }
            parent.objColl.push(parent.activeObj);
            const cropObj = extend({}, parent.cropObj, {}, true);
            const object = { currObj: {} };
            parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
            const obj = object['currObj'];
            obj.objColl = extend([], parent.objColl, [], true);
            obj.pointColl = extend([], parent.pointColl, [], true);
            obj.afterCropActions = extend([], parent.afterCropActions, [], true);
            const selPointCollObj = { selPointColl: null };
            parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
                value: { obj: selPointCollObj } });
            obj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
            this.undoRedoColl.push({ operation: 'shapeTransform', previousObj: obj, currentObj: obj,
                previousObjColl: objColl, currentObjColl: obj.objColl,
                previousPointColl: obj.pointColl, currentPointColl: obj.pointColl,
                previousSelPointColl: obj.selPointColl, currentSelPointColl: obj.selPointColl,
                previousCropObj: cropObj, currentCropObj: cropObj });
            parent.notify('selection', { prop: 'redrawShape', onPropertyChange: false,
                value: { obj: parent.objColl[parent.objColl.length - 1] } });
        }
    }
    updateUndoRedo() {
        const parent = this.parent;
        const prevCropObj = extend({}, parent.cropObj, {}, true);
        const object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        prevObj.objColl = extend([], parent.objColl, [], true);
        prevObj.pointColl = extend([], parent.pointColl, [], true);
        prevObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        parent.objColl.push(parent.activeObj);
        this.updateUrc('shapeTransform', prevObj, prevObj.objColl, prevObj.pointColl, prevObj.selPointColl, prevCropObj);
        parent.objColl.pop();
        parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: null } });
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        if (!isBlazor()) {
            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                    isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
            parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                    isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
        }
        else {
            parent.updateToolbar(parent.element, 'imageLoaded');
        }
    }
    getZeroZoomObjPointValue(obj, point) {
        const parent = this.parent;
        const object = { currObj: {} };
        parent.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const currentObj = object['currObj'];
        currentObj.objColl = extend([], parent.objColl, [], true);
        currentObj.pointColl = extend([], parent.pointColl, [], true);
        currentObj.afterCropActions = extend([], parent.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        parent.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        currentObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        const cropDimensionObj = { cropDimension: null };
        parent.notify('transform', { prop: 'getCropDimension', onPropertyChange: false, value: { obj: cropDimensionObj } });
        let getZeroZoomObjColl = extend([], parent.objColl, [], true);
        let getZeroZoomPointColl = extend([], parent.pointColl, [], true);
        const arrowObj = { arrowDimension: null };
        this.parent.notify('draw', { prop: 'getArrowDimension', onPropertyChange: false, value: { obj: arrowObj } });
        const tempArrowObj = extend({}, arrowObj['arrowDimension'], {}, true);
        if (parent.transform.zoomFactor > 0 && (obj.length > 0 || point.length > 0)) {
            parent.objColl = obj;
            parent.pointColl = point;
            const isUndoRedo = parent.isUndoRedo;
            if (parent.transform.zoomFactor !== 0) {
                parent.isUndoRedo = parent.isCropTab = true;
                parent.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
                const zoomSettings = extend({}, parent.zoomSettings, null, true);
                if (parent.transform.zoomFactor > 0) {
                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                        value: { zoomFactor: -parent.transform.zoomFactor, zoomPoint: null } });
                }
                else {
                    parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                        value: { zoomFactor: Math.abs(parent.transform.zoomFactor), zoomPoint: null } });
                }
                parent.zoomSettings = zoomSettings;
                parent.isCropTab = false;
                parent.isUndoRedo = isUndoRedo;
                getZeroZoomObjColl = extend([], parent.objColl, [], true);
                getZeroZoomPointColl = extend([], parent.pointColl, [], true);
                parent.objColl = [];
                parent.pointColl = [];
                parent.freehandCounter = 0;
                parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                    value: { obj: { selPointColl: [] } } });
                parent.notify('transform', { prop: 'setCropDimension', onPropertyChange: false,
                    value: { width: cropDimensionObj['cropDimension']['width'], height: cropDimensionObj['cropDimension']['height'] } });
                const maxDimension = { width: cropDimensionObj['cropDimension']['width'], height: cropDimensionObj['cropDimension']['height'] };
                maxDimension.width += (maxDimension.width * currentObj.defaultZoom);
                maxDimension.height += (maxDimension.height * currentObj.defaultZoom);
                parent.notify('draw', { prop: 'setZoomCropWidth', value: { width: maxDimension.width, height: maxDimension.height } });
                parent.notify('draw', { prop: 'setCurrentObj', onPropertyChange: false, value: { obj: currentObj } });
                parent.img.destLeft = currentObj.destPoints.startX;
                parent.img.destTop = currentObj.destPoints.startY;
                parent.panPoint.totalPannedPoint = currentObj.totalPannedPoint;
                parent.panPoint.totalPannedClientPoint = currentObj.totalPannedClientPoint;
                parent.panPoint.totalPannedInternalPoint = currentObj.totalPannedInternalPoint;
                parent.objColl = extend([], currentObj.objColl, [], true);
                parent.pointColl = extend([], currentObj.pointColl, [], true);
                parent.freehandCounter = parent.pointColl.length;
                parent.notify('draw', { prop: 'setArrowDimension', onPropertyChange: false, value: { arrowDimension: tempArrowObj } });
                parent.notify('freehand-draw', { prop: 'setSelPointColl', onPropertyChange: false,
                    value: { obj: { selPointColl: extend([], currentObj.selPointColl, [], true) } } });
                this.lowerContext.filter = 'none';
                parent.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
                parent.notify('freehand-draw', { prop: 'freehandRedraw', onPropertyChange: false,
                    value: { context: this.lowerContext, points: null } });
                parent.notify('freehand-draw', { prop: 'updateFHDCurPts', onPropertyChange: false });
                this.lowerContext.filter = currentObj.filter;
                if (parent.transform.degree !== 0) {
                    parent.notify('transform', { prop: 'drawPannedImage', onPropertyChange: false,
                        value: { xDiff: 0, yDiff: 0 } });
                }
            }
        }
        return { obj: getZeroZoomObjColl, point: getZeroZoomPointColl };
    }
}

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ImageEditor_1;
/**
 * This interface is used to specify settings for finetuning operations on images, including brightness, contrast, hue, saturation, exposure, opacity, and blur. It includes properties for setting minimum and maximum values for each of these options, as well as a default value.
 */
class FinetuneSettings extends ChildProperty {
}
__decorate([
    Property(null)
], FinetuneSettings.prototype, "brightness", void 0);
__decorate([
    Property(null)
], FinetuneSettings.prototype, "contrast", void 0);
__decorate([
    Property(null)
], FinetuneSettings.prototype, "hue", void 0);
__decorate([
    Property(null)
], FinetuneSettings.prototype, "saturation", void 0);
__decorate([
    Property(null)
], FinetuneSettings.prototype, "exposure", void 0);
__decorate([
    Property(null)
], FinetuneSettings.prototype, "opacity", void 0);
__decorate([
    Property(null)
], FinetuneSettings.prototype, "blur", void 0);
/**
 * An interface used to define the settings such as minimum, maximum, and default zoom factors, and the type of zooming which are available in the image editor control.
 */
class ZoomSettings extends ChildProperty {
}
__decorate([
    Property(null)
], ZoomSettings.prototype, "zoomTrigger", void 0);
__decorate([
    Property(1)
], ZoomSettings.prototype, "minZoomFactor", void 0);
__decorate([
    Property(10)
], ZoomSettings.prototype, "maxZoomFactor", void 0);
__decorate([
    Property(1)
], ZoomSettings.prototype, "zoomFactor", void 0);
__decorate([
    Property(null)
], ZoomSettings.prototype, "zoomPoint", void 0);
/**
 * This interface is used to specify settings for selection operations on images, including visibility, stroke color and fill color.
 */
class SelectionSettings extends ChildProperty {
}
__decorate([
    Property(true)
], SelectionSettings.prototype, "showCircle", void 0);
__decorate([
    Property(null)
], SelectionSettings.prototype, "strokeColor", void 0);
__decorate([
    Property(null)
], SelectionSettings.prototype, "fillColor", void 0);
/**
 * The Image Editor is a graphical user interface for editing images.
 *
 * {% codeBlock src='image-editor/default/index.md' %}{% endcodeBlock %}
 *
 * @remarks
 * The Image Editor component provides various image editing features such as zooming, cropping, rotating, inserting text and shapes (rectangles, ellipses, and lines), drawing freehand on top of an image, undo/redo, and more.
 *
 */
let ImageEditor = ImageEditor_1 = class ImageEditor extends Component {
    /**
     *
     * Constructor for creating the widget
     *
     * @param  {ImageEditorModel} options - Specifies the image editor model
     * @param  {string|HTMLDivElement} element - Specifies the target element
     */
    constructor(options, element) {
        super(options);
        /**
         *
         * Image Editor Private Properties
         */
        /** @hidden */
        this.isImageLoaded = false;
        /** @hidden */
        this.activeObj = { activePoint: { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 },
            flipObjColl: [], triangle: [], triangleRatio: [], rotatedAngle: 0 };
        // current object's ui interaction properties
        /** @hidden */
        this.currObjType = { shape: '', isDragging: false, isActiveObj: false, isText: false, isInitialText: false, isLine: false, isInitialLine: false,
            isCustomCrop: false, isZoomed: false, isUndoZoom: false, isUndoAction: false, isFiltered: false, isSave: false, isResize: false };
        /** @hidden */
        this.objColl = [];
        /** @hidden */
        // eslint-disable-next-line
        this.pointColl = {};
        /** @hidden */
        this.freehandCounter = 0;
        /** @hidden */
        this.points = [];
        /** @hidden */
        this.togglePen = false;
        /** @hidden */
        this.togglePan = false;
        /** @hidden */
        this.img = { destLeft: 0, destTop: 0, destWidth: 0, destHeight: 0, srcLeft: 0, srcTop: 0, srcWidth: 0, srcHeight: 0 };
        /** @hidden */
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.rotateFlipColl = [];
        // All prop values saved while cropping (to restore the image to its original state)
        /** @hidden */
        this.cropObj = { cropZoom: 0, defaultZoom: 0, totalPannedPoint: { x: 0, y: 0 }, totalPannedClientPoint: { x: 0, y: 0 },
            totalPannedInternalPoint: { x: 0, y: 0 }, tempFlipPanPoint: { x: 0, y: 0 }, activeObj: {}, rotateFlipColl: [],
            degree: 0, currFlipState: '', destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
            srcPoints: { startX: 0, startY: 0, width: 0, height: 0 }, filter: '', isBrightAdjust: false,
            zoomFactor: 0, previousZoomValue: 0 };
        // Stored transformations performed after cropping
        /** @hidden */
        this.afterCropActions = [];
        /** @hidden */
        this.transform = { degree: 0, currFlipState: '', zoomFactor: 0, cropZoomFactor: null, defaultZoomFactor: 0 };
        /** @hidden */
        this.panPoint = { currentPannedPoint: { x: 0, y: 0 }, totalPannedPoint: { x: 0, y: 0 }, totalPannedInternalPoint: { x: 0, y: 0 },
            totalPannedClientPoint: { x: 0, y: 0 } };
        /** @hidden */
        this.isUndoRedo = false;
        /** @hidden */
        this.isCropTab = false;
        /** @hidden */
        this.isCircleCrop = false;
        /** @hidden */
        this.fontSizeColl = [];
        /** @hidden */
        this.initialAdjustmentValue = '';
        /** @hidden */
        this.currentFilter = '';
        /** @hidden */
        this.canvasFilter = 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
            'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' + 'invert(0%)';
        /** @hidden */
        this.toolbarHeight = 0;
        /** @hidden */
        this.isPublicMethod = false;
        /** @hidden */
        this.isCropToolbar = false;
        /** @hidden */
        this.cursor = 'default';
        if (!isBlazor()) {
            ImageEditor_1.Inject(Crop, Draw, Selection, Transform, Export, ToolbarModule);
            ImageEditor_1.Inject(UndoRedo);
            ImageEditor_1.Inject(Filter);
            ImageEditor_1.Inject(Shape);
            ImageEditor_1.Inject(FreehandDrawing);
            if (element) {
                this.appendTo(element);
            }
        }
        else {
            new Crop(this);
            new Draw(this);
            new Filter(this);
            new FreehandDrawing(this);
            new Selection(this);
            new Shape(this);
            new Transform(this);
            new UndoRedo(this);
            new Export(this);
        }
    }
    /**
     * To provide the array of modules needed for component rendering.
     *
     * @returns {ModuleDeclaration[]} - To provide the array of modules needed for component rendering.
     * @hidden
     */
    requiredModules() {
        const modules = [];
        modules.push({ member: 'crop', args: [this] });
        modules.push({ member: 'draw', args: [this] });
        modules.push({ member: 'selection', args: [this] });
        modules.push({ member: 'transform', args: [this] });
        modules.push({ member: 'export', args: [this] });
        modules.push({ member: 'toolbar-module', args: [this] });
        modules.push({ member: 'undo-redo', args: [this] });
        modules.push({ member: 'filter', args: [this] });
        modules.push({ member: 'shape', args: [this] });
        modules.push({ member: 'freehand-draw', args: [this] });
        return modules;
    }
    preRender() {
        // pre render code snippets
        this.element.id = this.element.id || getUniqueID('ej2-image-editor');
        if (Browser.isDevice) {
            this.element.classList.add('e-device');
        }
        this.initializeThemeColl();
    }
    /**
     *
     * To Initialize the component rendering
     *
     * @private
     * @returns {void}
     */
    render() {
        this.initialize();
    }
    /**
     * To get component name.
     *
     * @returns {string} - Module Name
     * @private
     */
    getModuleName() {
        return 'image-editor';
    }
    /**
     *
     * To get the properties to be maintained in the persisted state.
     *
     * @returns {string} - Persist data
     * @private
     */
    getPersistData() {
        return this.addOnPersist([]);
    }
    /**
     *
     * Called internally if any of the property value changed.
     *
     * @param {ImageEditorModel} newProperties - Specifies new properties
     * @param {ImageEditorModel} oldProperties - Specifies old properties
     * @returns {void}
     * @private
     */
    onPropertyChanged(newProperties, oldProperties) {
        for (const prop of Object.keys(newProperties)) {
            switch (prop) {
                case 'cssClass':
                    if (oldProperties.cssClass) {
                        removeClass([this.element], oldProperties.cssClass.replace(/\s+/g, ' ').trim().split(' '));
                    }
                    if (newProperties.cssClass) {
                        addClass([this.element], newProperties.cssClass.replace(/\s+/g, ' ').trim().split(' '));
                    }
                    break;
                case 'disabled':
                    if (newProperties.disabled) {
                        this.element.classList.add('e-disabled');
                        this.unwireEvent();
                    }
                    else {
                        this.element.classList.remove('e-disabled');
                        this.wireEvent();
                    }
                    break;
                case 'height':
                    this.element.style.height = newProperties.height;
                    break;
                case 'width':
                    this.element.style.width = newProperties.width;
                    break;
                case 'theme':
                    if (newProperties.theme) {
                        if (this.theme && this.theme !== '') {
                            this.theme = this.toPascalCase(this.theme);
                        }
                        else {
                            this.theme = 'Bootstrap5';
                        }
                        this.upperContext.strokeStyle = this.themeColl[this.theme]['primaryColor'];
                        this.upperContext.fillStyle = this.themeColl[this.theme]['secondaryColor'];
                    }
                    break;
                case 'finetuneSettings':
                    if (newProperties.finetuneSettings) {
                        this.finetuneSettings = newProperties.finetuneSettings;
                        this.notify('filter', { prop: 'update-finetunes' });
                    }
                    break;
                case 'locale':
                    if (newProperties.locale) {
                        this.notify('toolbar', { prop: 'setLocale', onPropertyChange: false, value: { locale: newProperties.locale } });
                        this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    break;
                case 'allowUndoRedo':
                    if (newProperties.allowUndoRedo) {
                        this.allowUndoRedo = true;
                    }
                    else {
                        this.allowUndoRedo = false;
                    }
                    this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                            isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    break;
                case 'showQuickAccessToolbar':
                    if (newProperties.showQuickAccessToolbar) {
                        this.showQuickAccessToolbar = true;
                        this.notify('toolbar', { prop: 'create-qa-toolbar', onPropertyChange: false });
                        this.notify('toolbar', { prop: 'renderQAT', onPropertyChange: false, value: { isPenEdit: null } });
                    }
                    else {
                        this.showQuickAccessToolbar = false;
                        this.notify('toolbar', { prop: 'destroy-qa-toolbar', onPropertyChange: false });
                    }
                    break;
                case 'zoomSettings':
                    if (newProperties.zoomSettings) {
                        this.zoomSettings.zoomTrigger = newProperties.zoomSettings.zoomTrigger;
                    }
                    if (isNullOrUndefined(this.zoomSettings.zoomTrigger)) {
                        this.zoomSettings.zoomTrigger = (ZoomTrigger.MouseWheel | ZoomTrigger.Pinch | ZoomTrigger.Toolbar |
                            ZoomTrigger.Commands);
                        this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    else if ((newProperties.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar) {
                        this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                    }
                    break;
                case 'selectionSettings':
                    if (newProperties.selectionSettings) {
                        this.selectionSettings = newProperties.selectionSettings;
                        if (this.activeObj.shape) {
                            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
                            this.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: this.activeObj } });
                        }
                    }
                    break;
            }
        }
    }
    destroy() {
        let classList = [];
        this.element.removeAttribute('tabindex');
        if (this.cssClass) {
            classList = classList.concat(this.cssClass.replace(/\s+/g, ' ').trim().split(' '));
        }
        removeClass([this.element], classList);
        if (!this.element.getAttribute('class')) {
            this.element.removeAttribute('class');
        }
        if (!isBlazor()) {
            this.notify('toolbar', { prop: 'destroySubComponents', onPropertyChange: false });
            this.notify('destroyed', null);
            super.destroy();
        }
        else {
            this.element.classList.remove('e-image-editor');
        }
        this.unwireEvent();
        this.element.innerHTML = '';
    }
    initialize() {
        if (this.toolbarTemplate) {
            this.element.appendChild(this.createElement('div', {
                id: this.element.id + '_toolbarArea', className: 'e-toolbar-area'
            }));
            this.toolbarTemplateFn();
        }
        else {
            this.notify('toolbar', { prop: 'create-toolbar', onPropertyChange: false });
            this.notify('toolbar', { prop: 'create-contextual-toolbar', onPropertyChange: false });
        }
        this.createCanvas();
        if (this.showQuickAccessToolbar) {
            const canvasWrapper = document.querySelector('#' + this.element.id + '_canvasWrapper');
            canvasWrapper.appendChild(this.createElement('div', {
                id: this.element.id + '_quickAccessToolbarArea', className: 'e-quick-access-toolbar-area'
            }));
            const quickAccessToolbar = document.getElementById(this.element.id + '_quickAccessToolbarArea');
            quickAccessToolbar.style.position = 'absolute';
            quickAccessToolbar.style.display = 'none';
            if (this.activeObj) {
                quickAccessToolbar.style.left = this.activeObj.activePoint.startX + 'px';
                quickAccessToolbar.style.top = this.activeObj.activePoint.startY + 'px';
            }
            quickAccessToolbar.style.width = '100%';
        }
        if (this.quickAccessToolbarTemplate) {
            this.quickAccessToolbarTemplateFn();
        }
        else {
            this.notify('toolbar', { prop: 'create-qa-toolbar', onPropertyChange: false });
        }
        this.wireEvent();
        this.lowerContext = this.lowerCanvas.getContext('2d');
        this.upperContext = this.upperCanvas.getContext('2d');
        this.inMemoryContext = this.inMemoryCanvas.getContext('2d');
        this.lowerContext.filter = this.getDefaultFilter();
        this.notify('filter', { prop: 'setAdjustmentValue', onPropertyChange: false, value: { adjustmentValue: this.lowerContext.filter } });
        this.canvasFilter = this.lowerContext.filter;
        this.notify('toolbar', { prop: 'setInitialAdjustmentValue', onPropertyChange: false, value: { value: this.lowerContext.filter } });
        if (this.cssClass) {
            addClass([this.element], this.cssClass.replace(/\s+/g, ' ').trim().split(' '));
        }
        if (this.element) {
            createSpinner({
                target: this.element
            });
        }
        this.initializeZoomSettings();
    }
    /**
     *
     * This Method will add events to component (element, event, method, current reference)
     *
     * @returns {void}.
     */
    wireEvent() {
        EventHandler.add(document, 'keydown', this.keyDownEventHandler, this);
        EventHandler.add(document, 'keypress', this.keyUpEventHandler, this);
        EventHandler.add(this.upperCanvas, 'mousedown', this.mouseDownEventHandler, this);
        EventHandler.add(this.upperCanvas, 'mousemove', this.mouseMoveEventHandler, this);
        EventHandler.add(this.upperCanvas, 'mouseup', this.mouseUpEventHandler, this);
        EventHandler.add(document, 'mouseup', this.mouseUpEventHandler, this);
        EventHandler.add(this.lowerCanvas, 'mousedown', this.canvasMouseDownHandler, this);
        EventHandler.add(this.lowerCanvas, 'mousemove', this.canvasMouseMoveHandler, this);
        EventHandler.add(this.lowerCanvas, 'mouseup', this.canvasMouseUpHandler, this);
        EventHandler.add(document, 'mouseup', this.canvasMouseUpHandler, this);
        EventHandler.add(this.upperCanvas, 'touchstart', this.touchStartHandler, this);
        EventHandler.add(this.lowerCanvas, 'touchstart', this.touchStartHandler, this);
        EventHandler.add(this.lowerCanvas, 'mousewheel DOMMouseScroll', this.handleScroll, this);
        EventHandler.add(this.upperCanvas, 'mousewheel DOMMouseScroll', this.handleScroll, this);
        window.addEventListener('resize', this.windowResizeHandler.bind(this));
        if ((!Browser.isIos && Browser.info.name !== 'safari')) {
            screen.orientation.addEventListener('change', this.screenOrientation.bind(this));
        }
        this.notify('shape', { prop: 'wireEvent', onPropertyChange: false });
    }
    /**
     *
     * This Method will remove events from component
     *
     * @returns {void}.
     */
    unwireEvent() {
        EventHandler.remove(document, 'keydown', this.keyDownEventHandler);
        EventHandler.remove(document, 'keypress', this.keyUpEventHandler);
        EventHandler.remove(this.upperCanvas, 'mousedown', this.mouseDownEventHandler);
        EventHandler.remove(this.upperCanvas, 'mousemove', this.mouseMoveEventHandler);
        EventHandler.remove(this.upperCanvas, 'mouseup', this.mouseUpEventHandler);
        EventHandler.remove(document, 'mouseup', this.mouseUpEventHandler);
        EventHandler.remove(this.lowerCanvas, 'mousedown', this.canvasMouseDownHandler);
        EventHandler.remove(this.lowerCanvas, 'mousemove', this.canvasMouseMoveHandler);
        EventHandler.remove(this.lowerCanvas, 'mouseup', this.canvasMouseUpHandler);
        EventHandler.remove(document, 'mouseup', this.canvasMouseUpHandler);
        EventHandler.remove(this.upperCanvas, 'touchstart', this.touchStartHandler);
        EventHandler.remove(this.lowerCanvas, 'touchstart', this.touchStartHandler);
        EventHandler.remove(this.lowerCanvas, 'mousewheel DOMMouseScroll', this.handleScroll);
        EventHandler.remove(this.upperCanvas, 'mousewheel DOMMouseScroll', this.handleScroll);
        window.removeEventListener('resize', this.windowResizeHandler.bind(this));
        if ((!Browser.isIos && Browser.info.name !== 'safari')) {
            screen.orientation.removeEventListener('change', this.screenOrientation.bind(this));
        }
        this.notify('shape', { prop: 'unWireEvent', onPropertyChange: false });
        this.notify('selection', { prop: 'unWireEvent', onPropertyChange: false });
    }
    createCanvas() {
        this.element.style.boxSizing = 'border-box';
        const obj = { toolbarHeight: 0 };
        this.notify('toolbar', { prop: 'getToolbarHeight', value: { obj: obj } });
        const height = obj['toolbarHeight'];
        this.element.style.width = this.width;
        this.element.style.height = this.height;
        const canvasWrapper = this.element.appendChild(this.createElement('div', { id: this.element.id + '_canvasWrapper',
            className: 'e-canvas-wrapper', attrs: { style: 'height:' + (this.element.offsetHeight - height - 2) + 'px; width:' +
                    (this.element.offsetWidth - 2)
                    + 'px; position: relative; overflow: hidden; margin: 0 auto;' }
        }));
        this.lowerCanvas = canvasWrapper.appendChild(this.createElement('canvas', {
            id: this.element.id + '_lowerCanvas', attrs: { name: 'canvasImage' }
        }));
        this.upperCanvas = canvasWrapper.appendChild(this.createElement('canvas', {
            id: this.element.id + '_upperCanvas', attrs: { name: 'canvasImage' }
        }));
        this.inMemoryCanvas = this.createElement('canvas', {
            id: this.element.id + '_inMemoryCanvas', attrs: { name: 'canvasImage' }
        });
        this.textArea = canvasWrapper.appendChild(this.createElement('textarea', {
            id: this.element.id + '_textArea', className: 'e-textarea', attrs: { name: 'textArea' }
        }));
        const dialog = this.element.appendChild(this.createElement('div', {
            id: this.element.id + '_dialog', className: 'e-dialog'
        }));
        dialog.style.display = 'none';
        this.textArea.setAttribute('spellcheck', 'false');
        this.textArea.style.lineHeight = 'normal';
        this.lowerCanvas.style.width = this.upperCanvas.style.width = this.inMemoryCanvas.style.width = '100%';
        this.lowerCanvas.style.height = this.upperCanvas.style.height = this.inMemoryCanvas.style.height = '100%';
        this.upperCanvas.style.position = this.lowerCanvas.style.position = this.textArea.style.position = 'absolute';
        this.textArea.style.backgroundColor = 'transparent';
        this.textArea.style.display = 'none';
        this.textArea.style.resize = 'none';
        this.lowerContext = this.lowerCanvas.getContext('2d');
        this.baseImg = this.createElement('img', {
            id: this.element.id + '_orgImg', attrs: { name: 'Image', crossorigin: 'anonymous' }
        });
        this.upperCanvas.style.cursor = this.cursor = 'default';
        this.upperCanvas.style.display = 'block';
        this.upperContext = this.upperCanvas.getContext('2d');
    }
    touchStartHandler(e) {
        this.notify('selection', { prop: 'touchStartHandler', onPropertyChange: false, value: { e: e } });
    }
    mouseDownEventHandler(e) {
        this.notify('selection', { prop: 'mouseDownEventHandler', onPropertyChange: false, value: { e: e } });
    }
    mouseMoveEventHandler(e) {
        this.notify('selection', { prop: 'mouseMoveEventHandler', onPropertyChange: false, value: { e: e } });
    }
    mouseUpEventHandler(e) {
        this.notify('selection', { prop: 'mouseUpEventHandler', onPropertyChange: false, value: { e: e } });
    }
    keyDownEventHandler(e) {
        this.notify('selection', { prop: 'keyDownEventHandler', onPropertyChange: false, value: { e: e } });
    }
    keyUpEventHandler(e) {
        // eslint-disable-next-line
        if (this.textArea.style.display === 'block' && e.target.id === this.element.id + '_textArea') {
            this.notify('selection', { prop: 'textKeyDown', value: { e: e } });
        }
    }
    canvasMouseDownHandler(e) {
        this.notify('selection', { prop: 'canvasMouseDownHandler', onPropertyChange: false, value: { e: e } });
    }
    canvasMouseMoveHandler(e) {
        this.notify('selection', { prop: 'canvasMouseMoveHandler', onPropertyChange: false, value: { e: e } });
    }
    canvasMouseUpHandler(e) {
        this.notify('selection', { prop: 'canvasMouseUpHandler', onPropertyChange: false, value: { e: e } });
    }
    handleScroll(e) {
        this.notify('selection', { prop: 'handleScroll', onPropertyChange: false, value: { e: e } });
    }
    adjustToScreen() {
        this.update();
    }
    screenOrientation() {
        if (Browser.isDevice) {
            setTimeout(this.adjustToScreen.bind(this), 100);
        }
    }
    windowResizeHandler() {
        if (!Browser.isDevice && this.element.classList.contains('e-image-editor')) {
            this.adjustToScreen();
        }
    }
    notifyResetForAllModules() {
        const modules = this.requiredModules();
        for (let i = 0; i < modules.length; i++) {
            this.notify(modules[i].member, { prop: 'reset', onPropertyChange: false });
        }
    }
    allowShape(x, y) {
        this.isPublicMethod = true;
        const obj = { inRange: false };
        this.notify('shape', { prop: 'isPointsInRange', onPropertyChange: false,
            value: { x: x, y: y, obj: obj } });
        return obj['inRange'];
    }
    /**
     * Clears the current selection performed in the image editor.
     *
     * @returns {void}.
     */
    clearSelection() {
        this.notify('selection', { prop: 'clearSelection', onPropertyChange: false });
    }
    /**
     * Crops an image based on the selection done in the image editor.
     *
     * {% codeBlock src='image-editor/crop/index.md' %}{% endcodeBlock %}
     *
     * @remarks
     * The selection can be done through programmatically using the 'select' method or through UI interactions.
     *
     * @returns {boolean}.
     *
     */
    crop() {
        const obj = { isCrop: false };
        this.notify('crop', { prop: 'crop', onPropertyChange: false, value: { obj: obj } });
        return obj['isCrop'];
    }
    /**
     * Flips an image by horizontally or vertically in the image editor.
     *
     * {% codeBlock src='image-editor/zoom/index.md' %}{% endcodeBlock %}
     *
     * @param { Direction } direction - Specifies the direction to flip the image.
     * A horizontal direction for horizontal flipping and vertical direction for vertical flipping.
     *
     * @remarks
     * It flips the shapes including rectangle, circle, line, text, and freehand drawings.
     *
     * @returns {void}.
     *
     */
    flip(direction) {
        this.notify('transform', { prop: 'flip', value: { direction: direction } });
        this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
    }
    /**
     * Returns an image as ImageData to load it in to a canvas.
     *
     * @remarks
     * The data returned from this method is directly drawn in a canvas using 'putImageData' method.
     * And then the user can get the base64 string from the canvas using toDataURL method.
     *
     * @returns {ImageData}.
     */
    getImageData() {
        const obj = { canvas: null };
        this.notify('export', { prop: 'exportToCanvas', value: { object: obj } });
        return obj['canvas'].getContext('2d').getImageData(0, 0, obj['canvas'].width, obj['canvas'].height);
    }
    /**
     *  Opens an image as URL or ImageData for editing in an image editor.
     *
     * @param {string | ImageData } data - Specifies url of the image or image data.
     *
     * @remarks
     * The supported file types are JPG, JPEG, PNG, and SVG.
     *
     * @returns {void}.
     */
    open(data) {
        this.notify('draw', { prop: 'open', value: { data: data } });
    }
    /**
     * Reset all the changes done in an image editor and revert to original image.
     *
     * @remarks
     * The undo redo collection also cleared while resetting the image editor.
     *
     * @returns {void}.
     */
    reset() {
        const obj = { isErrorImage: false };
        this.notify('draw', { prop: 'getErrorImage', value: { obj: obj } });
        if (!this.disabled && !obj['isErrorImage']) {
            this.clearContext(this.inMemoryContext);
            this.clearContext(this.lowerContext);
            this.clearContext(this.upperContext);
            this.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            if (!isBlazor()) {
                this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                        isApplyBtn: false, isCropping: false, isZooming: null, cType: null } });
                if (Browser.isDevice && document.getElementById(this.element.id + '_bottomToolbar')) {
                    getComponent(document.getElementById(this.element.id + '_bottomToolbar'), 'toolbar').destroy();
                    this.notify('toolbar', { prop: 'create-bottom-toolbar', onPropertyChange: false });
                }
            }
            this.currObjType.isUndoAction = this.isUndoRedo = this.togglePan = this.togglePen = this.isImageLoaded = false;
            this.isCircleCrop = this.isCropTab = false;
            this.objColl = [];
            this.transform.degree = 0;
            this.upperCanvas.style.display = 'block';
            this.transform.currFlipState = '';
            this.upperCanvas.style.cursor = this.cursor = this.lowerCanvas.style.cursor = 'default';
            this.lowerContext.lineWidth = this.upperContext.lineWidth = undefined;
            this.textArea.value = this.textArea.textContent = '';
            this.textArea.style.display = 'none';
            this.lowerContext.filter = this.canvasFilter = this.getDefaultFilter();
            this.img.destLeft = this.img.destTop = this.img.srcLeft = this.img.srcTop = 0;
            this.img.destWidth = this.img.destHeight = this.img.srcWidth = this.img.srcHeight = null;
            this.currSelectionPoint = null;
            this.panPoint.currentPannedPoint = { x: 0, y: 0 };
            this.rotateFlipColl = [];
            this.points = [];
            this.pointColl = {};
            this.freehandCounter = 0;
            this.notify('draw', { prop: 'resetPanPoints' });
            this.lowerCanvas.style.left = this.upperCanvas.style.left = '';
            this.fontSizeColl = [];
            this.lowerCanvas.style.top = this.upperCanvas.style.top = '';
            this.lowerCanvas.style.maxWidth = this.upperCanvas.style.maxWidth = '';
            this.lowerCanvas.style.maxHeight = this.upperCanvas.style.maxHeight = '';
            this.transform.defaultZoomFactor = this.transform.zoomFactor = 0;
            this.transform.cropZoomFactor = null;
            this.currObjType = { shape: '', isDragging: false, isActiveObj: false, isText: false, isInitialText: false, isLine: false,
                isInitialLine: false, isCustomCrop: false, isZoomed: false, isUndoZoom: false,
                isUndoAction: false, isFiltered: false, isSave: false, isResize: false };
            this.cropObj = { cropZoom: 0, defaultZoom: 0, totalPannedPoint: { x: 0, y: 0 }, totalPannedClientPoint: { x: 0, y: 0 },
                totalPannedInternalPoint: { x: 0, y: 0 }, tempFlipPanPoint: { x: 0, y: 0 }, activeObj: {},
                rotateFlipColl: [], degree: 0, currFlipState: '', zoomFactor: 0, previousZoomValue: 0,
                destPoints: { startX: 0, startY: 0, width: 0, height: 0 },
                srcPoints: { startX: 0, startY: 0, width: 0, height: 0 }, filter: '', isBrightAdjust: false };
            this.afterCropActions = [];
            this.currentFilter = '';
            const obj = { initialZoomValue: false };
            this.notify('draw', { prop: 'getInitialZoomValue', onPropertyChange: false, value: { obj: obj } });
            if (obj['initialZoomValue']) {
                this.setProperties({ zoomSettings: { zoomFactor: obj['initialZoomValue'] } }, true);
            }
            if (document.getElementById(this.element.id + '_quickAccessToolbarArea')) {
                document.getElementById(this.element.id + '_quickAccessToolbarArea').style.display = 'none';
            }
            this.notifyResetForAllModules();
            this.notify('filter', { prop: 'update-finetunes' });
            this.isImageLoaded = false;
            this.notify('draw', { prop: 'update-canvas', onPropertyChange: false });
            this.isImageLoaded = true;
            if (!isBlazor()) {
                if (this.element.querySelector('.e-contextual-toolbar-wrapper')) {
                    this.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
                }
                this.notify('toolbar', { prop: 'refresh-dropdown-btn', value: { isDisabled: false } });
                this.notify('toolbar', { prop: 'enable-disable-btns' });
            }
        }
    }
    /**
     * Rotate an image to clockwise and anti-clockwise.
     *
     * {% codeBlock src='image-editor/rotate/index.md' %}{% endcodeBlock %}
     *
     * @param {number} degree - Specifies a degree to rotate an image.
     * A positive integer value for clockwise and negative integer value for anti-clockwise rotation.
     *
     * @remarks
     * It rotated the shapes including rectangle, circle, line, text, and freehand drawings.
     *
     * @returns {boolean}.
     *
     */
    rotate(degree) {
        const obj = { isRotate: false };
        this.notify('transform', { prop: 'rotate', value: { degree: degree, obj: obj } });
        this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
        return obj['isRotate'];
    }
    /**
     * Export an image using the specified file name and the extension.
     *
     * @param {string} type - Specifies a format of image to be saved.
     * @param {string} fileName – Specifies a file name to be saved
     *
     * @remarks
     * The supported file types are JPG, JPEG, PNG, and SVG.
     *
     * @returns {void}.
     */
    export(type, fileName) {
        this.notify('export', { prop: 'export', onPropertyChange: false, value: { type: type, fileName: fileName } });
    }
    /**
     * Perform selection in an image editor. The selection helps to crop an image.
     *
     * {% codeBlock src='image-editor/select/index.md' %}{% endcodeBlock %}
     *
     * @param {string} type - Specifies the shape - circle / square / custom selection / pre-defined ratios.
     * @param {number} startX – Specifies the start x-coordinate point of the selection.
     * @param {number} startY – Specifies the start y-coordinate point of the selection.
     * @param {number} width - Specifies the width of the selection area.
     * @param {number} height - Specifies the height of the selection area.
     *
     * @remarks
     * The selection UI is based on the 'theme' property.
     *
     * @returns {void}.
     *
     */
    select(type, startX, startY, width, height) {
        this.notify('draw', { prop: 'select', onPropertyChange: false,
            value: { type: type, startX: startX, startY: startY, width: width, height: height } });
    }
    /**
     * Enable or disable a freehand drawing option in an Image Editor.
     *
     * @param {boolean} value - Specifies a value whether to enable or disable freehand drawing.
     *
     * @returns {void}.
     * @private
     */
    freeHandDraw(value) {
        this.notify('freehand-draw', { prop: 'freeHandDraw', onPropertyChange: false, value: { value: value } });
    }
    /**
     * Enable or disable a freehand drawing in an Image Editor.
     *
     * @param {boolean} value - Specifies a value whether to enable or disable freehand drawing.
     *
     * @remarks
     * User can directly drawing on a canvas after enabling this option.
     *
     * @returns {void}.
     */
    freehandDraw(value) {
        if (!this.disabled && this.isImageLoaded) {
            this.freeHandDraw(value);
        }
    }
    /**
     * Enable or disable a panning on the Image Editor.
     *
     * @param {boolean} value - Specifies a value whether enable or disable panning.
     *
     * @remarks
     * This option will take into effect once the image's visibility is hidden when zooming an image or selection has been performed.
     *
     * @returns {void}.
     */
    pan(value) {
        this.notify('transform', { prop: 'pan', onPropertyChange: false, value: { value: value } });
    }
    /**
     * Zoom in or out on a point in the image editor.
     *
     * @param {number} zoomFactor - The percentage-based zoom factor to use (e.g. 20 for 2x zoom).
     * @param {Point} zoomPoint - The point in the image editor to zoom in/out on.
     *
     * @remarks
     * Zooming directly enables the panning option when the image's visibility is hidden.
     * User can disable it by using 'Pan' method.
     * @returns {void}
     *
     */
    zoom(zoomFactor, zoomPoint) {
        this.notify('transform', { prop: 'zoom', onPropertyChange: false,
            value: { zoomFactor: zoomFactor, zoomPoint: zoomPoint } });
    }
    /**
     * Draw ellipse on an image.
     *
     * {% codeBlock src='image-editor/ellipse/index.md' %}{% endcodeBlock %}
     *
     * @param {number} x - Specifies x-coordinate of ellipse.
     * @param {number} y - Specifies y-coordinate of ellipse.
     * @param {number} radiusX - Specifies the radius x point for the ellipse.
     * @param {number} radiusY - Specifies the radius y point for the ellipse.
     * @param {number} strokeWidth - Specifies the stroke width of ellipse.
     * @param {string} strokeColor - Specifies the stroke color of ellipse.
     * @param {string} fillColor - Specifies the fill color of the ellipse.
     * @returns {boolean}.
     *
     */
    drawEllipse(x, y, radiusX, radiusY, strokeWidth, strokeColor, fillColor) {
        let isEllipse = false;
        const isPointsInRange = this.allowShape(x, y);
        if (!this.disabled && this.isImageLoaded && (isPointsInRange || (isNullOrUndefined(x) && isNullOrUndefined(y)))) {
            isEllipse = true;
            this.notify('shape', { prop: 'drawEllipse', onPropertyChange: false, value: { x: x, y: y, radiusX: radiusX, radiusY: radiusY,
                    strokeWidth: strokeWidth, strokeColor: strokeColor, fillColor: fillColor } });
        }
        return isEllipse;
    }
    /**
     * Draw line on an image.
     *
     * @param {number} startX – Specifies start point x-coordinate of line.
     * @param {number} startY – Specifies start point y-coordinate of line.
     * @param {number} endX - Specifies end point x-coordinates of line.
     * @param {number} endY - Specifies end point y-coordinates of the line.
     * @param {number} strokeWidth - Specifies the stroke width of line.
     * @param {string} strokeColor - Specifies the stroke color of line.
     * @returns {boolean}.
     */
    drawLine(startX, startY, endX, endY, strokeWidth, strokeColor) {
        let isLine = false;
        const isPointsInRange = this.allowShape(startX, startY);
        if (!this.disabled && this.isImageLoaded && (isPointsInRange || (isNullOrUndefined(startX) && isNullOrUndefined(startY)))) {
            isLine = true;
            this.notify('shape', { prop: 'drawLine', onPropertyChange: false, value: { startX: startX, startY: startY, endX: endX,
                    endY: endY, strokeWidth: strokeWidth, strokeColor: strokeColor } });
        }
        return isLine;
    }
    /**
     * Draw arrow on an image.
     *
     * @param {number} startX – Specifies start point x-coordinate of arrow.
     * @param {number} startY – Specifies start point y-coordinate of arrow.
     * @param {number} endX - Specifies end point x-coordinates of arrow.
     * @param {number} endY - Specifies end point y-coordinates of the arrow.
     * @param {number} strokeWidth - Specifies the stroke width of arrow.
     * @param {string} strokeColor - Specifies the stroke color of arrow.
     * @param {ArrowheadType} arrowStart – Specifies the type of arrowhead for start position. The default value is ‘None’.
     * @param {ArrowheadType} arrowEnd – Specifies the type of arrowhead for end position. The default value is ‘SolidArrow’.
     * @returns {boolean}.
     */
    drawArrow(startX, startY, endX, endY, strokeWidth, strokeColor, arrowStart, arrowEnd) {
        let isArrow = false;
        const isPointsInRange = this.allowShape(startX, startY);
        if (!this.disabled && this.isImageLoaded && (isPointsInRange || (isNullOrUndefined(startX) && isNullOrUndefined(startY)))) {
            isArrow = true;
            this.notify('shape', { prop: 'drawArrow', onPropertyChange: false, value: { startX: startX, startY: startY, endX: endX,
                    endY: endY, strokeWidth: strokeWidth, strokeColor: strokeColor, arrowStart: arrowStart, arrowEnd: arrowEnd } });
        }
        return isArrow;
    }
    /**
     * Draw path on an image.
     *
     * @param {Point[]} pointColl – Specifies collection of start and end x, y-coordinates of path.
     * @param {number} strokeWidth - Specifies the stroke width of path.
     * @param {string} strokeColor - Specifies the stroke color of path.
     * @returns {boolean}.
     */
    drawPath(pointColl, strokeWidth, strokeColor) {
        this.isPublicMethod = true;
        const obj = { inRange: false };
        let isPath = false;
        if (pointColl && pointColl.length > 0) {
            for (let i = 0; i < pointColl.length; i++) {
                if (obj['inRange']) {
                    break;
                }
                this.notify('shape', { prop: 'isPointsInRange', onPropertyChange: false,
                    value: { x: pointColl[i].x, y: pointColl[i].y, obj: obj } });
            }
        }
        if (!this.disabled && this.isImageLoaded && (obj['inRange'] || isNullOrUndefined(pointColl))) {
            isPath = true;
            this.notify('shape', { prop: 'drawPath', onPropertyChange: false, value: { pointColl: pointColl,
                    strokeWidth: strokeWidth, strokeColor: strokeColor } });
        }
        return isPath;
    }
    /**
     * Draw a rectangle on an image.
     *
     * @param {number} x - Specifies x-coordinate of rectangle.
     * @param {number} y - Specifies y-coordinate of rectangle.
     * @param {number} width - Specifies the width of the rectangle.
     * @param {number} height - Specifies the height of the rectangle.
     * @param {number} strokeWidth - Specifies the stroke width of rectangle.
     * @param {string} strokeColor - Specifies the stroke color of rectangle.
     * @param {string} fillColor - Specifies the fill color of the rectangle.
     * @returns {boolean}.
     */
    drawRectangle(x, y, width, height, strokeWidth, strokeColor, fillColor) {
        let isRectangle = false;
        const isPointsInRange = this.allowShape(x, y);
        if (!this.disabled && this.isImageLoaded && (isPointsInRange || (isNullOrUndefined(x) && isNullOrUndefined(y)))) {
            isRectangle = true;
            this.notify('shape', { prop: 'drawRectangle', onPropertyChange: false, value: { x: x, y: y, width: width, height: height,
                    strokeWidth: strokeWidth, strokeColor: strokeColor, fillColor: fillColor } });
        }
        return isRectangle;
    }
    /**
     * Draw a text on an image.
     *
     * {% codeBlock src='image-editor/text/index.md' %}{% endcodeBlock %}
     *
     * @param {number} x - Specifies x-coordinate of text.
     * @param {number} y - Specifies y-coordinate of text.
     * @param {string} text - Specifies the text to add on an image.
     * @param {string} fontFamily - Specifies the font family of the text.
     * @param {number} fontSize - Specifies the font size of the text.
     * @param {boolean} bold - Specifies whether the text is bold or not.
     * @param {boolean} italic - Specifies whether the text is italic or not.
     * @param {string} color - Specifies font color of the text.
     * @returns {boolean}.
     *
     */
    drawText(x, y, text, fontFamily, fontSize, bold, italic, color) {
        let isText = false;
        const isPointsInRange = this.allowShape(x, y);
        if (!this.disabled && this.isImageLoaded && (isPointsInRange || (isNullOrUndefined(x) && isNullOrUndefined(y)))) {
            isText = true;
            this.notify('shape', { prop: 'drawText', onPropertyChange: false, value: { x: x, y: y, text: text, fontFamily: fontFamily,
                    fontSize: fontSize, bold: bold, italic: italic, color: color } });
        }
        return isText;
    }
    /**
     * Select a shape based on the given shape id.
     * Use 'getShapeSettings' method to get the shape id which is then passed to perform selection.
     *
     * {% codeBlock src='image-editor/selectShape/index.md' %}{% endcodeBlock %}
     *
     * @param {string} id - Specifies the shape id to select a shape on an image.
     * @returns {boolean}.
     *
     */
    selectShape(id) {
        const obj = { isSelected: false };
        this.notify('shape', { prop: 'selectShape', onPropertyChange: false, value: { id: id, obj: obj } });
        return obj['isSelected'];
    }
    /**
     * Deletes a shape based on the given shape id.
     * Use 'getShapeSettings' method to get the shape id which is then passed to perform selection.
     *
     * {% codeBlock src='image-editor/deleteShape/index.md' %}{% endcodeBlock %}
     *
     * @param {string} id - Specifies the shape id to delete the shape on an image.
     * @returns {void}.
     *
     */
    deleteShape(id) {
        this.notify('shape', { prop: 'deleteShape', onPropertyChange: false, value: { id: id } });
    }
    /**
     * Get particular shapes details based on id of the shape which is drawn on an image editor.
     *
     * {% codeBlock src='image-editor/getShapeSetting/index.md' %}{% endcodeBlock %}
     *
     * @param {string} id - Specifies the shape id on an image.
     * @returns {ShapeSettings}.
     *
     */
    getShapeSetting(id) {
        const shapeDetails = {};
        this.notify('shape', { prop: 'getShapeSetting', onPropertyChange: false,
            value: { id: id, obj: shapeDetails } });
        return shapeDetails;
    }
    /**
     * Get all the shapes details which is drawn on an image editor.
     *
     * @returns {ShapeSettings[]}.
     */
    getShapeSettings() {
        const obj = { shapeDetailsColl: [] };
        this.notify('shape', { prop: 'getShapeSettings', onPropertyChange: false, value: { obj: obj } });
        return obj['shapeDetailsColl'];
    }
    /**
     * To refresh the Canvas Wrapper.
     *
     * @returns {void}.
     */
    update() {
        this.notify('transform', { prop: 'update' });
    }
    /**
     * Finetuning an image with the given type of finetune and its value in the image editor.
     *
     * @param {ImageFinetuneOption } finetuneOption - Specifies the finetune options to be performed in the image.
     * @param {number } value - Specifies the value for finetuning the image.
     *
     * @remarks
     * The finetuning will not affect the shapes background and border color.
     *
     * @returns {void}.
     *
     */
    finetuneImage(finetuneOption, value) {
        if (!this.disabled && this.isImageLoaded) {
            this.notify('filter', { prop: 'finetuneImage', value: { value: value, option: finetuneOption } });
        }
    }
    /**
     * Filtering an image with the given type of filters.
     *
     * @param {ImageFilterOption } filterOption - Specifies the filter options to the image.
     *
     * @remarks
     * The filtering will not affect the shape's background and border color.
     * @returns {void}.
     */
    applyImageFilter(filterOption) {
        if (!this.disabled && this.isImageLoaded) {
            this.notify('filter', { prop: 'applyImageFilter', value: { option: filterOption.toString() } });
            this.canvasFilter = this.lowerContext.filter;
            this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
        }
    }
    /**
     * Reverse the last action which performed by the user in the Image Editor.
     *
     * @remarks
     * This method will take into effect once the 'allowUndoRedo' property is enabled.
     *
     * @returns {void}.
     */
    undo() {
        this.notify('undo-redo', { prop: 'undo', onPropertyChange: false });
    }
    /**
     * Redo the last user action that was undone by the user or `undo` method.
     *
     * @remarks
     * This method will take into effect once the 'allowUndoRedo' property is enabled.
     * @returns {void}.
     */
    redo() {
        this.notify('undo-redo', { prop: 'redo', onPropertyChange: false });
    }
    /**
     * Get the dimension of an image in the image editor such as x, y, width, and height.
     * The method helps to get dimension after cropped an image.
     *
     * @returns {Dimension}.
     * A Dimension object containing the x, y, width, and height of an image.
     */
    getImageDimension() {
        return { x: this.img.destLeft, y: this.img.destTop, width: this.img.destWidth, height: this.img.destHeight };
    }
    // Toolbar related codes
    toolbarTemplateFn() {
        let template;
        const templateID = this.element.id + '_toolbar';
        const toolbarArea = this.element.querySelector('#' + this.element.id + '_toolbarArea');
        if (this.toolbarTemplate) {
            this.toolbarFn = this.templateParser(this.toolbarTemplate);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (this.isReact) {
                template = this.toolbarFn({ type: 'toolbar' }, this, 'Template', templateID)[0];
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            else if (this.isAngular) {
                const templateColl = this.toolbarFn({ type: 'toolbar' }, this, 'Template', templateID);
                template = (templateColl[0].nodeType === 3) ? templateColl[1] : templateColl[0];
            }
            else {
                template = this.toolbarFn({ type: 'toolbar' }, this, 'Template', templateID)[0];
            }
            toolbarArea.appendChild(template);
            this.toolbarHeight = toolbarArea.clientHeight;
            this.notify('toolbar', { prop: 'setToolbarHeight', value: { height: this.toolbarHeight } });
            this['renderReactTemplates']();
        }
    }
    quickAccessToolbarTemplateFn() {
        let template;
        const templateID = this.element.id + '_quickAccessToolbar';
        const toolbarArea = this.element.querySelector('#' + this.element.id + '_quickAccessToolbarArea');
        if (this.quickAccessToolbarTemplate) {
            this.qatFn = this.templateParser(this.quickAccessToolbarTemplate);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (this.isReact) {
                template = this.qatFn({ type: 'toolbar' }, this, 'Template', templateID)[0];
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }
            else if (this.isAngular) {
                const templateColl = this.qatFn({ type: 'toolbar' }, this, 'Template', templateID);
                template = (templateColl[0].nodeType === 3) ? templateColl[1] : templateColl[0];
            }
            else {
                template = this.qatFn({ type: 'toolbar' }, this, 'Template', templateID)[0];
            }
            toolbarArea.appendChild(template);
            this['renderReactTemplates']();
        }
    }
    templateParser(template) {
        if (template) {
            try {
                if (typeof template !== 'function' && document.querySelectorAll(template).length) {
                    return compile(document.querySelector(template).innerHTML.trim());
                }
                else {
                    return compile(template);
                }
            }
            catch (error) {
                return compile(template);
            }
        }
        return undefined;
    }
    // Common codes for EJ2 and Blazor
    getTextFromId(id) {
        const idToValue = { '1': 'none', '2': 'bar', '3': 'arrow', '4': 'arrowSolid',
            '5': 'circle', '6': 'circleSolid', '7': 'square', '8': 'squareSolid' };
        return idToValue[`${id}`];
    }
    getFinetuneOption(type) {
        const typeToOption = { 'brightness': ImageFinetuneOption.Brightness, 'contrast': ImageFinetuneOption.Contrast,
            'hue': ImageFinetuneOption.Hue, 'saturation': ImageFinetuneOption.Saturation, 'opacity': ImageFinetuneOption.Opacity,
            'blur': ImageFinetuneOption.Blur, 'exposure': ImageFinetuneOption.Exposure };
        return typeToOption[`${type}`];
    }
    setPenStroke(args) {
        this.notify('freehand-draw', { prop: 'setPenStrokeWidth', onPropertyChange: false, value: { value: parseInt(args, 10) } });
    }
    updateFreehandDrawColorChange() {
        const obj = { tempFreeHandDrawEditingStyles: null };
        this.notify('freehand-draw', { prop: 'getTempFreeHandDrawEditingStyles', value: { obj: obj } });
        this.notify('freehand-draw', { prop: 'color-change', value: { color: obj['tempFreeHandDrawEditingStyles'].strokeColor } });
    }
    setInitialZoomState() {
        this.objColl.push(this.activeObj);
        this.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        const isUndoRedo = this.isUndoRedo;
        this.isCropTab = false;
        this.isUndoRedo = true;
        if (this.transform.cropZoomFactor && this.transform.cropZoomFactor > 0) {
            this.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                value: { zoomFactor: -this.transform.cropZoomFactor, zoomPoint: null } });
        }
        else {
            this.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                value: { zoomFactor: Math.abs(this.transform.cropZoomFactor), zoomPoint: null } });
        }
        this.isUndoRedo = isUndoRedo;
        this.panPoint.totalPannedPoint = { x: 0, y: 0 };
        this.transform.cropZoomFactor = 0;
        this.notify('freehand-draw', { prop: 'updateFHDColl', onPropertyChange: false });
        this.activeObj = extend({}, this.objColl[this.objColl.length - 1], {}, true);
        this.objColl.pop();
        this.isCropTab = true;
        this.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: this.activeObj } });
    }
    /**
     * Set the old item Transform item state.
     *
     * @hidden
     * @returns {void}.
     */
    updateCropTransformItems() {
        this.prevCurrSelectionPoint = extend({}, this.currSelectionPoint, {}, true);
        const object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const currentObj = object['currObj'];
        currentObj.objColl = extend([], this.objColl, [], true);
        currentObj.pointColl = extend([], this.pointColl, [], true);
        currentObj.afterCropActions = extend([], this.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        currentObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.cancelCropSelection = { operation: 'cropTransform', previousObj: currentObj, currentObj: currentObj,
            previousObjColl: currentObj.objColl, currentObjColl: currentObj.objColl,
            previousPointColl: currentObj.pointColl, currentPointColl: currentObj.pointColl,
            previousSelPointColl: currentObj.selPointColl, currentSelPointColl: currentObj.selPointColl,
            previousCropObj: extend({}, this.cropObj, {}, true),
            currentCropObj: extend({}, this.cropObj, {}, true),
            previousText: null, currentText: null, filter: null, isCircleCrop: this.isCircleCrop };
    }
    /**
     * Get the pascal case.
     *
     * @param { string } str - Specifies the string to convert to pascal case.
     * @param { Object } obj - Specifies the string to convert to pascal case.
     * @hidden
     * @returns {string}.
     * A pascal case string.
     */
    toPascalCase(str, obj) {
        let strArr = [];
        if (!isNullOrUndefined(str)) {
            strArr = str.toLowerCase().split('-');
        }
        for (let i = 0; i < strArr.length; i++) {
            strArr[i] = strArr[i].charAt(0).toUpperCase() + strArr[i].slice(1);
        }
        if (obj) {
            obj['maxText'] = strArr.join('');
        }
        return strArr.join('');
    }
    /**
     * Get the font sizes.
     *
     * @hidden
     * @returns {DropDownButtonItemModel[]}.
     * A font size collections.
     */
    getFontSizes() {
        const items = [];
        this.fontSizeColl = [];
        let fontSize;
        if (this.transform.degree === 0 || this.transform.degree % 180 === 0) {
            fontSize = this.img.destWidth / 25;
        }
        else {
            fontSize = this.img.destHeight / 25;
        }
        for (let i = 1; i <= 10; i++) {
            this.fontSizeColl.push({ text: (i * (Math.round(fontSize / 2))).toString() });
            items.push({ text: (i.toString()) });
        }
        return items;
    }
    /**
     * Handles the OK button operation
     *
     * @param { boolean } isMouseDown - Specifies whether it is a mouse down.
     * @hidden
     * @returns {void}.
     */
    okBtn(isMouseDown) {
        let isCropSelection = false;
        let splitWords;
        if (this.activeObj.shape !== undefined) {
            splitWords = this.activeObj.shape.split('-');
        }
        if (splitWords === undefined && this.currObjType.isCustomCrop) {
            isCropSelection = true;
        }
        else if (splitWords !== undefined && splitWords[0] === 'crop') {
            isCropSelection = true;
        }
        const selElem = this.element.querySelector('.e-contextual-toolbar-wrapper .e-toolbar-item.e-selected');
        const obj = { bool: false };
        this.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
        if (selElem) {
            this.currentFilter = selElem.children[0].children[0].id.replace('Canvas', '');
        }
        if (isCropSelection) {
            this.crop();
        }
        else if (this.togglePen) {
            this.freeHandDraw(false);
            this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
        }
        else if (this.textArea.style.display === 'block') {
            this.notify('shape', { prop: 'redrawActObj', onPropertyChange: false,
                value: { x: null, y: null, isMouseDown: null } });
            if (isNullOrUndefined(isMouseDown)) {
                this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            }
        }
        else if ((!isBlazor() && document.querySelector('#' + this.element.id + '_sliderWrapper')) || (isBlazor() && !this.element.querySelector('.e-ie-contextual-slider').classList.contains('e-hidden')) ||
            this.currObjType.isFiltered) {
            this.initialAdjustmentValue = this.canvasFilter = this.lowerContext.filter;
            this.currObjType.isFiltered = false;
            const obj = { value: null };
            this.notify('draw', { prop: 'getTempAdjustmentValue', value: { obj: obj } });
            if (obj['value'] !== this.lowerContext.filter) {
                this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            }
        }
        else if (obj['bool']) {
            this.notify('freehand-draw', { prop: 'applyFhd', onPropertyChange: false });
            this.notify('selection', { prop: 'setFreehandDrawCustomized', value: { isFreehandDrawCustomized: false } });
            if (!isBlazor()) {
                this.notify('toolbar', { prop: 'destroy-qa-toolbar' });
            }
            else {
                this.updateToolbar(this.element, 'destroyQuickAccessToolbar');
            }
            this.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
        }
        else if ((this.activeObj.activePoint.width !== 0 && this.activeObj.activePoint.height !== 0) ||
            (this.activeObj.shape === 'path' && this.activeObj.pointColl.length > 0)) {
            this.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: isMouseDown } });
        }
        if (!isBlazor() && !obj['isCropToolbar']) {
            this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                    isApplyBtn: false, isCropping: null, isZooming: null, cType: null } });
        }
        this.notify('draw', { prop: 'setNewPath', value: { bool: false } });
        this.isCropTab = false;
        this.transform.zoomFactor = this.transform.defaultZoomFactor;
        this.notify('selection', { prop: 'setCurrentDrawingShape', onPropertyChange: false, value: { value: '' } });
    }
    /**
     * Set the temporary filter properties.
     *
     * @hidden
     * @returns {void}.
     */
    setTempFilterProperties() {
        this.upperCanvas.style.display = 'block';
        this.cropSelectedState();
        const obj = { adjustmentLevel: null };
        this.notify('filter', { prop: 'getAdjustmentLevel', onPropertyChange: false,
            value: { obj: obj } });
        this.lowerContext.filter = this.initialAdjustmentValue;
        this.notify('draw', { prop: 'setTempAdjustmentValue', value: { tempAdjustmentValue: this.lowerContext.filter } });
        this.notify('filter', { prop: 'setTempAdjustmentLevel', onPropertyChange: false,
            value: { tempAdjustmentLevel: extend({}, obj['adjustmentLevel'], {}, true) } });
        this.notify('draw', { prop: 'setTempFilter', value: { tempFilter: this.currentFilter } });
        const undoRedoObj = { undoRedoStep: null };
        this.notify('undo-redo', { prop: 'getUndoRedoStep', value: { obj: undoRedoObj } });
        this.notify('draw', { prop: 'setTempUndoRedoStep', value: { tempUndoRedoStep: undoRedoObj['undoRedoStep'] } });
    }
    /**
     * To crop the selection.
     *
     * @hidden
     * @returns {void}.
     */
    cropSelectedState() {
        if (this.activeObj.shape && this.activeObj.shape.split('-')[0] === 'crop') {
            this.okBtn();
        }
    }
    /**
     * Get the current canvas data.
     *
     * @hidden
     * @returns {ImageData}.
     * An ImageData returns the current canvas image data object.
     */
    getCurrentCanvasData() {
        const tempFilter = this.lowerContext.filter;
        this.lowerContext.filter = this.canvasFilter = 'none';
        const objColl = extend([], this.objColl, null, true);
        const pointColl = extend([], this.pointColl, null, true);
        this.objColl = [];
        this.pointColl = [];
        this.freehandCounter = 0;
        this.notify('draw', { prop: 'render-image', value: { isMouseWheel: false } });
        const data = this.getImageData();
        if (!isBlazor()) {
            if (!Browser.isDevice) {
                this.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'main',
                        isApplyBtn: true, isCropping: false } });
            }
            this.element.querySelector('#' + this.element.id + '_contextualToolbarArea').classList.remove('e-hide');
        }
        this.objColl = objColl;
        this.pointColl = pointColl;
        this.freehandCounter = pointColl.length;
        this.notify('shape', { prop: 'iterateObjColl', onPropertyChange: false });
        this.lowerContext.filter = this.canvasFilter = tempFilter;
        return data;
    }
    /**
     * To set current adjustment value
     *
     * @param { string } type - Specifies the type of adjustment.
     * @param { number } value - Specifies the value to adjust.
     * @hidden
     * @returns {void}.
     */
    setCurrAdjustmentValue(type, value) {
        const finetuneValueChanging = { finetune: this.getFinetuneOption(type),
            value: value, cancel: false };
        if (isBlazor() && this.events && this.events.finetuneValueChanging.hasDelegate === true) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            this.dotNetRef.invokeMethodAsync('OnFinetuneValueChangeAsync', finetuneValueChanging).then((finetuneValueChanging) => {
                if (finetuneValueChanging.cancel) {
                    return;
                }
                this.notify('filter', { prop: 'setCurrAdjValue', value: { type: type.toLowerCase(), value: value } });
            });
        }
        else {
            this.trigger('finetuneValueChanging', finetuneValueChanging);
            if (finetuneValueChanging.cancel) {
                return;
            }
            this.notify('filter', { prop: 'setCurrAdjValue', value: { type: type.toLowerCase(), value: value } });
        }
    }
    /**
     * Get the square point for path.
     *
     * @param { SelectionPoint } obj - Specifies the points of path.
     * @hidden
     * @returns {ActivePoint}.
     * An ActivePoint object which returns the square point.
     */
    getSquarePointForPath(obj) {
        let point = { startX: 0, startY: 0, endX: 0, endY: 0, width: 0, height: 0 };
        if (obj.pointColl.length > 0) {
            point = { startX: obj.pointColl[0].x, startY: obj.pointColl[0].y, endX: obj.pointColl[0].x, endY: obj.pointColl[0].y };
            for (let i = 1; i < obj.pointColl.length; i++) {
                if (obj.pointColl[i].x < point.startX) {
                    point.startX = obj.pointColl[i].x;
                }
                if (obj.pointColl[i].y < point.startY) {
                    point.startY = obj.pointColl[i].y;
                }
                if (obj.pointColl[i].x > point.endX) {
                    point.endX = obj.pointColl[i].x;
                }
                if (obj.pointColl[i].y > point.endY) {
                    point.endY = obj.pointColl[i].y;
                }
            }
            point.width = point.endX - point.startX;
            point.height = point.endY - point.startY;
        }
        return point;
    }
    /**
     * Get the SelectionType.
     *
     * @param { string } type - Specifies the SelectionType.
     * @hidden
     * @returns {string}.
     * An string which returns the SelectionType.
     */
    getSelectionType(type) {
        const typeToSelectionType = { 'CropCustom': 'Custom', 'CropSquare': 'Square', 'CropCircle': 'Circle',
            'Crop3:2': '3:2', 'Crop4:3': '4:3', 'Crop5:4': '5:4', 'Crop7:5': '7:5', 'Crop16:9': '16:9' };
        return typeToSelectionType[`${type}`];
    }
    /** Clears the context.
     *
     * @param { CanvasRenderingContext2D } ctx - Specifies the canvas context.
     * @hidden
     * @returns {void}.
     */
    clearContext(ctx) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.clearRect(0, 0, ctx.canvas.height, ctx.canvas.width);
    }
    /**
     * Apply Arrow for start and end.
     *
     * @param { string } type - Specifies the start arrow or end arrow.
     * @param { string } id - Specifies the start arrow or end arrow item id.
     * @hidden
     * @returns {void}.
     */
    updateArrow(type, id) {
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        const prevCropObj = extend({}, this.cropObj, {}, true);
        const object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        this.objColl.pop();
        if (type === 'startArrow') {
            this.activeObj.start = this.getTextFromId(id);
        }
        else if (type === 'endArrow') {
            this.activeObj.end = this.getTextFromId(id);
        }
        this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: null, fillColor: null,
                strokeWidth: this.activeObj.strokeSettings.strokeWidth } });
        this.objColl.push(this.activeObj);
        this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
            value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl, previousCropObj: prevCropObj, previousText: null,
                currentText: null, previousFilter: null, isCircleCrop: null } });
        this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
        if (!isBlazor()) {
            if (Browser.isDevice) {
                if (document.getElementById(this.element.id + '_bottomToolbar')) {
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    const toolbar = getComponent(this.element.id + '_bottomToolbar', 'toolbar');
                    toolbar.refreshOverflow();
                }
            }
            else {
                if (document.getElementById(this.element.id + '_toolbar')) {
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    const toolbar = getComponent(this.element.id + '_toolbar', 'toolbar');
                    toolbar.refreshOverflow();
                }
            }
        }
    }
    /**
     * Apply Font style for text.
     *
     * @param { string } id - Specifies the selected item id.
     * @hidden
     * @returns {void}.
     */
    updateFontFamily(id) {
        this.notify('selection', { prop: 'setInitialTextEdit', value: { bool: false } });
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        const objColl = extend([], this.objColl, [], true);
        const prevCropObj = extend({}, this.cropObj, {}, true);
        const object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.objColl.pop();
        if (this.textArea.style.display === 'block') {
            this.notify('shape', { prop: 'updateFontRatio', onPropertyChange: false,
                value: { obj: this.activeObj, isTextArea: true } });
            const temp = this.activeObj.textSettings.fontFamily;
            this.activeObj.textSettings.fontFamily = this.toPascalCase(id);
            this.notify('shape', { prop: 'redraw-text' });
            this.objColl.push(this.activeObj);
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'textAreaCustomization', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
            this.objColl.pop();
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            const width = this.activeObj.activePoint.width +
                this.activeObj.textSettings.fontSize * 0.25;
            this.textArea.style.width = width + 'px';
            this.textArea.style.fontFamily = this.toPascalCase(id);
            this.activeObj.textSettings.fontFamily = temp;
            this.notify('shape', { prop: 'updateFontStyles', onPropertyChange: false,
                value: { isTextBox: null } });
        }
        else {
            this.notify('shape', { prop: 'updateFontRatio', onPropertyChange: false,
                value: { obj: this.activeObj, isTextArea: null } });
            const fontFamily = this.activeObj.textSettings.fontFamily = this.toPascalCase(id);
            this.notify('shape', { prop: 'setTextSettings', onPropertyChange: false,
                value: { textSettings: null, fontFamily: fontFamily, fontSize: null } });
            this.notify('shape', { prop: 'redraw-text' });
            this.objColl.push(this.activeObj);
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: objColl,
                    previousPointColl: extend([], this.pointColl, [], true),
                    previousSelPointColl: prevObj.selPointColl, previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
            this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
        }
    }
    /**
     * Apply Font size for text.
     *
     * @param { string } text - Specifies the selected item text.
     * @hidden
     * @returns {void}.
     */
    updateFontSize(text) {
        const itemText = text;
        this.notify('selection', { prop: 'setInitialTextEdit', value: { bool: false } });
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        const prevCropObj = extend({}, this.cropObj, {}, true);
        const object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.objColl.pop();
        if (this.textArea.style.display === 'block') {
            this.notify('shape', { prop: 'updateFontRatio', onPropertyChange: false,
                value: { obj: this.activeObj, isTextArea: true } });
            const temp = this.activeObj.textSettings.fontSize;
            this.activeObj.textSettings.fontSize = parseInt(this.fontSizeColl[(parseInt(itemText, 10) - 1)].text, 10);
            this.objColl.push(this.activeObj);
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'textAreaCustomization', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
            this.objColl.pop();
            let textStyle = '';
            if (this.textArea.style.fontWeight === 'bold') {
                textStyle = 'bold ';
            }
            if (this.textArea.style.fontStyle === 'italic') {
                textStyle = 'italic ';
            }
            if (this.textArea.style.fontWeight === 'bold' && this.textArea.style.fontStyle === 'italic') {
                textStyle = 'italic bold ';
            }
            this.upperContext.font = textStyle + this.activeObj.textSettings.fontSize + 'px' + ' ' + this.textArea.style.fontFamily;
            const rows = this.textArea.value.split('\n');
            const obj = { maxText: '' };
            this.notify('shape', { prop: 'getMaxText', onPropertyChange: false,
                value: { isTextBox: true, text: null, obj: obj } });
            const text = obj['maxText'];
            const width = this.upperContext.measureText(text).width +
                this.activeObj.textSettings.fontSize * 0.5;
            this.textArea.style.width = width + 'px';
            this.textArea.style.height = rows.length * (this.activeObj.textSettings.fontSize + this.activeObj.textSettings.fontSize * 0.25) + 'px';
            this.activeObj.textSettings.fontSize = temp;
            this.upperContext.font = this.activeObj.textSettings.fontSize + 'px' + ' ' + this.activeObj.textSettings.fontFamily;
            this.textArea.style.fontSize = parseInt(this.fontSizeColl[(parseInt(itemText, 10) - 1)].text, 10) + 'px';
            if (this.textArea.style.fontFamily === 'georgia') {
                this.textArea.style.width = parseFloat(this.textArea.style.width) + parseFloat(this.textArea.style.fontSize) + 'px';
            }
        }
        else {
            this.notify('shape', { prop: 'updateFontRatio', onPropertyChange: false,
                value: { obj: this.activeObj, isTextArea: null } });
            const fontSize = this.activeObj.textSettings.fontSize = parseInt(this.fontSizeColl[(parseInt(itemText, 10) - 1)].text, 10);
            this.notify('shape', { prop: 'setTextSettings', onPropertyChange: false,
                value: { textSettings: null, fontFamily: null, fontSize: fontSize } });
            this.upperContext.font = this.activeObj.textSettings.fontSize + 'px' + ' ' + this.activeObj.textSettings.fontFamily;
            const rows = this.activeObj.keyHistory.split('\n');
            const obj = { maxText: '' };
            this.notify('shape', { prop: 'getMaxText', onPropertyChange: false,
                value: { isTextBox: null, text: null, obj: obj } });
            const text = obj['maxText'];
            const width = this.upperContext.measureText(text).width +
                this.activeObj.textSettings.fontSize * 0.5;
            const height = rows.length * (this.activeObj.textSettings.fontSize +
                this.activeObj.textSettings.fontSize * 0.25);
            this.notify('selection', { prop: 'setTextSelection', onPropertyChange: false,
                value: { width: width, height: height } });
            this.notify('draw', { prop: 'updateActiveObject', onPropertyChange: false, value: { actPoint: this.activeObj.activePoint, obj: this.activeObj,
                    isMouseMove: null, x: null, y: null } });
            this.notify('shape', { prop: 'redraw-text' });
            this.objColl.push(this.activeObj);
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
            this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
        }
    }
    /**
     * Apply Font color for text.
     *
     * @param { string } value - Specifies the selected color item value.
     * @hidden
     * @returns {void}.
     */
    updateFontColor(value) {
        this.notify('selection', { prop: 'setInitialTextEdit', value: { bool: false } });
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        const prevCropObj = extend({}, this.cropObj, {}, true);
        const object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.objColl.pop();
        if (this.textArea.style.display === 'none') {
            this.activeObj.strokeSettings.strokeColor = value;
            this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null,
                    strokeColor: this.activeObj.strokeSettings.strokeColor, fillColor: null, strokeWidth: null } });
            if (!this.togglePen) {
                this.objColl.push(this.activeObj);
                this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                    value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                        previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                        previousCropObj: prevCropObj, previousText: null,
                        currentText: null, previousFilter: null, isCircleCrop: null } });
                this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
            }
        }
        else if (this.textArea.style.display === 'block') {
            this.textArea.style.color = value;
            const temp = this.activeObj.strokeSettings.strokeColor;
            this.activeObj.strokeSettings.strokeColor = value;
            this.objColl.push(this.activeObj);
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'textAreaCustomization', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
            this.objColl.pop();
            this.activeObj.strokeSettings.strokeColor = temp;
        }
        else if (!this.togglePen) {
            this.objColl.push(this.activeObj);
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
            this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
        }
    }
    /**
     * Apply Pen stroke width.
     *
     * @param { string } id - Specifies the selected item id.
     * @hidden
     * @returns {void}.
     */
    updatePenStrokeWidth(id) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const temp = extend([], this.pointColl, [], true);
        this.updateFreehandDrawColorChange();
        const prevCropObj = extend({}, this.cropObj, {}, true);
        const object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.pointColl = temp;
        this.notify('selection', { prop: 'setFreehandDrawCustomized', value: { isFreehandDrawCustomized: true } });
        this.setPenStroke(id);
        const obj = { bool: false };
        this.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
        if (obj['bool']) {
            const obj = { penStrokeWidth: null };
            this.notify('freehand-draw', { prop: 'getPenStrokeWidth', onPropertyChange: false, value: { obj: obj } });
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            this.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                value: { strokeColor: null, strokeWidth: obj['penStrokeWidth'] } });
            const indexObj = { freehandSelectedIndex: null };
            this.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
            this.pointColl[indexObj['freehandSelectedIndex']].strokeWidth = obj['penStrokeWidth'];
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'freehanddrawCustomized', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
        }
    }
    /**
     * Apply Pen stroke color.
     *
     * @param { string } value - Specifies the selected color item value.
     * @hidden
     * @returns {void}.
     */
    updatePenStrokeColor(value) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        const temp = extend([], this.pointColl, [], true);
        this.updateFreehandDrawColorChange();
        const prevCropObj = extend({}, this.cropObj, {}, true);
        const object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.pointColl = temp;
        this.notify('selection', { prop: 'setFreehandDrawCustomized', value: { isFreehandDrawCustomized: true } });
        this.activeObj.strokeSettings.strokeColor = value;
        const obj = { bool: false };
        this.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
        if (obj['bool']) {
            const indexObj = { freehandSelectedIndex: null };
            this.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
            this.upperContext.clearRect(0, 0, this.upperCanvas.width, this.upperCanvas.height);
            this.pointColl[indexObj['freehandSelectedIndex']].strokeColor = value;
            this.notify('freehand-draw', { prop: 'hoverFhd', onPropertyChange: false,
                value: { strokeColor: value } });
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'freehanddrawCustomized', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
        }
        else if (!this.togglePen) {
            this.notify('selection', { prop: 'redrawShape', value: { obj: this.activeObj } });
        }
    }
    /**
     * Apply Shape stroke width.
     *
     * @param { string } id - Specifies the selected item id.
     * @hidden
     * @returns {void}.
     */
    updateStrokeWidth(id) {
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        const prevCropObj = extend({}, this.cropObj, {}, true);
        const object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.objColl.pop();
        this.activeObj.strokeSettings.strokeWidth = parseInt(id, 10);
        this.activeObj.strokeSettings.strokeWidth *= 2;
        this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: null, fillColor: null,
                strokeWidth: this.activeObj.strokeSettings.strokeWidth } });
        this.objColl.push(this.activeObj);
        this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
            value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj, previousText: null,
                currentText: null, previousFilter: null, isCircleCrop: null } });
        this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
    }
    /**
     * Apply Shape stroke color.
     *
     * @param { string } value - Specifies the selected color item value.
     * @hidden
     * @returns {void}.
     */
    updateStrokeColor(value) {
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        const prevCropObj = extend({}, this.cropObj, {}, true);
        const object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.objColl.pop();
        this.activeObj.strokeSettings.strokeColor = value;
        this.notify('shape', { prop: 'setStrokeSettings', value: { strokeSettings: null, strokeColor: this.activeObj.strokeSettings.strokeColor, fillColor: null, strokeWidth: null } });
        if (!this.togglePen) {
            this.objColl.push(this.activeObj);
            this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
                value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                    previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                    previousCropObj: prevCropObj, previousText: null,
                    currentText: null, previousFilter: null, isCircleCrop: null } });
            this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
        }
    }
    /**
     * Apply Shape fill color.
     *
     * @param { string } value - Specifies the selected color item value.
     * @hidden
     * @returns {void}.
     */
    updateFillColor(value) {
        this.notify('shape', { prop: 'pushActItemIntoObj' });
        const prevCropObj = extend({}, this.cropObj, {}, true);
        const object = { currObj: {} };
        this.notify('filter', { prop: 'getCurrentObj', onPropertyChange: false, value: { object: object } });
        const prevObj = object['currObj'];
        prevObj.objColl = extend([], this.objColl, [], true);
        prevObj.pointColl = extend([], this.pointColl, [], true);
        prevObj.afterCropActions = extend([], this.afterCropActions, [], true);
        const selPointCollObj = { selPointColl: null };
        this.notify('freehand-draw', { prop: 'getSelPointColl', onPropertyChange: false,
            value: { obj: selPointCollObj } });
        prevObj.selPointColl = extend([], selPointCollObj['selPointColl'], [], true);
        this.objColl.pop();
        this.activeObj.strokeSettings.fillColor = value;
        this.notify('shape', { prop: 'setStrokeSettings',
            value: { strokeSettings: null, strokeColor: null, fillColor: this.activeObj.strokeSettings.fillColor,
                strokeWidth: null } });
        this.objColl.push(this.activeObj);
        this.notify('undo-redo', { prop: 'updateUndoRedoColl', onPropertyChange: false,
            value: { operation: 'shapeTransform', previousObj: prevObj, previousObjColl: prevObj.objColl,
                previousPointColl: prevObj.pointColl, previousSelPointColl: prevObj.selPointColl,
                previousCropObj: prevCropObj, previousText: null,
                currentText: null, previousFilter: null, isCircleCrop: null } });
        this.notify('selection', { prop: 'redrawShape', value: { obj: this.objColl[this.objColl.length - 1] } });
    }
    /**
     * Get pascalToSplitWords from string.
     *
     * @param { string } str - Specifies the word.
     * @hidden
     * @returns {string}.
     */
    pascalToSplitWords(str) {
        str = str.charAt(0).toUpperCase() + str.slice(1);
        const splitStr = str.match(/[A-Z][a-z]+/g);
        if (isNullOrUndefined(splitStr)) {
            return str;
        }
        else {
            return splitStr.map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        }
    }
    /**
     * Get Slider Value.
     *
     * @param { string } type - Finetune type.
     * @hidden
     * @returns {number}.
     */
    getCurrAdjustmentValue(type) {
        const obj = { adjustmentLevel: null };
        this.notify('filter', { prop: 'getAdjustmentLevel', onPropertyChange: false,
            value: { obj: obj } });
        const typeToAdjustmentLevel = { 'brightness': obj['adjustmentLevel'].brightness,
            'contrast': obj['adjustmentLevel'].contrast, 'hue': obj['adjustmentLevel'].hue,
            'saturation': obj['adjustmentLevel'].saturation, 'opacity': obj['adjustmentLevel'].opacity,
            'blur': obj['adjustmentLevel'].blur, 'exposure': obj['adjustmentLevel'].exposure };
        return typeToAdjustmentLevel[`${type}`];
    }
    /**
     * Apply transformSelect.
     *
     * @param { string } type - Specifies the selected item text.
     * @hidden
     * @returns {void}.
     */
    transformSelect(type) {
        this.isCropToolbar = true;
        this.setInitialZoomState();
        const activeObj = extend({}, this.activeObj, {}, true);
        this.cropSelectedState();
        this.notify('draw', { prop: 'resetCurrentSelectionPoint' });
        this.notify('transform', { prop: 'performTransformation', value: { text: type } });
        this.notify('draw', { prop: 'moveToSelectionRange', value: { type: type, activeObj: activeObj } });
        this.isCropToolbar = false;
    }
    /**
     * Returns default filter.
     *
     * @hidden
     * @returns {string}.
     */
    getDefaultFilter() {
        return 'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
            'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' +
            'grayscale(0%) ' + 'invert(0%)';
    }
    // Blazor codes
    /**
     * To Initialize the component rendering
     *
     * @private
     * @param {HTMLCanvasElement} element - Specifies the canvas element.
     * @param {BlazorDotnetObject} dotnetRef - Specifies for blazor client to server communication.
     * @returns {void}
     */
    initializeImageEditor(element, dotnetRef) {
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        this.element = element;
        const canvasWrapper = this.element.querySelector('.e-canvas-wrapper');
        if (this.element.querySelector('#' + this.element.id + '_toolbarArea')) {
            this.toolbarHeight = this.element.querySelector('#' + this.element.id + '_toolbarArea').clientHeight;
        }
        else {
            this.toolbarHeight = 0;
        }
        canvasWrapper.style.height = (this.element.offsetHeight - this.toolbarHeight - 2) + 'px';
        canvasWrapper.style.width = (this.element.offsetWidth - 2) + 'px';
        this.lowerCanvas = this.element.querySelector('.e-lower-canvas');
        this.upperCanvas = this.element.querySelector('.e-upper-canvas');
        this.lowerCanvas.id = this.element.id + '_lowerCanvas';
        this.upperCanvas.id = this.element.id + '_upperCanvas';
        this.textArea = this.element.querySelector('.e-textbox');
        this.inMemoryCanvas = this.createElement('canvas', {
            id: this.element.id + '_inMemoryCanvas', attrs: { name: 'canvasImage' }
        });
        this.upperCanvas.width = this.lowerCanvas.width = this.inMemoryCanvas.width = this.element.offsetWidth;
        this.upperCanvas.height = this.lowerCanvas.height = this.inMemoryCanvas.height = (this.element.offsetHeight - this.toolbarHeight);
        this.lowerContext = this.lowerCanvas.getContext('2d');
        this.baseImg = this.createElement('img', {
            id: this.element.id + '_orgImg', attrs: { name: 'Image', crossorigin: 'anonymous' }
        });
        this.upperContext = this.upperCanvas.getContext('2d');
        this.inMemoryContext = this.inMemoryCanvas.getContext('2d');
        if (dotnetRef) {
            this.dotNetRef = dotnetRef;
        }
        this.prerender();
        this.wireEvent();
        this.lowerContext.filter = this.getDefaultFilter();
        this.notify('filter', { prop: 'setAdjustmentValue', onPropertyChange: false, value: { adjustmentValue: this.lowerContext.filter } });
        this.canvasFilter = this.initialAdjustmentValue = this.lowerContext.filter;
        if (this.cssClass) {
            addClass([this.element], this.cssClass.replace(/\s+/g, ' ').trim().split(' '));
        }
        if (this.element) {
            createSpinner({
                target: this.element
            });
        }
        this.initializeZoomSettings();
    }
    prerender() {
        // pre render code snippets
        this.element.id = this.element.id || getUniqueID('ej2-image-editor');
        if (Browser.isDevice) {
            this.element.classList.add('e-device');
        }
        this.initializeThemeColl();
    }
    initializeZoomSettings() {
        if (isNullOrUndefined(this.zoomSettings.zoomTrigger)) {
            this.zoomSettings.zoomTrigger = (ZoomTrigger.MouseWheel | ZoomTrigger.Pinch | ZoomTrigger.Toolbar | ZoomTrigger.Commands);
        }
        if (isNullOrUndefined(this.selectionSettings.strokeColor)) {
            this.selectionSettings.strokeColor = this.themeColl[this.theme]['primaryColor'];
        }
        if (isNullOrUndefined(this.selectionSettings.fillColor)) {
            this.selectionSettings.fillColor = this.themeColl[this.theme]['secondaryColor'];
        }
    }
    initializeThemeColl() {
        this.themeColl = {
            Bootstrap5: { primaryColor: '#0d6efd', secondaryColor: '#fff' },
            Bootstrap5Dark: { primaryColor: '#0d6efd', secondaryColor: '#fff' },
            Tailwind: { primaryColor: '#4f46e5', secondaryColor: '#fff' },
            TailwindDark: { primaryColor: '#22d3ee', secondaryColor: '#fff' },
            Fluent: { primaryColor: '#0078d4', secondaryColor: '#fff' },
            FluentDark: { primaryColor: '#0078d4', secondaryColor: '#fff' },
            Bootstrap4: { primaryColor: '#007bff', secondaryColor: '#fff' },
            Bootstrap: { primaryColor: '#317ab9', secondaryColor: '#fff' },
            BootstrapDark: { primaryColor: '#317ab9', secondaryColor: '#fff' },
            Material: { primaryColor: '#e3165b', secondaryColor: '#fff' },
            MaterialDark: { primaryColor: '#00b0ff', secondaryColor: '#fff' },
            Fabric: { primaryColor: '#0078d6', secondaryColor: '#fff' },
            FabricDark: { primaryColor: '#0074cc', secondaryColor: '#fff' },
            Highcontrast: { primaryColor: '#000000', secondaryColor: '#fff' },
            Material3: { primaryColor: '#6750a4', secondaryColor: '#fff' },
            Material3Dark: { primaryColor: '#d0bcff', secondaryColor: '#fff' }
        };
    }
    /**
     * Get the square point for path.
     *
     * @param { HTMLDivElement } element - Specifies element.
     * @param { string } type - Specifies the type.
     * @param { string } value - Specifies the value.
     * @hidden
     * @private
     * @returns {void}.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function
    updateToolbar(element, type, value) {
    }
};
__decorate([
    Property('')
], ImageEditor.prototype, "cssClass", void 0);
__decorate([
    Property(false)
], ImageEditor.prototype, "disabled", void 0);
__decorate([
    Property('100%')
], ImageEditor.prototype, "height", void 0);
__decorate([
    Property('Bootstrap5')
], ImageEditor.prototype, "theme", void 0);
__decorate([
    Property()
], ImageEditor.prototype, "toolbar", void 0);
__decorate([
    Property()
], ImageEditor.prototype, "toolbarTemplate", void 0);
__decorate([
    Property('100%')
], ImageEditor.prototype, "width", void 0);
__decorate([
    Property(true)
], ImageEditor.prototype, "allowUndoRedo", void 0);
__decorate([
    Property(true)
], ImageEditor.prototype, "showQuickAccessToolbar", void 0);
__decorate([
    Property()
], ImageEditor.prototype, "quickAccessToolbarTemplate", void 0);
__decorate([
    Property(false)
], ImageEditor.prototype, "isReadOnly", void 0);
__decorate([
    Property(false)
], ImageEditor.prototype, "enableRtl", void 0);
__decorate([
    Property(false)
], ImageEditor.prototype, "enablePersistence", void 0);
__decorate([
    Complex({}, FinetuneSettings)
], ImageEditor.prototype, "finetuneSettings", void 0);
__decorate([
    Complex({}, ZoomSettings)
], ImageEditor.prototype, "zoomSettings", void 0);
__decorate([
    Complex({}, SelectionSettings)
], ImageEditor.prototype, "selectionSettings", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "beforeSave", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "created", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "destroyed", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "zooming", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "panning", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "cropping", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "rotating", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "flipping", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "shapeChanging", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "selectionChanging", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "fileOpened", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "saved", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "toolbarCreated", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "toolbarUpdating", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "toolbarItemClicked", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "imageFiltering", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "finetuneValueChanging", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "click", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "quickAccessToolbarOpen", void 0);
__decorate([
    Event()
], ImageEditor.prototype, "quickAccessToolbarItemClick", void 0);
ImageEditor = ImageEditor_1 = __decorate([
    NotifyPropertyChanges
], ImageEditor);

/**
 * An enum representing the file types supported by the image editor.
 *
 * @enum {string}
 */
var FileType;
(function (FileType) {
    /** The PNG file type. */
    FileType["Png"] = "Png";
    /** The JPEG file type. */
    FileType["Jpeg"] = "Jpeg";
    /** The SVG file type. */
    FileType["Svg"] = "Svg";
})(FileType || (FileType = {}));
/**
 * An enumeration representing the direction of an image editor operation.
 *
 * @enum {string}
 */
var Direction;
(function (Direction) {
    /** The horizontal direction. */
    Direction["Horizontal"] = "Horizontal";
    /** The vertical direction. */
    Direction["Vertical"] = "Vertical";
})(Direction || (Direction = {}));
/**
 * An enumeration representing the type of shape to be added in the image editor.
 *
 * @enum {string}
 */
var ShapeType;
(function (ShapeType) {
    /** A rectangle shape. */
    ShapeType["Rectangle"] = "Rectangle";
    /** An ellipse shape. */
    ShapeType["Ellipse"] = "Ellipse";
    /** A line shape. */
    ShapeType["Line"] = "Line";
    /** An arrow shape. */
    ShapeType["Arrow"] = "Arrow";
    /** A path shape. */
    ShapeType["Path"] = "Path";
    /** A text shape. */
    ShapeType["Text"] = "Text";
    /** A freehand drawing shape. */
    ShapeType["FreehandDraw"] = "FreehandDraw";
})(ShapeType || (ShapeType = {}));
/**
 * An enumeration representing the different ways to trigger zooming in the image editor.
 *
 * @aspNumberEnum
 */
var ZoomTrigger;
(function (ZoomTrigger) {
    /** Zooming triggered by mouse wheel. */
    ZoomTrigger[ZoomTrigger["MouseWheel"] = 1] = "MouseWheel";
    /** Zooming triggered by pinch gesture. */
    ZoomTrigger[ZoomTrigger["Pinch"] = 2] = "Pinch";
    /** Zooming triggered by command keys. */
    ZoomTrigger[ZoomTrigger["Commands"] = 4] = "Commands";
    /** Zooming triggered by toolbar button click. */
    ZoomTrigger[ZoomTrigger["Toolbar"] = 8] = "Toolbar";
})(ZoomTrigger || (ZoomTrigger = {}));
/**
 * * An enum representing the available themes in the image editor.
 */
var Theme;
(function (Theme) {
    /** The Bootstrap 5 theme. */
    Theme["Bootstrap5"] = "Bootstrap5";
    /** The dark variant of the Bootstrap 5 theme. */
    Theme["Bootstrap5Dark"] = "Bootstrap5Dark";
    /** The Tailwind CSS theme. */
    Theme["Tailwind"] = "Tailwind";
    /** The dark variant of the Tailwind CSS theme. */
    Theme["TailwindDark"] = "TailwindDark";
    /** The Fluent UI theme. */
    Theme["Fluent"] = "Fluent";
    /** The dark variant of the Fluent UI theme. */
    Theme["FluentDark"] = "FluentDark";
    /** The Bootstrap 4 theme. */
    Theme["Bootstrap4"] = "Bootstrap4";
    /** The Bootstrap theme. */
    Theme["Bootstrap"] = "Bootstrap";
    /** The dark variant of the Bootstrap theme. */
    Theme["BootstrapDark"] = "BootstrapDark";
    /** The Material Design theme. */
    Theme["Material"] = "Material";
    /** The dark variant of the Material Design theme. */
    Theme["MaterialDark"] = "MaterialDark";
    /** The Fabric theme. */
    Theme["Fabric"] = "Fabric";
    /** The dark variant of the Fabric theme. */
    Theme["FabricDark"] = "FabricDark";
    /** The high contrast theme. */
    Theme["Highcontrast"] = "Highcontrast";
})(Theme || (Theme = {}));
/**
 * An enum representing the available toolbar commands in the image editor.
 */
var ImageEditorCommand;
(function (ImageEditorCommand) {
    ImageEditorCommand["Crop"] = "Crop";
    ImageEditorCommand["Transform"] = "Transform";
    ImageEditorCommand["Annotate"] = "Annotate";
    ImageEditorCommand["ZoomIn"] = "ZoomIn";
    ImageEditorCommand["ZoomOut"] = "ZoomOut";
    ImageEditorCommand["Open"] = "Open";
    ImageEditorCommand["Reset"] = "Reset";
    ImageEditorCommand["Save"] = "Save";
    ImageEditorCommand["Pan"] = "Pan";
    ImageEditorCommand["Move"] = "Move";
    ImageEditorCommand["Pen"] = "Pen";
    ImageEditorCommand["Line"] = "Line";
    ImageEditorCommand["Arrow"] = "Arrow";
    ImageEditorCommand["Path"] = "Path";
    ImageEditorCommand["Rectangle"] = "Rectangle";
    ImageEditorCommand["Ellipse"] = "Ellipse";
    ImageEditorCommand["Text"] = "Text";
    ImageEditorCommand["CustomSelection"] = "CustomSelection";
    ImageEditorCommand["CircleSelection"] = "CircleSelection";
    ImageEditorCommand["SquareSelection"] = "SquareSelection";
    ImageEditorCommand["RatioSelection"] = "RatioSelection";
    ImageEditorCommand["RotateLeft"] = "RotateLeft";
    ImageEditorCommand["RotateRight"] = "RotateRight";
    ImageEditorCommand["FlipHorizontal"] = "FlipHorizontal";
    ImageEditorCommand["FlipVertical"] = "FlipVertical";
})(ImageEditorCommand || (ImageEditorCommand = {}));
/**
 * An enumeration of available image filter options.
 *
 * @remarks
 * These options can be used with the `applyImageFilter` method of the image editor control to apply filters to an image.
 */
var ImageFilterOption;
(function (ImageFilterOption) {
    /** Default filter */
    ImageFilterOption["Default"] = "Default";
    /** Chrome filter */
    ImageFilterOption["Chrome"] = "Chrome";
    /** Cold filter */
    ImageFilterOption["Cold"] = "Cold";
    /** Warm filter */
    ImageFilterOption["Warm"] = "Warm";
    /** Grayscale filter */
    ImageFilterOption["Grayscale"] = "Grayscale";
    /** Sepia filter */
    ImageFilterOption["Sepia"] = "Sepia";
    /** Invert filter */
    ImageFilterOption["Invert"] = "Invert";
})(ImageFilterOption || (ImageFilterOption = {}));
/**
 * An enumeration of available image finetune options.
 *
 * @remarks
 * These options can be used with the `finetuneImage` method of the image editor control to apply finetuning to an image.
 */
var ImageFinetuneOption;
(function (ImageFinetuneOption) {
    /** Adjust the brightness of the image */
    ImageFinetuneOption["Brightness"] = "Brightness";
    /** Adjust the contrast of the image */
    ImageFinetuneOption["Contrast"] = "Contrast";
    /** Adjust the hue of the image */
    ImageFinetuneOption["Hue"] = "Hue";
    /** Adjust the saturation of the image */
    ImageFinetuneOption["Saturation"] = "Saturation";
    /** Adjust the exposure of the image */
    ImageFinetuneOption["Exposure"] = "Exposure";
    /** Adjust the opacity of the image */
    ImageFinetuneOption["Opacity"] = "Opacity";
    /** Adjust the blur of the image */
    ImageFinetuneOption["Blur"] = "Blur";
})(ImageFinetuneOption || (ImageFinetuneOption = {}));
/**
 * Specifies the type of arrowhead should be drawn.
 *
 */
var ArrowheadType;
(function (ArrowheadType) {
    /** Indicates no arrowhead should be drawn. */
    ArrowheadType["None"] = "None";
    /** Indicates a normal triangle-shaped arrowhead should be drawn. */
    ArrowheadType["Arrow"] = "Arrow";
    /** Indicates a solid triangle-shaped arrowhead should be drawn. */
    ArrowheadType["SolidArrow"] = "SolidArrow";
    /** Indicates a circular-shaped arrowhead should be drawn. */
    ArrowheadType["Circle"] = "Circle";
    /** Indicates a solid circular-shaped arrowhead should be drawn. */
    ArrowheadType["SolidCircle"] = "SolidCircle";
    /** Indicates a square-shaped arrowhead should be drawn. */
    ArrowheadType["Square"] = "Square";
    /** Indicates a solid square-shaped arrowhead should be drawn. */
    ArrowheadType["SolidSquare"] = "SolidSquare";
    /** Indicates a bar shaped arrowhead should be drawn. */
    ArrowheadType["Bar"] = "Bar";
})(ArrowheadType || (ArrowheadType = {}));

class ToolbarModule {
    constructor(parent) {
        this.defToolbarItems = [];
        this.toolbarHeight = 46;
        this.currToolbar = '';
        this.preventZoomBtn = false;
        this.currentToolbar = 'main';
        this.selFhdColor = '#42a5f5';
        this.preventEnableDisableUr = false;
        this.parent = parent;
        this.addEventListener();
        this.initLocale();
    }
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
    }
    addEventListener() {
        this.parent.on('toolbar', this.toolbar, this);
        this.parent.on('destroyed', this.destroy, this);
    }
    removeEventListener() {
        this.parent.off('toolbar', this.toolbar);
        this.parent.off('destroyed', this.destroy);
    }
    initLocale() {
        this.defaultLocale = {
            Crop: 'Crop',
            ZoomIn: 'Zoom In',
            ZoomOut: 'Zoom Out',
            Undo: 'Undo',
            Redo: 'Redo',
            Transform: 'Transform',
            Annotation: 'Annotation',
            Finetune: 'Finetune',
            Brightness: 'Brightness',
            Contrast: 'Contrast',
            Hue: 'Hue',
            Saturation: 'Saturation',
            Opacity: 'Opacity',
            Blur: 'Blur',
            Sharpen: 'Sharpen',
            Exposure: 'Exposure',
            Filter: 'Filter',
            Default: 'Default',
            Chrome: 'Chrome',
            Cold: 'Cold',
            Warm: 'Warm',
            Grayscale: 'Grayscale',
            BlackAndWhite: 'Black and White',
            Sepia: 'Sepia',
            Invert: 'Invert',
            Text: 'Add Text',
            Pen: 'Pen',
            Reset: 'Reset',
            Save: 'Save',
            Select: 'Select',
            RotateLeft: 'Rotate Left',
            RotateRight: 'Rotate Right',
            HorizontalFlip: 'Horizontal Flip',
            VerticalFlip: 'Vertical Flip',
            OK: 'OK',
            Cancel: 'Cancel',
            FillColor: 'Fill Color',
            StrokeColor: 'Stroke Color',
            StrokeWidth: 'Stroke Width',
            FontFamily: 'Font Family',
            FontStyle: 'Font Style',
            FontSize: 'Font Size',
            FontColor: 'Font Color',
            Pan: 'Pan',
            Move: 'Move',
            Load: 'Load',
            Custom: 'Custom',
            Square: 'Square',
            Circle: 'Circle',
            Ellipse: 'Ellipse',
            Rectangle: 'Rectangle',
            Line: 'Line',
            Arrow: 'Arrow',
            Path: 'Path',
            Bold: 'Bold',
            Italic: 'Italic',
            BoldItalic: 'Bold Italic',
            XSmall: 'X-Small',
            Small: 'Small',
            Medium: 'Medium',
            Large: 'Large',
            XLarge: 'X-Large',
            ABC: 'ABC',
            Browse: 'Browse',
            Duplicate: 'Duplicate',
            Remove: 'Remove',
            EditText: 'Edit Text',
            Start: 'Start',
            End: 'End',
            Bar: 'Bar',
            ArrowSolid: 'Arrow Solid',
            CircleSolid: 'Circle Solid',
            SquareSolid: 'Square Solid',
            None: 'None',
            CropAndTransform: 'Crop and Transform',
            CropSelection: 'Crop Selection'
        };
        this.l10n = new L10n('image-editor', this.defaultLocale, this.parent.locale);
    }
    toolbar(args) {
        const parent = this.parent;
        this.updatePrivateVariables();
        switch (args.prop) {
            case 'create-toolbar':
                this.createToolbar();
                break;
            case 'create-contextual-toolbar':
                this.createContextualToolbar();
                break;
            case 'update-toolbar-items':
                this.updateToolbarItems();
                break;
            case 'refresh-toolbar':
                this.refreshToolbar(args.value['type'], args.value['isApplyBtn'], args.value['isCropping'], args.value['isZooming'], args.value['cType']);
                break;
            case 'renderQAT':
                this.renderQAT(args.value['isPenEdit']);
                break;
            case 'enable-disable-btns':
                this.enableDisableTbrBtn();
                break;
            case 'init-main-toolbar':
                this.initMainToolbar(args.value['isApplyBtn'], args.value['isDevice'], args.value['isOkBtn']);
                break;
            case 'create-bottom-toolbar':
                this.createBottomToolbar();
                break;
            case 'refresh-main-toolbar':
                this.refreshMainToolbar();
                break;
            case 'create-qa-toolbar':
                this.createQuickAccessToolbar();
                break;
            case 'destroy-qa-toolbar':
                this.destroyQuickAccessToolbar();
                break;
            case 'zoom-up-handler':
                this.zoomBtnMouseUpHandler();
                break;
            case 'refresh-dropdown-btn':
                this.refreshDropDownBtn(args.value['isDisabled']);
                break;
            case 'close-contextual-toolbar':
                this.closeContextualToolbar();
                break;
            case 'destroy-bottom-toolbar':
                this.destroyBottomToolbar();
                break;
            case 'destroy-top-toolbar':
                this.destroyTopToolbar();
                break;
            case 'destroySubComponents':
                this.destroySubComponents();
                break;
            case 'setLocale':
                this.l10n.setLocale(args.value['locale']);
                break;
            case 'setPreventZoomBtn':
                this.preventZoomBtn = args.value['isPrevent'];
                break;
            case 'getToolbarHeight':
                args.value['obj']['toolbarHeight'] = this.toolbarHeight;
                break;
            case 'setToolbarHeight':
                this.toolbarHeight = args.value['height'];
                break;
            case 'setCurrentToolbar':
                this.currentToolbar = args.value['type'];
                break;
            case 'setSelectedFreehandColor':
                this.selFhdColor = args.value['color'];
                break;
            case 'getCurrentFilter':
                args.value['obj']['currentFilter'] = parent.currentFilter;
                break;
            case 'setCurrentFilter':
                parent.currentFilter = args.value['filter'];
                break;
            case 'setInitialAdjustmentValue':
                parent.initialAdjustmentValue = args.value['value'];
                break;
            case 'getCanvasFilter':
                args.value['obj']['canvasFilter'] = parent.canvasFilter;
                break;
            case 'getDefToolbarItems':
                args.value['obj']['defToolbarItems'] = this.defToolbarItems;
                break;
            case 'getPenStroke':
                this.getPenStroke(args.value['value']);
                break;
            case 'performDefToolbarClickAction':
                this.performDefTbrClick(args.value['type'], args.value['isContextualToolbar'], args.value['isDisabledAdjustment'], args.value['isDisabledFilter'], args.value['isFilterFinetune']);
                break;
            case 'setTempFilterProperties':
                parent.setTempFilterProperties();
                break;
            case 'refreshSlider':
                this.refreshSlider();
                break;
            case 'renderSlider':
                this.renderSlider(args.value['type']);
                break;
            case 'getCurrAdjustmentValue':
                parent.getCurrAdjustmentValue(args.value['type']);
                break;
            case 'setCurrAdjustmentValue':
                parent.setCurrAdjustmentValue(args.value['type'], args.value['value']);
                break;
            case 'refreshShapeDrawing':
                this.refreshShapeDrawing();
                break;
            case 'getCropToolbar':
                args.value['obj']['isCropToolbar'] = parent.isCropToolbar;
                break;
            case 'getPrevCurrSelectionPoint':
                args.value['obj']['prevCurrSelectionPoint'] = parent.prevCurrSelectionPoint;
                break;
            case 'setPrevCurrSelectionPoint':
                parent.prevCurrSelectionPoint = args.value['point'];
                break;
            case 'updateCropTransformItems':
                parent.updateCropTransformItems();
                break;
            case 'setEnableDisableUndoRedo':
                this.preventEnableDisableUr = args.value['isPrevent'];
                break;
            case 'reset':
                this.reset();
                break;
        }
    }
    updatePrivateVariables() {
        const parent = this.parent;
        this.inMemoryCanvas = parent.inMemoryCanvas;
        if (parent.lowerCanvas) {
            this.lowerContext = parent.lowerCanvas.getContext('2d');
        }
        if (parent.upperCanvas) {
            this.upperContext = parent.upperCanvas.getContext('2d');
        }
        if (this.inMemoryCanvas) {
            this.inMemoryContext = this.inMemoryCanvas.getContext('2d');
        }
    }
    reset() {
        const parent = this.parent;
        this.defToolbarItems = [];
        this.toolbarHeight = 46;
        parent.prevCurrSelectionPoint = null;
        this.zoomBtnHold = null;
        this.currToolbar = '';
        this.currentToolbar = 'main';
        this.selFhdColor = '#42a5f5';
        parent.currentFilter = '';
        this.preventZoomBtn = parent.isCropToolbar = this.preventEnableDisableUr = false;
        parent.initialAdjustmentValue = parent.canvasFilter =
            'brightness(' + 1 + ') ' + 'contrast(' + 100 + '%) ' + 'hue-rotate(' + 0 + 'deg) ' +
                'saturate(' + 100 + '%) ' + 'opacity(' + 1 + ') ' + 'blur(' + 0 + 'px) ' + 'sepia(0%) ' + 'grayscale(0%) ' + 'invert(0%)';
    }
    destroyTopToolbar() {
        const parent = this.parent;
        const toolbar = document.getElementById(parent.element.id + '_toolbar');
        if (this.isToolbar() && toolbar && toolbar.classList.contains('e-control')) {
            getComponent(document.getElementById(parent.element.id + '_toolbar'), 'toolbar').destroy();
        }
    }
    destroyBottomToolbar() {
        const parent = this.parent;
        const toolbar = document.getElementById(parent.element.id + '_bottomToolbar');
        if (toolbar && toolbar.classList.contains('e-control')) {
            getComponent(document.getElementById(parent.element.id + '_bottomToolbar'), 'toolbar').destroy();
        }
    }
    isToolbar() {
        const parent = this.parent;
        return (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.length > 0)
            || !isNullOrUndefined(parent.toolbarTemplate));
    }
    createToolbar() {
        const parent = this.parent;
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.length > 0)) {
            parent.element.appendChild(parent.createElement('div', {
                id: parent.element.id + '_toolbarArea', className: 'e-toolbar-area'
            }));
            const toolbarItems = { cssClass: 'e-image-upload', align: 'Left', type: 'Input',
                tooltipText: this.l10n.getConstant('Browse'), template: new Uploader({ allowedExtensions: '.jpg, .jpeg, .png,.svg' }) };
            if (isNullOrUndefined(this.defToolbarItems)) {
                this.defToolbarItems = [];
            }
            this.defToolbarItems.push(toolbarItems);
            const toolbarArea = document.getElementById(parent.element.id + '_toolbarArea');
            const toolbar = parent.createElement('div', {
                id: parent.element.id + '_toolbar'
            });
            toolbarArea.appendChild(toolbar);
            const uploadItems = [
                {
                    cssClass: 'e-image-upload',
                    align: 'Left', type: 'Input',
                    tooltipText: this.l10n.getConstant('Browse'),
                    template: new Uploader({
                        allowedExtensions: '.jpg, .jpeg, .png,.svg',
                        selected: () => {
                            if (!parent.disabled) {
                                if (Browser.isDevice) {
                                    if (this.defToolbarItems.length > 0 &&
                                        document.getElementById(parent.element.id + '_toolbar')) {
                                        getComponent(document.getElementById(parent.element.id + '_toolbar'), 'toolbar').destroy();
                                    }
                                    if (document.getElementById(parent.element.id + '_bottomToolbar')) {
                                        getComponent(document.getElementById(parent.element.id + '_bottomToolbar'), 'toolbar').destroy();
                                    }
                                    this.initMainToolbar(false, Browser.isDevice, null);
                                    this.createBottomToolbar();
                                }
                                else {
                                    if (this.defToolbarItems.length > 0 &&
                                        document.getElementById(parent.element.id + '_toolbar')) {
                                        getComponent(document.getElementById(parent.element.id + '_toolbar'), 'toolbar').destroy();
                                    }
                                    this.initMainToolbar(false, false, null);
                                }
                            }
                        }
                    })
                }
            ];
            const toolbarObj = new Toolbar({ items: uploadItems, width: '100%',
                created: () => {
                    parent.trigger('toolbarCreated', { toolbarType: 'main' });
                },
                clicked: this.defToolbarClicked.bind(this) });
            toolbarObj.appendTo('#' + parent.element.id + '_toolbar');
            this.createLeftToolbarControls();
            if (document.getElementById(parent.element.id + '_toolbar')) {
                this.toolbarHeight = document.getElementById(parent.element.id + '_toolbar').clientHeight;
            }
        }
        else {
            this.toolbarHeight = 0;
        }
    }
    createContextualToolbar() {
        const parent = this.parent;
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.length > 0)) {
            parent.element.appendChild(parent.createElement('div', { id: parent.element.id + '_contextualToolbarArea',
                className: 'e-contextual-toolbar-wrapper e-hide', attrs: { style: 'position: absolute;' }
            }));
            const toolbarArea = document.getElementById(parent.element.id + '_contextualToolbarArea');
            const toolbar = parent.createElement('div', { id: parent.element.id + '_contextualToolbar' });
            toolbarArea.appendChild(toolbar);
        }
    }
    createBottomToolbar() {
        const parent = this.parent;
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.length > 0)) {
            parent.element.appendChild(parent.createElement('div', {
                id: parent.element.id + '_bottomToolbarArea', className: 'e-bottom-toolbar'
            }));
            if (!parent.toolbarTemplate) {
                document.getElementById(parent.element.id + '_canvasWrapper').style.height = (parent.element.offsetHeight
                    - this.toolbarHeight * 2) - 3 + 'px';
                const toolbarArea = document.getElementById(parent.element.id + '_bottomToolbarArea');
                const toolbarElem = parent.createElement('div', {
                    id: parent.element.id + '_bottomToolbar'
                });
                toolbarArea.appendChild(toolbarElem);
            }
            this.initBottomToolbar();
        }
    }
    createQuickAccessToolbar() {
        const parent = this.parent;
        if (parent.showQuickAccessToolbar) {
            const toolbarItems = { cssClass: 'e-image-upload', align: 'Left', type: 'Input',
                tooltipText: this.l10n.getConstant('Browse'), template: new Uploader({ allowedExtensions: '.jpg, .jpeg, .png,.svg' }) };
            if (isNullOrUndefined(this.defToolbarItems)) {
                this.defToolbarItems = [];
            }
            this.defToolbarItems.push(toolbarItems);
            const toolbarArea = document.getElementById(parent.element.id + '_quickAccessToolbarArea');
            const toolbar = parent.createElement('div', {
                id: parent.element.id + '_quickAccessToolbar'
            });
            toolbarArea.appendChild(toolbar);
            const toolbarObj = new Toolbar({ clicked: this.defToolbarClicked.bind(this) });
            toolbarObj.appendTo('#' + parent.element.id + '_quickAccessToolbar');
        }
    }
    initMainToolbar(isApplyOption, isDevice, isOkBtn) {
        const parent = this.parent;
        if (this.isToolbar()) {
            const leftItem = this.getLeftToolbarItem(isOkBtn);
            const rightItem = this.getRightToolbarItem(isOkBtn);
            const mainItem = this.getMainToolbarItem(isApplyOption);
            const zoomItem = this.getZoomToolbarItem();
            if (isDevice) {
                this.defToolbarItems = [...leftItem, ...rightItem];
            }
            else {
                this.defToolbarItems = [...leftItem, ...mainItem, ...rightItem, ...zoomItem];
            }
            const toolbarObj = new Toolbar({
                width: '100%',
                items: this.defToolbarItems,
                clicked: this.defToolbarClicked.bind(this),
                created: () => {
                    if (!isDevice) {
                        this.renderAnnotationBtn();
                    }
                    this.wireZoomBtnEvents();
                    this.renderSaveBtn();
                    parent.trigger('toolbarCreated', { toolbarType: 'main' });
                }
            });
            toolbarObj.appendTo('#' + parent.element.id + '_toolbar');
            this.createLeftToolbarControls();
            this.enableDisableTbrBtn();
            if (this.isToolbar() && document.getElementById(parent.element.id + '_toolbar')) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                const toolbar = getComponent(parent.element.id + '_toolbar', 'toolbar');
                toolbar.refreshOverflow();
            }
        }
    }
    initBottomToolbar() {
        const parent = this.parent;
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.length > 0)) {
            const items = this.getMainToolbarItem();
            const toolbarObj = new Toolbar({ items: items, width: '100%',
                created: () => {
                    this.renderAnnotationBtn();
                    this.renderCropBtn();
                    this.renderTransformBtn();
                    parent.trigger('toolbarCreated', { toolbarType: 'main' });
                },
                clicked: this.defToolbarClicked.bind(this)
            });
            toolbarObj.appendTo('#' + parent.element.id + '_bottomToolbar');
            if (this.defToolbarItems.length > 0 && document.getElementById(parent.element.id + '_bottomToolbar')) {
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                const toolbar = getComponent(parent.element.id + '_bottomToolbar', 'toolbar');
                toolbar.refreshOverflow();
            }
        }
    }
    getLeftToolbarItem(isOkBtn) {
        const parent = this.parent;
        const toolbarItems = [];
        if (!isOkBtn) {
            toolbarItems.push({ id: parent.element.id + '_upload', cssClass: 'e-image-upload', align: 'Left', type: 'Input', template: new Uploader({ allowedExtensions: '.jpg, .jpeg, .png,.svg' }) });
            toolbarItems.push({ visible: false, cssClass: 'e-image-position e-btn e-flat', tooltipText: this.l10n.getConstant('Browse'), align: 'Left' });
        }
        if (parent.allowUndoRedo) {
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Undo') > -1)) {
                toolbarItems.push({ id: parent.element.id + '_undo', prefixIcon: 'e-icons e-undo', cssClass: 'top-icon e-undo',
                    tooltipText: this.l10n.getConstant('Undo'), align: 'Left' });
            }
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Redo') > -1)) {
                toolbarItems.push({ id: parent.element.id + '_redo', prefixIcon: 'e-icons e-redo', cssClass: 'top-icon e-redo',
                    tooltipText: this.l10n.getConstant('Redo'), align: 'Left' });
            }
        }
        if (!this.preventZoomBtn && (parent.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar) {
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('ZoomOut') > -1)) {
                toolbarItems.push({ id: parent.element.id + '_zoomOut', prefixIcon: 'e-icons e-zoom-out', cssClass: 'top-icon e-dec-zoom',
                    tooltipText: this.l10n.getConstant('ZoomOut'), align: 'Left' });
            }
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('ZoomIn') > -1)) {
                toolbarItems.push({ id: parent.element.id + '_zoomIn', prefixIcon: 'e-icons e-zoom-in', cssClass: 'top-icon e-inc-zoom',
                    tooltipText: this.l10n.getConstant('ZoomIn'), align: 'Left' });
            }
        }
        const tempToolbarItems = this.processToolbar('left');
        for (let i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        return toolbarItems;
    }
    getRightToolbarItem(isOkBtn) {
        const parent = this.parent;
        const toolbarItems = [];
        if (isOkBtn) {
            toolbarItems.push({ id: parent.element.id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right' });
            toolbarItems.push({ id: parent.element.id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Reset') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_reset', prefixIcon: 'e-icons e-btn-reset', cssClass: 'top-icon e-img-reset',
                tooltipText: this.l10n.getConstant('Reset'), align: 'Right' });
        }
        if (!isOkBtn) {
            if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Save') > -1)) {
                toolbarItems.push({ id: parent.element.id + '_save', prefixIcon: 'e-icons e-btn-save', cssClass: 'top-icon e-save',
                    tooltipText: this.l10n.getConstant('Save'), align: 'Right', template: '<button id="' + parent.element.id + '_saveBtn"></button>' });
            }
        }
        const tempToolbarItems = this.processToolbar('right');
        for (let i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        return toolbarItems;
    }
    getMainToolbarItem(isApplyOption) {
        const parent = this.parent;
        const toolbarItems = [];
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Crop') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_cropTransform', prefixIcon: 'e-icons e-crop', cssClass: 'top-icon e-crop',
                tooltipText: this.l10n.getConstant('CropAndTransform'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Annotate') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_annotation', tooltipText: this.l10n.getConstant('Annotation'), align: 'Center',
                template: '<button id="' + parent.element.id + '_annotationBtn"></button>' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Finetune') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_adjustment', prefixIcon: 'e-icons e-adjustment', cssClass: 'top-icon e-adjustment',
                tooltipText: this.l10n.getConstant('Finetune'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Filter') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_filter', prefixIcon: 'e-icons e-filters', cssClass: 'top-icon e-filters',
                tooltipText: this.l10n.getConstant('Filter'), align: 'Center' });
        }
        const tempToolbarItems = this.processToolbar('center');
        for (let i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (isApplyOption) {
            toolbarItems.push({ id: parent.element.id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right' });
            toolbarItems.push({ id: parent.element.id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    }
    getZoomToolbarItem() {
        const toolbarItems = [];
        return toolbarItems;
    }
    updateContextualToolbar(type, cType) {
        const parent = this.parent;
        const toolbarArea = parent.element.querySelector('#' + parent.element.id + '_toolbarArea');
        const contextualToolbarArea = parent.element.querySelector('#' + parent.element.id + '_contextualToolbarArea');
        contextualToolbarArea.classList.remove('e-hide');
        contextualToolbarArea.style.left = toolbarArea.offsetLeft + 'px';
        if (type === 'filter') {
            if (document.getElementById(parent.element.id + '_toolbar') && this.defToolbarItems.length > 0) {
                getComponent(document.getElementById(parent.element.id + '_toolbar'), 'toolbar').destroy();
            }
            if (Browser.isDevice) {
                this.initMainToolbar(false, true, true);
            }
            else {
                this.initMainToolbar(true, null, null);
            }
            this.refreshSlider();
            this.initFilterToolbarItem();
        }
        else {
            if (document.querySelector('#' + parent.element.id + '_contextualToolbar').classList.contains('e-control')) {
                getComponent(document.getElementById(parent.element.id + '_contextualToolbar'), 'toolbar').destroy();
            }
            this.refreshSlider();
            this.renderSlider(cType);
        }
        if (Browser.isDevice) {
            const cHt = contextualToolbarArea.offsetHeight;
            const ht = parent.element.querySelector('#' + parent.element.id + '_canvasWrapper').offsetHeight;
            contextualToolbarArea.style.top = this.toolbarHeight + ht - cHt + 'px';
        }
        else {
            contextualToolbarArea.style.top = this.toolbarHeight + 'px';
        }
    }
    processToolbar(position) {
        const parent = this.parent;
        const toolbarItems = [];
        if (parent.toolbar) {
            for (let i = 0, len = parent.toolbar.length; i < len; i++) {
                if (typeof (parent.toolbar[i]) === 'object') {
                    if (isNullOrUndefined(parent.toolbar[i].align)) {
                        if (position === 'left') {
                            toolbarItems.push(parent.toolbar[i]);
                        }
                    }
                    else if (parent.toolbar[i].align.toLowerCase() === position) {
                        toolbarItems.push(parent.toolbar[i]);
                    }
                }
            }
        }
        return toolbarItems;
    }
    processSubToolbar(items) {
        const toolbarItems = [];
        if (items) {
            for (let i = 0, len = items.length; i < len; i++) {
                if (typeof (items[i]) === 'object') {
                    items[i].align = 'Center';
                    toolbarItems.push(items[i]);
                }
            }
        }
        return toolbarItems;
    }
    wireZoomBtnEvents() {
        const zoomIn = document.querySelector('#' + this.parent.element.id + '_zoomIn');
        const zoomOut = document.querySelector('#' + this.parent.element.id + '_zoomOut');
        if (zoomIn) {
            zoomIn.addEventListener('mousedown', this.zoomInBtnMouseDownHandler.bind(this));
            zoomIn.addEventListener('mouseup', this.zoomBtnMouseUpHandler.bind(this));
            zoomIn.addEventListener('click', this.zoomInBtnClickHandler.bind(this));
            zoomIn.addEventListener('touchstart', this.zoomInBtnClickHandler.bind(this));
        }
        if (zoomOut) {
            zoomOut.addEventListener('mousedown', this.zoomOutBtnMouseDownHandler.bind(this));
            zoomOut.addEventListener('mouseup', this.zoomBtnMouseUpHandler.bind(this));
            zoomOut.addEventListener('click', this.zoomOutBtnClickHandler.bind(this));
            zoomIn.addEventListener('touchstart', this.zoomInBtnClickHandler.bind(this));
        }
    }
    enableDisableTbrBtn() {
        const parent = this.parent;
        if (!this.preventEnableDisableUr) {
            const object = { appliedUndoRedoColl: [] };
            parent.notify('undo-redo', { prop: 'getAppliedUndoRedoColl', value: { obj: object } });
            const undoRedoObj = { undoRedoStep: null };
            parent.notify('undo-redo', { prop: 'getUndoRedoStep', value: { obj: undoRedoObj } });
            const undo = document.querySelector('#' + parent.element.id + '_undo');
            if (undo && undoRedoObj['undoRedoStep'] === 0) {
                undo.classList.add('e-disabled');
                undo.parentElement.classList.add('e-overlay');
            }
            else if (undo && undoRedoObj['undoRedoStep'] > 0) {
                undo.classList.remove('e-disabled');
                undo.parentElement.classList.remove('e-overlay');
            }
            const redo = document.querySelector('#' + parent.element.id + '_redo');
            if (redo && (undoRedoObj['undoRedoStep'] === object['appliedUndoRedoColl'].length)) {
                redo.classList.add('e-disabled');
                redo.parentElement.classList.add('e-overlay');
            }
            else if (redo && (undoRedoObj['undoRedoStep'] === 0 && object['appliedUndoRedoColl'].length > 0)) {
                redo.classList.remove('e-disabled');
                redo.parentElement.classList.remove('e-overlay');
            }
            else if (redo && undoRedoObj['undoRedoStep'] > 0) {
                redo.classList.remove('e-disabled');
                redo.parentElement.classList.remove('e-overlay');
            }
        }
        const zoomIn = document.querySelector('#' + parent.element.id + '_zoomIn');
        if (zoomIn && parent.zoomSettings.zoomFactor >= parent.zoomSettings.maxZoomFactor) {
            zoomIn.classList.add('e-disabled');
            zoomIn.parentElement.classList.add('e-overlay');
        }
        else if (zoomIn) {
            zoomIn.classList.remove('e-disabled');
            zoomIn.parentElement.classList.remove('e-overlay');
        }
        const zoomOut = document.querySelector('#' + parent.element.id + '_zoomOut');
        if (zoomOut && parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor) {
            zoomOut.classList.add('e-disabled');
            zoomOut.parentElement.classList.add('e-overlay');
        }
        else if (zoomOut) {
            zoomOut.classList.remove('e-disabled');
            zoomOut.parentElement.classList.remove('e-overlay');
        }
        const pan = document.querySelector('#' + parent.element.id + '_pan');
        if (pan && parent.zoomSettings.zoomFactor <= parent.zoomSettings.minZoomFactor) {
            pan.style.display = 'none';
        }
        else if (pan) {
            pan.style.display = 'block';
        }
    }
    createLeftToolbarControls() {
        const parent = this.parent;
        if (this.defToolbarItems !== undefined && this.defToolbarItems.length > 0 &&
            (document.getElementById(parent.element.id + '_toolbar'))) {
            const uploadDiv = document.getElementById(parent.element.id + '_toolbar')
                .querySelector('.e-image-upload');
            if (uploadDiv) {
                const uploadElem = uploadDiv.getElementsByTagName('input')[0];
                const uploadBtnElem = uploadDiv.getElementsByTagName('button')[0];
                uploadBtnElem.className = 'e-tbar-btn e-tbtn-txt top-icon';
                uploadBtnElem.innerHTML = '';
                uploadBtnElem.appendChild(parent.createElement('span', {
                    className: 'e-btn-icon e-icons e-upload-icon e-icon-left'
                }));
                uploadElem.onchange = this.fileSelect.bind(this, uploadElem);
            }
        }
    }
    fileSelect(inputElement, args) {
        this.parent.notify('draw', { prop: 'fileSelect', value: { inputElement: inputElement, args: args } });
    }
    renderAnnotationBtn(isContextualToolbar) {
        const parent = this.parent;
        const items = [];
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Pen') > -1)) {
            items.push({ text: this.l10n.getConstant('Pen'), id: 'pen', iconCss: 'e-icons e-free-pen' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Line') > -1)) {
            items.push({ text: this.l10n.getConstant('Line'), id: 'line', iconCss: 'e-icons e-line' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Rectangle') > -1)) {
            items.push({ text: this.l10n.getConstant('Rectangle'), id: 'rectangle', iconCss: 'e-icons e-rectangle' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Ellipse') > -1)) {
            items.push({ text: this.l10n.getConstant('Ellipse'), id: 'ellipse', iconCss: 'e-icons e-circle' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Arrow') > -1)) {
            items.push({ text: this.l10n.getConstant('Arrow'), id: 'arrow', iconCss: 'e-icons e-arrow-right-up' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Path') > -1)) {
            items.push({ text: this.l10n.getConstant('Path'), id: 'path', iconCss: 'e-icons e-critical-path' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Text') > -1)) {
            items.push({ text: this.l10n.getConstant('Text'), id: 'text', iconCss: 'e-icons e-add-text' });
        }
        const obj = { freehandDrawSelectedId: null };
        parent.notify('freehand-draw', { prop: 'getFreehandDrawSelectedId', onPropertyChange: false, value: { obj: obj } });
        const duplicateElement = document.querySelector('#' + parent.element.id + '_duplicate');
        const removeElement = document.querySelector('#' + parent.element.id + '_remove');
        const editTextElement = document.querySelector('#' + parent.element.id + '_editText');
        if ((parent.activeObj.activePoint.width === 0 && parent.activeObj.activePoint.height === 0) &&
            (isNullOrUndefined(parent.activeObj.pointColl) || (parent.activeObj.pointColl
                && parent.activeObj.pointColl.length === 0)) &&
            isNullOrUndefined(obj['freehandDrawSelectedId'])) {
            if (duplicateElement) {
                duplicateElement.classList.add('e-disabled');
            }
            if (removeElement) {
                removeElement.classList.add('e-disabled');
            }
            if (editTextElement) {
                editTextElement.classList.add('e-disabled');
            }
        }
        else {
            if (duplicateElement) {
                duplicateElement.classList.remove('e-disabled');
            }
            if (removeElement) {
                removeElement.classList.remove('e-disabled');
            }
            if (editTextElement) {
                editTextElement.classList.remove('e-disabled');
            }
        }
        const iconCss = isContextualToolbar ? this.getCurrentShapeIcon(parent.activeObj.shape) : 'e-annotation';
        const drpDownBtn = new DropDownButton({ items: items, iconCss: 'e-icons ' + iconCss,
            cssClass: 'e-image-popup',
            open: (args) => {
                if (Browser.isDevice) {
                    args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        args.element.parentElement.offsetHeight + 'px';
                }
                if (parent.activeObj.shape) {
                    document.getElementById(parent.activeObj.shape).classList.add('e-selected');
                }
                else if (parent.togglePen) {
                    document.getElementById('pen').classList.add('e-selected');
                }
            },
            select: (args) => {
                parent.okBtn();
                let isCropSelection = false;
                let splitWords;
                if (parent.activeObj.shape !== undefined) {
                    splitWords = parent.activeObj.shape.split('-');
                }
                if (splitWords === undefined && parent.currObjType.isCustomCrop) {
                    isCropSelection = true;
                }
                else if (splitWords !== undefined && splitWords[0] === 'crop') {
                    isCropSelection = true;
                }
                parent.currObjType.isCustomCrop = false;
                if (isCropSelection || parent.togglePan) {
                    parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                    this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                    this.refreshToolbar('main');
                }
                const obj = { currentFreehandDrawIndex: null };
                parent.notify('freehand-draw', { prop: 'getCurrentFreehandDrawIndex', value: { obj: obj } });
                drpDownBtn.iconCss = 'e-icons ' + this.getCurrentShapeIcon(args.item.id);
                switch (args.item.id) {
                    case 'pen':
                        parent.notify('draw', { prop: 'setTempFreehandCounter', value: { tempFreehandCounter: parent.freehandCounter } });
                        parent.notify('draw', { prop: 'setTempCurrentFreehandDrawIndex', value: { tempCurrentFreehandDrawIndex: obj['currentFreehandDrawIndex'] } });
                        this.currentToolbar = 'pen';
                        parent.freeHandDraw(true);
                        break;
                    case 'text':
                        this.currentToolbar = 'text';
                        parent.notify('shape', { prop: 'draw-shape-text' });
                        // this.setInitialShapeSettings(args);
                        // parent.activeObj.textFlip = parent.transform.currFlipState;
                        // parent.notify('selection', {prop: 'annotate', value: {shape: args.item.id }});
                        // parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: {type: 'text',
                        //     isApplyBtn: null, isCropping: null, isZooming: null, cType: null}});
                        break;
                    default:
                        this.currentToolbar = 'shapes';
                        /// parent.notify('shape', { prop: 'draw-shape', value: {obj: (args.item.id).toLowerCase()}});
                        this.setInitialShapeSettings(args);
                        parent.notify('selection', { prop: 'annotate', value: { shape: args.item.id } });
                        parent.notify('toolbar', { prop: 'refresh-toolbar', onPropertyChange: false, value: { type: 'shapes',
                                isApplyBtn: null, isCropping: null, isZooming: null, cType: null } });
                        break;
                }
                this.updateToolbarItems();
            }
        });
        // Render initialized DropDownButton.
        drpDownBtn.appendTo('#' + parent.element.id + '_annotationBtn');
    }
    renderCropBtn() {
        const parent = this.parent;
        const items = [];
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('CustomSelection') > -1)) {
            items.push({ text: this.l10n.getConstant('Custom'), id: 'custom', iconCss: 'e-icons e-custom' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('CircleSelection') > -1)) {
            items.push({ text: this.l10n.getConstant('Circle'), id: 'circle', iconCss: 'e-icons e-circle' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('SquareSelection') > -1)) {
            items.push({ text: this.l10n.getConstant('Square'), id: 'square', iconCss: 'e-icons e-square' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('RatioSelection') > -1)) {
            items.push({ text: '3:2', id: '3:2', iconCss: 'e-icons e-custom-a' });
            items.push({ text: '4:3', id: '4:3', iconCss: 'e-icons e-custom-b' });
            items.push({ text: '5:4', id: '5:4', iconCss: 'e-icons e-custom-c' });
            items.push({ text: '7:5', id: '7:5', iconCss: 'e-icons e-custom-d' });
            items.push({ text: '16:9', id: '16:9', iconCss: 'e-icons e-custom-e' });
        }
        let iconCss;
        let shape;
        if (parent.activeObj.shape) {
            iconCss = this.getCurrentShapeIcon(parent.activeObj.shape);
            shape = parent.activeObj.shape;
        }
        else if (parent.currSelectionPoint) {
            iconCss = this.getCurrentShapeIcon(parent.currSelectionPoint.shape);
            shape = parent.currSelectionPoint.shape;
        }
        else {
            iconCss = 'e-custom';
            shape = 'custom';
        }
        const drpDownBtn = new DropDownButton({
            open: (args) => {
                if (parent.togglePan) {
                    this.cancelPan();
                }
                if (Browser.isDevice) {
                    args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        args.element.parentElement.offsetHeight + 'px';
                }
                if (parent.activeObj.shape && parent.activeObj.shape.split('-').length > 1) {
                    document.getElementById(parent.activeObj.shape.split('-')[1]).classList.add('e-selected');
                }
                parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
            },
            items: items,
            select: (args) => {
                this.cropSelect(args);
                drpDownBtn.iconCss = 'e-icons ' + this.getCurrentShapeIcon('crop-' + args.item.id);
                drpDownBtn.content = parent.toPascalCase(args.item.id);
            },
            iconCss: 'e-icons ' + iconCss, cssClass: 'e-image-popup',
            content: parent.toPascalCase(shape.replace('crop-', ''))
        });
        drpDownBtn.appendTo('#' + parent.element.id + '_cropBtn');
    }
    renderTransformBtn() {
        const parent = this.parent;
        const items = [];
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('RotateLeft') > -1)) {
            items.push({ text: this.l10n.getConstant('RotateLeft'), id: 'rotateleft', iconCss: 'e-icons e-anti-clock-wise' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('RotateRight') > -1)) {
            items.push({ text: this.l10n.getConstant('RotateRight'), id: 'rotateright', iconCss: 'e-icons e-clock-wise' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('FlipHorizontal') > -1)) {
            items.push({ text: this.l10n.getConstant('HorizontalFlip'), id: 'horizontalflip', iconCss: 'e-icons e-horizontal-flip' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('FlipVertical') > -1)) {
            items.push({ text: this.l10n.getConstant('VerticalFlip'), id: 'verticalflip', iconCss: 'e-icons e-vertical-flip' });
        }
        const drpDownBtn = new DropDownButton({
            open: (args) => {
                if (Browser.isDevice) {
                    const ht = args.element.parentElement.offsetHeight;
                    args.element.parentElement.style.display = 'none';
                    args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        ht + 'px';
                    args.element.parentElement.style.display = 'block';
                }
            },
            items: items, select: parent.transformSelect.bind(this),
            iconCss: 'e-icons e-transform', cssClass: 'e-image-popup'
        });
        drpDownBtn.appendTo('#' + parent.element.id + '_transformBtn');
    }
    renderSaveBtn() {
        const parent = this.parent;
        const saveItems = [
            { text: 'JPEG', id: 'jpeg' },
            { text: 'PNG', id: 'png' },
            { text: 'SVG', id: 'svg' }
        ];
        const ddbElem = document.getElementById(parent.element.id + '_saveBtn');
        if (ddbElem) {
            // Initialize the DropDownButton component.
            const saveDrpDownBtn = new DropDownButton({ items: saveItems, cssClass: 'e-caret-hide e-image-popup', iconCss: 'e-icons e-save',
                select: (args) => {
                    parent.export(args.item.text);
                }
            });
            saveDrpDownBtn.appendTo('#' + parent.element.id + '_saveBtn');
        }
    }
    getCropTransformToolbarItem() {
        const parent = this.parent;
        const toolbarItems = [];
        toolbarItems.push({ id: parent.element.id + '_crop', tooltipText: this.l10n.getConstant('CropSelection'), align: 'Center',
            template: '<button id="' + parent.element.id + '_cropBtn"></button>'
        });
        toolbarItems.push({ align: 'Center', type: 'Separator' });
        toolbarItems.push({ id: parent.element.id + '_rotateLeft', prefixIcon: 'e-icons e-anti-clock-wise',
            tooltipText: this.l10n.getConstant('RotateLeft'), align: 'Center' });
        toolbarItems.push({ id: parent.element.id + '_rotateRight', prefixIcon: 'e-icons e-clock-wise',
            tooltipText: this.l10n.getConstant('RotateRight'), align: 'Center' });
        toolbarItems.push({ align: 'Center', type: 'Separator' });
        toolbarItems.push({ id: parent.element.id + '_horizontalFlip', prefixIcon: 'e-icons e-horizontal-flip',
            tooltipText: this.l10n.getConstant('HorizontalFlip'), align: 'Center' });
        toolbarItems.push({ id: parent.element.id + '_verticalFlip', prefixIcon: 'e-icons e-vertical-flip',
            tooltipText: this.l10n.getConstant('VerticalFlip'), align: 'Center' });
        if (!Browser.isDevice) {
            toolbarItems.push({ id: parent.element.id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right' });
            toolbarItems.push({ id: parent.element.id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    }
    getShapesToolbarItem(items) {
        const parent = this.parent;
        const toolbarItems = [];
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar)) {
            toolbarItems.push({ id: parent.element.id + '_annotation', tooltipText: this.l10n.getConstant('Annotation'), align: 'Center',
                template: '<button id="' + parent.element.id + '_annotationBtn"></button>' });
        }
        if (items.indexOf('fillColor') > -1) {
            toolbarItems.push({ prefixIcon: 'e-icons e-copy', id: parent.element.id + '_fillcolor',
                cssClass: 'top-icon e-fill', tooltipText: this.l10n.getConstant('FillColor'), align: 'Center', type: 'Input',
                template: '<button id="' + parent.element.id + '_fillColorBtn"></button>' });
        }
        if (items.indexOf('strokeColor') > -1) {
            toolbarItems.push({ prefixIcon: 'e-icons e-copy', id: parent.element.id + '_strokecolor',
                cssClass: 'top-icon e-stroke', tooltipText: this.l10n.getConstant('StrokeColor'), align: 'Center', type: 'Input',
                template: '<button id="' + parent.element.id + '_borderColorBtn"></button>' });
        }
        if (items.indexOf('strokeWidth') > -1) {
            toolbarItems.push({ id: parent.element.id + '_strokeWidth', cssClass: 'top-icon e-size', tooltipText: 'Stroke Width', align: 'Center',
                type: 'Input', template: '<button id="' + parent.element.id + '_borderWidthBtn"></button>' });
        }
        if (items.indexOf('start') > -1) {
            toolbarItems.push({ id: parent.element.id + '_start', cssClass: 'top-icon e-size', tooltipText: 'Start', align: 'Center',
                type: 'Input', template: '<button id="' + parent.element.id + '_startBtn"></button>' });
        }
        if (items.indexOf('end') > -1) {
            toolbarItems.push({ id: parent.element.id + '_end', cssClass: 'top-icon e-size', tooltipText: 'End', align: 'Center',
                type: 'Input', template: '<button id="' + parent.element.id + '_endBtn"></button>' });
        }
        toolbarItems.push({ align: 'Center', type: 'Separator' });
        if (items.indexOf('duplicate') > -1) {
            toolbarItems.push({ id: parent.element.id + '_duplicate', prefixIcon: 'e-icons e-order', cssClass: 'top-icon e-order',
                tooltipText: this.l10n.getConstant('Duplicate'), align: 'Center' });
        }
        if (items.indexOf('remove') > -1) {
            toolbarItems.push({ id: parent.element.id + '_remove', prefixIcon: 'e-icons e-trash', cssClass: 'top-icon e-trash',
                tooltipText: this.l10n.getConstant('Remove'), align: 'Center' });
        }
        if (items.indexOf('text') > -1) {
            toolbarItems.push({ id: parent.element.id + '_editText', prefixIcon: 'e-icons e-annotation-edit', cssClass: 'top-icon e-annotation-edit',
                tooltipText: this.l10n.getConstant('EditText'), align: 'Center' });
        }
        const tempToolbarItems = this.processSubToolbar(items);
        for (let i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (!Browser.isDevice) {
            const obj = { shape: null };
            parent.notify('selection', { prop: 'getCurrentDrawingShape', value: { obj: obj } });
            if (obj['shape'] !== 'path') {
                toolbarItems.push({ id: parent.element.id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                    tooltipText: this.l10n.getConstant('OK'), align: 'Right' });
                toolbarItems.push({ id: parent.element.id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                    tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
            }
        }
        return toolbarItems;
    }
    initCropTransformToolbar() {
        const parent = this.parent;
        const leftItem = this.getLeftToolbarItem();
        const rightItem = this.getRightToolbarItem();
        const mainItem = this.getCropTransformToolbarItem();
        const zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = [...leftItem, ...zoomItem, ...mainItem, ...rightItem];
        }
        const toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: () => {
                this.renderCropBtn();
                this.wireZoomBtnEvents();
                if (!Browser.isDevice) {
                    this.renderSaveBtn();
                }
                parent.trigger('toolbarCreated', { toolbarType: 'shapes' });
                if (Browser.isDevice) {
                    if (this.defToolbarItems.length > 0 && document.getElementById(parent.element.id + '_bottomToolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    this.createLeftToolbarControls();
                    if (this.defToolbarItems.length > 0 && document.getElementById(parent.element.id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
                parent.select('custom');
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + parent.element.id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + parent.element.id + '_toolbar');
        }
        this.enableDisableTbrBtn();
        parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
    }
    getCurrentShapeIcon(shape) {
        let icon = '';
        switch (shape) {
            case 'rectangle':
                icon = 'e-rectangle';
                break;
            case 'ellipse':
                icon = 'e-circle';
                break;
            case 'line':
                icon = 'e-line';
                break;
            case 'arrow':
                icon = 'e-arrow-right-up';
                break;
            case 'path':
                icon = 'e-critical-path';
                break;
            case 'text':
                icon = 'e-add-text';
                break;
            case 'pen':
                icon = 'e-free-pen';
                break;
            case 'crop-custom':
                icon = 'e-custom';
                break;
            case 'crop-circle':
                icon = 'e-circle';
                break;
            case 'crop-square':
                icon = 'e-square';
                break;
            case 'crop-3:2':
                icon = 'e-custom-a';
                break;
            case 'crop-4:3':
                icon = 'e-custom-b';
                break;
            case 'crop-5:4':
                icon = 'e-custom-c';
                break;
            case 'crop-7:5':
                icon = 'e-custom-d';
                break;
            case 'crop-16:9':
                icon = 'e-custom-e';
                break;
            default:
                icon = 'e-free-pen';
                break;
        }
        return icon;
    }
    initShapesToolbarItem(items) {
        const parent = this.parent;
        const leftItem = this.getLeftToolbarItem();
        const rightItem = this.getRightToolbarItem();
        const mainItem = this.getShapesToolbarItem(items);
        const zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = [...leftItem, ...zoomItem, ...mainItem, ...rightItem];
        }
        const toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: () => {
                this.renderAnnotationBtn(true);
                this.createShapeColor(items);
                this.createShapeBtn(items);
                if (parent.activeObj.shape === 'arrow') {
                    this.createStartBtn();
                    this.createEndBtn();
                }
                this.wireZoomBtnEvents();
                if (!Browser.isDevice) {
                    this.renderSaveBtn();
                }
                parent.trigger('toolbarCreated', { toolbarType: 'shapes' });
                if (Browser.isDevice) {
                    if (this.defToolbarItems.length > 0 && document.getElementById(parent.element.id + '_bottomToolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    this.createLeftToolbarControls();
                    if (this.defToolbarItems.length > 0 && document.getElementById(parent.element.id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + parent.element.id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + parent.element.id + '_toolbar');
        }
        this.enableDisableTbrBtn();
    }
    createShapeColor(items) {
        const parent = this.parent;
        if (items.indexOf('fillColor') > -1) {
            parent.element.querySelector('.e-template.e-fill').appendChild(parent.createElement('input', {
                id: parent.element.id + '_shape_fill'
            }));
            const fillColor = new ColorPicker({
                modeSwitcher: false, noColor: true, value: '',
                showButtons: false, mode: 'Palette', cssClass: 'e-shape-fill-color',
                change: (args) => {
                    parent.updateFillColor(args.currentValue.hex);
                    if (args.currentValue.rgba === '') {
                        fillDDB.element.children[0].classList.add('e-nocolor-item');
                    }
                    else {
                        fillDDB.element.children[0].classList.remove('e-nocolor-item');
                        fillDDB.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    }
                    fillDDB.toggle();
                }
            }, '#' + parent.element.id + '_shape_fill');
            const fillDDB = new DropDownButton({
                open: (args) => {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = fillDDB.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                        args.element.parentElement.style.left = parent.element.offsetLeft + 'px';
                    }
                },
                target: '.e-shape-fill-color',
                iconCss: 'e-dropdownbtn-preview'
            }, '#' + parent.element.id + '_fillColorBtn');
            fillColor.inline = true;
            parent.element.querySelector('.e-fill.e-template .e-dropdownbtn-preview').classList.add('e-nocolor-item');
        }
        if (items.indexOf('strokeColor') > -1) {
            parent.element.querySelector('.e-template.e-stroke').appendChild(parent.createElement('input', {
                id: parent.element.id + '_shape_stroke'
            }));
            const strokeColor = new ColorPicker({
                modeSwitcher: false, noColor: false, value: '#fff',
                showButtons: false, mode: 'Palette', cssClass: 'e-shape-stroke-color',
                change: (args) => {
                    parent.updateStrokeColor(args.currentValue.hex);
                    strokeDDB.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    strokeDDB.toggle();
                }
            }, '#' + parent.element.id + '_shape_stroke');
            const strokeDDB = new DropDownButton({
                open: (args) => {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = strokeDDB.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                        args.element.parentElement.style.left = parent.element.offsetLeft + 'px';
                    }
                },
                target: '.e-shape-stroke-color',
                iconCss: 'e-dropdownbtn-preview'
            }, '#' + parent.element.id + '_borderColorBtn');
            strokeColor.inline = true;
            parent.element.querySelector('.e-stroke.e-template .e-dropdownbtn-preview').style.background = '#fff';
        }
    }
    createShapeBtn(items) {
        const parent = this.parent;
        const strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('XSmall') },
            { id: '2', text: this.l10n.getConstant('Small') },
            { id: '3', text: this.l10n.getConstant('Medium') },
            { id: '4', text: this.l10n.getConstant('Large') },
            { id: '5', text: this.l10n.getConstant('XLarge') }
        ];
        if (items.indexOf('strokeWidth') > -1) {
            const strokeWidthBtn = document.getElementById(parent.element.id + '_borderWidthBtn');
            const spanElem = document.createElement('span');
            spanElem.innerHTML = this.l10n.getConstant('XSmall');
            spanElem.className = 'e-shape-stroke-width';
            strokeWidthBtn.appendChild(spanElem);
            // Initialize the DropDownButton component.
            const drpDownBtn = new DropDownButton({ items: strokeWidthItems,
                open: (args) => {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    const activeBtn = spanElem.innerHTML;
                    if (activeBtn !== '') {
                        args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                    }
                },
                select: (args) => {
                    spanElem.textContent = args.item.text;
                    parent.updateStrokeWidth(args.item.id);
                    if (Browser.isDevice) {
                        if (document.getElementById(parent.element.id + '_bottomToolbar')) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            const toolbar = getComponent(parent.element.id + '_bottomToolbar', 'toolbar');
                            toolbar.refreshOverflow();
                        }
                    }
                    else {
                        if (document.getElementById(parent.element.id + '_toolbar')) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            const toolbar = getComponent(parent.element.id + '_toolbar', 'toolbar');
                            toolbar.refreshOverflow();
                        }
                    }
                }
            });
            // Render initialized DropDownButton.
            drpDownBtn.appendTo('#' + parent.element.id + '_borderWidthBtn');
        }
    }
    createStartBtn() {
        const parent = this.parent;
        const strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('None') },
            { id: '2', text: this.l10n.getConstant('Bar') },
            { id: '3', text: this.l10n.getConstant('Arrow') },
            { id: '4', text: this.l10n.getConstant('ArrowSolid') },
            { id: '5', text: this.l10n.getConstant('Circle') },
            { id: '6', text: this.l10n.getConstant('CircleSolid') },
            { id: '7', text: this.l10n.getConstant('Square') },
            { id: '8', text: this.l10n.getConstant('SquareSolid') }
        ];
        const strokeWidthBtn = document.getElementById(parent.element.id + '_startBtn');
        const spanElem = document.createElement('span');
        if (isNullOrUndefined(parent.activeObj.start)) {
            parent.activeObj.start = 'none';
        }
        spanElem.innerHTML = parent.pascalToSplitWords(parent.activeObj.start);
        spanElem.className = 'e-shape-start';
        strokeWidthBtn.appendChild(spanElem);
        // Initialize the DropDownButton component.
        const drpDownBtn = new DropDownButton({ items: strokeWidthItems,
            open: (args) => {
                if (Browser.isDevice) {
                    args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        args.element.parentElement.offsetHeight + 'px';
                }
                const activeBtn = spanElem.innerHTML;
                if (activeBtn !== '') {
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                }
            },
            select: (args) => {
                spanElem.textContent = args.item.text;
                parent.updateArrow('startArrow', args.item.id);
            }
        });
        // Render initialized DropDownButton.
        drpDownBtn.appendTo('#' + parent.element.id + '_startBtn');
    }
    createEndBtn() {
        const parent = this.parent;
        const strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('None') },
            { id: '2', text: this.l10n.getConstant('Bar') },
            { id: '3', text: this.l10n.getConstant('Arrow') },
            { id: '4', text: this.l10n.getConstant('ArrowSolid') },
            { id: '5', text: this.l10n.getConstant('Circle') },
            { id: '6', text: this.l10n.getConstant('CircleSolid') },
            { id: '7', text: this.l10n.getConstant('Square') },
            { id: '8', text: this.l10n.getConstant('SquareSolid') }
        ];
        const strokeEndBtn = document.getElementById(parent.element.id + '_endBtn');
        const spanElem = document.createElement('span');
        if (isNullOrUndefined(parent.activeObj.end)) {
            parent.activeObj.end = 'arrowSolid';
        }
        spanElem.innerHTML = parent.pascalToSplitWords(parent.activeObj.end);
        spanElem.className = 'e-shape-end';
        strokeEndBtn.appendChild(spanElem);
        // Initialize the DropDownButton component.
        const drpDownBtn = new DropDownButton({ items: strokeWidthItems,
            open: (args) => {
                if (Browser.isDevice) {
                    args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                        args.element.parentElement.offsetHeight + 'px';
                }
                const activeBtn = spanElem.innerHTML;
                if (activeBtn !== '') {
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                }
            },
            select: (args) => {
                spanElem.textContent = args.item.text;
                parent.updateArrow('endArrow', args.item.id);
            }
        });
        // Render initialized DropDownButton.
        drpDownBtn.appendTo('#' + parent.element.id + '_endBtn');
    }
    getTextToolbarItem(items) {
        const parent = this.parent;
        const toolbarItems = [];
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar)) {
            toolbarItems.push({ id: parent.element.id + '_annotation', tooltipText: this.l10n.getConstant('Annotation'), align: 'Center',
                template: '<button id="' + parent.element.id + '_annotationBtn"></button>' });
        }
        if (items.indexOf('fontFamily') > -1) {
            toolbarItems.push({ id: parent.element.id + '_fontFamily', cssClass: 'top-icon e-img-font-family',
                tooltipText: this.l10n.getConstant('FontFamily'), align: 'Center',
                template: '<button id="' + parent.element.id + '_fontFamilyBtn"></button>' });
        }
        if (items.indexOf('fontSize') > -1) {
            toolbarItems.push({ id: parent.element.id + '_fontSize', cssClass: 'top-icon e-img-font-size',
                tooltipText: this.l10n.getConstant('FontSize'), align: 'Center',
                template: '<button id="' + parent.element.id + '_fontSizeBtn"></button>' });
        }
        if (items.indexOf('fontColor') > -1) {
            toolbarItems.push({ cssClass: 'top-icon e-text-font-color', id: parent.element.id + '_text_strokecolor',
                tooltipText: this.l10n.getConstant('FontColor'), align: 'Center',
                type: 'Input', template: '<button id="' + parent.element.id + '_fontColorBtn"></button>' });
        }
        if (items.indexOf('bold') > -1) {
            toolbarItems.push({ id: parent.element.id + '_bold', prefixIcon: 'e-icons e-bold', cssClass: 'top-icon e-bold',
                tooltipText: this.l10n.getConstant('Bold'), align: 'Center' });
        }
        if (items.indexOf('italic') > -1) {
            toolbarItems.push({ id: parent.element.id + '_italic', prefixIcon: 'e-icons e-italic', cssClass: 'top-icon e-italic',
                tooltipText: this.l10n.getConstant('Italic'), align: 'Center' });
        }
        toolbarItems.push({ align: 'Center', type: 'Separator' });
        if (items.indexOf('duplicate') > -1) {
            toolbarItems.push({ id: parent.element.id + '_duplicate', prefixIcon: 'e-icons e-order', cssClass: 'top-icon e-order',
                tooltipText: this.l10n.getConstant('Duplicate'), align: 'Center' });
        }
        if (items.indexOf('remove') > -1) {
            toolbarItems.push({ id: parent.element.id + '_remove', prefixIcon: 'e-icons e-trash', cssClass: 'top-icon e-trash',
                tooltipText: this.l10n.getConstant('Remove'), align: 'Center' });
        }
        if (items.indexOf('text') > -1) {
            toolbarItems.push({ id: parent.element.id + '_editText', prefixIcon: 'e-icons e-annotation-edit', cssClass: 'top-icon e-annotation-edit',
                tooltipText: this.l10n.getConstant('EditText'), align: 'Center' });
        }
        const tempToolbarItems = this.processSubToolbar(items);
        for (let i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (!Browser.isDevice) {
            toolbarItems.push({ id: parent.element.id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right' });
            toolbarItems.push({ id: parent.element.id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    }
    getFontFamilyItems() {
        if (Browser.isDevice) {
            return [{ id: 'arial', text: 'ABC' }, { id: 'calibri', text: 'ABC' }, { id: 'georgia', text: 'ABC' },
                { id: 'roboto', text: 'ABC' }, { id: 'tahoma', text: 'ABC' }];
        }
        return [{ id: 'arial', text: 'Arial' }, { id: 'calibri', text: 'Calibri' }, { id: 'georgia', text: 'Georgia' },
            { id: 'roboto', text: 'Roboto' }, { id: 'tahoma', text: 'Tahoma' }];
    }
    initTextToolbarItem(items) {
        const parent = this.parent;
        const leftItem = this.getLeftToolbarItem();
        const rightItem = this.getRightToolbarItem();
        const mainItem = this.getTextToolbarItem(items);
        const zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = [...leftItem, ...zoomItem, ...mainItem, ...rightItem];
        }
        const toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: () => {
                this.renderAnnotationBtn(true);
                this.createTextColor(items);
                this.createTextBtn(items);
                this.wireZoomBtnEvents();
                if (!Browser.isDevice) {
                    this.renderSaveBtn();
                }
                parent.trigger('toolbarCreated', { toolbarType: 'text' });
                if (Browser.isDevice) {
                    if (this.defToolbarItems.length > 0 && document.getElementById(parent.element.id + '_bottomToolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    this.createLeftToolbarControls();
                    if (this.defToolbarItems.length > 0 && document.getElementById(parent.element.id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + parent.element.id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + parent.element.id + '_toolbar');
        }
        this.enableDisableTbrBtn();
    }
    createTextColor(items) {
        const parent = this.parent;
        if (items.indexOf('fontColor') > -1 && parent.element.querySelector('.e-template.e-text-font-color')) {
            parent.element.querySelector('.e-template.e-text-font-color').appendChild(parent.createElement('input', {
                id: parent.element.id + '_text_font'
            }));
            const fontColor = new ColorPicker({
                modeSwitcher: false, value: '#fff',
                showButtons: false, mode: 'Palette', cssClass: 'e-text-fontt-color',
                change: (args) => {
                    parent.updateFontColor(args.currentValue.hex);
                    strokeDDB.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    strokeDDB.toggle();
                }
            }, '#' + parent.element.id + '_text_font');
            const strokeDDB = new DropDownButton({
                open: (args) => {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = strokeDDB.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                        args.element.parentElement.style.left = parent.element.offsetLeft + 'px';
                    }
                },
                target: '.e-text-fontt-color',
                iconCss: 'e-dropdownbtn-preview'
            }, '#' + parent.element.id + '_fontColorBtn');
            fontColor.inline = true;
            parent.element.querySelector('.e-text-font-color.e-template .e-dropdownbtn-preview').style.background
                = '#fff';
        }
    }
    createTextBtn(items) {
        const parent = this.parent;
        if (items.indexOf('fontFamily') > -1) {
            const fontNameBtn = document.getElementById(parent.element.id + '_fontFamilyBtn');
            const spanElem = document.createElement('span');
            if (Browser.isDevice) {
                spanElem.innerHTML = 'ABC';
                spanElem.setAttribute('style', 'font-family: arial');
            }
            else {
                spanElem.innerHTML = 'Arial';
            }
            spanElem.className = 'e-text-font-family';
            if (fontNameBtn) {
                fontNameBtn.appendChild(spanElem);
            }
            const fontFamilyBtn = new DropDownButton({ items: this.getFontFamilyItems(),
                cssClass: 'e-font-family',
                createPopupOnClick: true,
                beforeItemRender: (args) => {
                    args.element.setAttribute('style', 'font-family:' + args.element.id);
                },
                open: (args) => {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = fontFamilyBtn.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    let fontFamily;
                    if (parent.textArea.style.display === 'block') {
                        fontFamily = parent.textArea.style.fontFamily;
                    }
                    else {
                        fontFamily = parent.activeObj.textSettings.fontFamily;
                    }
                    args.element.querySelector('[id *= ' + '"' + fontFamily.toLowerCase()
                        + '"' + ']').classList.add('e-selected-btn');
                },
                select: (args) => {
                    spanElem.textContent = args.item.text;
                    if (Browser.isDevice) {
                        spanElem.setAttribute('style', 'font-family:' + args.item.id);
                    }
                    parent.updateFontFamily(args.item.id);
                }
            });
            fontFamilyBtn.appendTo('#' + parent.element.id + '_fontFamilyBtn');
        }
        if (items.indexOf('fontSize') > -1) {
            const fontSizeBtnElem = document.getElementById(parent.element.id + '_fontSizeBtn');
            const fontSizeSpanElem = document.createElement('span');
            const fontSizes = parent.getFontSizes();
            fontSizeSpanElem.innerHTML = fontSizes[0].text;
            fontSizeSpanElem.className = 'e-text-font-size';
            fontSizeBtnElem.appendChild(fontSizeSpanElem);
            const fontSizeBtn = new DropDownButton({
                cssClass: 'e-font-size',
                items: fontSizes,
                open: (args) => {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = fontSizeBtn.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    const activeBtn = fontSizeSpanElem.innerHTML;
                    args.element.querySelector('[aria-label *= ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                },
                select: (args) => {
                    fontSizeSpanElem.textContent = args.item.text;
                    parent.updateFontSize(args.item.text);
                }
            });
            fontSizeBtn.appendTo('#' + parent.element.id + '_fontSizeBtn');
        }
    }
    refreshToolbar(type, isApplyBtn, isCropping, isZooming, cType) {
        const parent = this.parent;
        if (!parent.isImageLoaded || parent.isCropToolbar) {
            return;
        }
        const item = type === 'shapes' && parent.activeObj.shape ? parent.activeObj.shape : type;
        const args = { toolbarType: item };
        if (type !== 'filter' && type !== 'color') {
            if (document.getElementById(parent.element.id + '_toolbar') && this.defToolbarItems.length > 0) {
                getComponent(document.getElementById(parent.element.id + '_toolbar'), 'toolbar').destroy();
                document.getElementById(parent.element.id + '_toolbar').innerHTML = '';
            }
            if (document.getElementById(parent.element.id + '_bottomToolbar') && this.defToolbarItems.length > 0) {
                if (document.getElementById(parent.element.id + '_bottomToolbar').className.indexOf('e-control') > -1) {
                    getComponent(document.getElementById(parent.element.id + '_bottomToolbar'), 'toolbar').destroy();
                    document.getElementById(parent.element.id + '_bottomToolbar').innerHTML = '';
                }
            }
        }
        this.refreshSlider();
        parent.isCropTab = false;
        switch (type) {
            case 'main':
                if (Browser.isDevice) {
                    if (isCropping) {
                        this.initMainToolbar(false, true, true);
                    }
                    else {
                        this.initMainToolbar(false, true, null);
                    }
                }
                else if (!Browser.isDevice || isZooming) {
                    if (isZooming) {
                        this.initMainToolbar(isApplyBtn, Browser.isDevice, null);
                    }
                    else {
                        this.initMainToolbar(isApplyBtn, Browser.isDevice, null);
                    }
                }
                if (Browser.isDevice) {
                    this.initBottomToolbar();
                }
                break;
            case 'shapes':
                if (Browser.isDevice) {
                    this.initMainToolbar(false, true, true);
                }
                if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'path') {
                    args.toolbarItems = ['strokeColor', 'strokeWidth', 'duplicate', 'remove'];
                }
                else if (parent.activeObj.shape === 'arrow') {
                    args.toolbarItems = ['strokeColor', 'strokeWidth', 'start', 'end', 'duplicate', 'remove'];
                }
                else {
                    args.toolbarItems = ['fillColor', 'strokeColor', 'strokeWidth', 'duplicate', 'remove'];
                }
                parent.trigger('toolbarUpdating', args);
                this.initShapesToolbarItem(args.toolbarItems);
                break;
            case 'text':
                if (Browser.isDevice) {
                    this.initMainToolbar(false, true, true);
                }
                args.toolbarItems = ['fontFamily', 'fontSize', 'fontColor', 'bold', 'italic', 'duplicate', 'remove', 'text'];
                parent.trigger('toolbarUpdating', args);
                this.initTextToolbarItem(args.toolbarItems);
                break;
            case 'pen':
                if (Browser.isDevice) {
                    this.initMainToolbar(false, true, true);
                }
                args.toolbarItems = ['strokeColor', 'strokeWidth', 'remove'];
                parent.trigger('toolbarUpdating', args);
                this.initPenToolbarItem(args.toolbarItems);
                break;
            case 'adjustment':
                if (Browser.isDevice) {
                    this.initMainToolbar(false, true, true);
                }
                this.initAdjustmentToolbarItem();
                break;
            case 'filter':
                this.updateContextualToolbar(type);
                break;
            case 'color':
                this.updateContextualToolbar(type, cType);
                break;
            case 'croptransform':
                parent.isCropTab = true;
                if (Browser.isDevice) {
                    this.initMainToolbar(false, true, true);
                }
                parent.updateCropTransformItems();
                this.initCropTransformToolbar();
                break;
        }
        this.currToolbar = type;
        this.refreshDropDownBtn(isCropping);
    }
    getAdjustmentToolbarItem() {
        const toolbarItems = [];
        const parent = this.parent;
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Brightness') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_brightness', prefixIcon: 'e-icons e-brightness', cssClass: 'top-icon e-brightness',
                tooltipText: this.l10n.getConstant('Brightness'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Contrast') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_contrast', prefixIcon: 'e-icons e-contrast', cssClass: 'top-icon e-contrast',
                tooltipText: this.l10n.getConstant('Contrast'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Hue') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_hue', prefixIcon: 'e-icons e-fade', cssClass: 'top-icon e-fade',
                tooltipText: this.l10n.getConstant('Hue'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Saturation') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_saturation', prefixIcon: 'e-icons e-saturation', cssClass: 'top-icon e-saturation',
                tooltipText: this.l10n.getConstant('Saturation'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Exposure') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_exposure', prefixIcon: 'e-icons e-grain', cssClass: 'top-icon e-grain',
                tooltipText: this.l10n.getConstant('Exposure'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Opacity') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_opacity', prefixIcon: 'e-icons e-opacity', cssClass: 'top-icon e-opacity',
                tooltipText: this.l10n.getConstant('Opacity'), align: 'Center' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Blur') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_blur', prefixIcon: 'e-icons e-tint', cssClass: 'top-icon e-tint',
                tooltipText: this.l10n.getConstant('Blur'), align: 'Center' });
        }
        const tempToolbarItems = this.processToolbar('center');
        for (let i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (!Browser.isDevice) {
            toolbarItems.push({ id: parent.element.id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right' });
            toolbarItems.push({ id: parent.element.id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    }
    getFilterToolbarItem() {
        const toolbarItems = [];
        const parent = this.parent;
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Default') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_default', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Default'), align: 'Center',
                template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + parent.element.id + '_defaultCanvas' + '></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant('Default') + '</span></div></div>' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Chrome') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_chrome', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Chrome'), align: 'Center',
                template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + parent.element.id + '_chromeCanvas' + '></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant('Chrome') + '</span></div></div>' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Cold') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_cold', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Cold'), align: 'Center',
                template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + parent.element.id + '_coldCanvas' + '></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant('Cold') + '</span></div></div>' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Warm') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_warm', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Warm'), align: 'Center',
                template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + parent.element.id + '_warmCanvas' + '></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant('Warm') + '</span></div></div>' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Grayscale') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_grayscale', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Grayscale'), align: 'Center',
                template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + parent.element.id + '_grayscaleCanvas' + '></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant('Grayscale') + '</span></div></div>' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Sepia') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_sepia', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Sepia'), align: 'Center',
                template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + parent.element.id + '_sepiaCanvas' + '></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant('Sepia') + '</span></div></div>' });
        }
        if (isNullOrUndefined(parent.toolbar) || (parent.toolbar && parent.toolbar.indexOf('Invert') > -1)) {
            toolbarItems.push({ id: parent.element.id + '_invert', prefixIcon: 'e-icons e-none', cssClass: 'top-icon e-none',
                tooltipText: this.l10n.getConstant('Invert'), align: 'Center',
                template: '<div class="filter-wrapper" style="box-sizing: content-box;"><canvas id=' + parent.element.id + '_invertCanvas' + '></canvas><div style="text-align:center;"><span>' + this.l10n.getConstant('Invert') + '</span></div></div>' });
        }
        const tempToolbarItems = this.processToolbar('center');
        for (let i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        return toolbarItems;
    }
    getPenToolbarItem(items) {
        const parent = this.parent;
        const toolbarItems = [];
        if (isNullOrUndefined(parent.toolbar) || parent.toolbar) {
            toolbarItems.push({ id: parent.element.id + '_annotation', tooltipText: this.l10n.getConstant('Annotation'), align: 'Center',
                template: '<button id="' + parent.element.id + '_annotationBtn"></button>' });
        }
        if (items.indexOf('strokeColor') > -1) {
            toolbarItems.push({ prefixIcon: 'e-icons e-copy', id: parent.element.id + '_pen_strokecolor',
                cssClass: 'top-icon e-pen-stroke-color',
                tooltipText: this.l10n.getConstant('StrokeColor'), align: 'Center', type: 'Input',
                template: '<button id="' + parent.element.id + '_penColorBtn"></button>' });
        }
        if (items.indexOf('strokeWidth') > -1) {
            toolbarItems.push({ prefixIcon: 'e-icons e-copy', cssClass: 'top-icon e-size',
                tooltipText: this.l10n.getConstant('StrokeWidth'),
                align: 'Center', type: 'Input', template: '<button id="' + parent.element.id + '_penStrokeWidth"></button>' });
        }
        toolbarItems.push({ align: 'Center', type: 'Separator' });
        if (items.indexOf('remove') > -1) {
            toolbarItems.push({ id: parent.element.id + '_remove', prefixIcon: 'e-icons e-trash', cssClass: 'top-icon e-trash',
                tooltipText: this.l10n.getConstant('Remove'), align: 'Center' });
        }
        const tempToolbarItems = this.processSubToolbar(items);
        for (let i = 0, len = tempToolbarItems.length; i < len; i++) {
            toolbarItems.push(tempToolbarItems[i]);
        }
        if (!Browser.isDevice) {
            toolbarItems.push({ id: parent.element.id + '_ok', prefixIcon: 'e-icons e-check', cssClass: 'top-icon e-tick',
                tooltipText: this.l10n.getConstant('OK'), align: 'Right' });
            toolbarItems.push({ id: parent.element.id + '_cancel', prefixIcon: 'e-icons e-close', cssClass: 'top-icon e-save',
                tooltipText: this.l10n.getConstant('Cancel'), align: 'Right' });
        }
        return toolbarItems;
    }
    initPenToolbarItem(items) {
        const parent = this.parent;
        const leftItem = this.getLeftToolbarItem();
        const rightItem = this.getRightToolbarItem();
        const mainItem = this.getPenToolbarItem(items);
        const zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = [...leftItem, ...zoomItem, ...mainItem, ...rightItem];
        }
        const toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: () => {
                this.renderAnnotationBtn(true);
                this.createPenColor(items);
                this.createPenBtn(items);
                this.wireZoomBtnEvents();
                if (!Browser.isDevice) {
                    this.renderSaveBtn();
                }
                parent.trigger('toolbarCreated', { toolbarType: 'pen' });
                if (Browser.isDevice) {
                    if (this.defToolbarItems.length > 0 && document.getElementById(parent.element.id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    this.createLeftToolbarControls();
                    if (this.defToolbarItems.length > 0 && document.getElementById(parent.element.id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + parent.element.id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + parent.element.id + '_toolbar');
        }
        this.enableDisableTbrBtn();
    }
    createPenColor(items) {
        const parent = this.parent;
        if (items.indexOf('strokeColor') > -1) {
            parent.element.querySelector('.e-template.e-pen-stroke-color').appendChild(parent.createElement('input', {
                id: parent.element.id + '_pen_stroke'
            }));
            const penColor = new ColorPicker({
                modeSwitcher: false, value: '#fff',
                showButtons: false, mode: 'Palette', cssClass: 'e-pen-color',
                change: (args) => {
                    parent.updatePenStrokeColor(args.currentValue.hex);
                    this.selFhdColor = args.currentValue.hex;
                    strokeDDB.element.children[0].style.backgroundColor = args.currentValue.rgba;
                    strokeDDB.toggle();
                }
            }, '#' + parent.element.id + '_pen_stroke');
            const strokeDDB = new DropDownButton({
                open: (args) => {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = strokeDDB.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                        args.element.parentElement.style.left = parent.element.offsetLeft + 'px';
                    }
                },
                target: '.e-pen-color',
                iconCss: 'e-dropdownbtn-preview'
            }, '#' + parent.element.id + '_penColorBtn');
            penColor.inline = true;
            const obj = { tempFreeHandDrawEditingStyles: null };
            parent.notify('freehand-draw', { prop: 'getTempFreeHandDrawEditingStyles', value: { obj: obj } });
            const indexObj = { freehandSelectedIndex: null };
            parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
            if (!isNullOrUndefined(indexObj['freehandSelectedIndex']) && indexObj['freehandSelectedIndex'] > -1) {
                parent.element.querySelector('.e-pen-stroke-color.e-template .e-dropdownbtn-preview').style.background
                    = this.selFhdColor === '#42a5f5' ? obj['tempFreeHandDrawEditingStyles'].strokeColor :
                        parent.pointColl[indexObj['freehandSelectedIndex']].strokeColor;
            }
            else {
                parent.element.querySelector('.e-pen-stroke-color.e-template .e-dropdownbtn-preview').style.background
                    = '#fff';
            }
        }
    }
    createPenBtn(items) {
        const parent = this.parent;
        const strokeWidthItems = [
            { id: '1', text: this.l10n.getConstant('XSmall') },
            { id: '2', text: this.l10n.getConstant('Small') },
            { id: '3', text: this.l10n.getConstant('Medium') },
            { id: '4', text: this.l10n.getConstant('Large') },
            { id: '5', text: this.l10n.getConstant('XLarge') }
        ];
        if (items.indexOf('strokeWidth') > -1) {
            const strokeWidthBtn = document.getElementById(parent.element.id + '_penStrokeWidth');
            const spanElem = document.createElement('span');
            const indexObj = { freehandSelectedIndex: null };
            parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
            if (!isNullOrUndefined(indexObj['freehandSelectedIndex']) && indexObj['freehandSelectedIndex'] > -1) {
                spanElem.innerHTML = this.getPenStroke(parent.pointColl[indexObj['freehandSelectedIndex']].strokeWidth);
            }
            else {
                spanElem.innerHTML = this.l10n.getConstant('Small');
            }
            spanElem.className = 'e-pen-stroke-width';
            strokeWidthBtn.appendChild(spanElem);
            const drpDownBtn = new DropDownButton({ items: strokeWidthItems,
                open: (args) => {
                    if (Browser.isDevice) {
                        args.element.parentElement.style.top = drpDownBtn.element.getBoundingClientRect().top -
                            args.element.parentElement.offsetHeight + 'px';
                    }
                    const activeBtn = spanElem.innerHTML;
                    args.element.querySelector('[aria-label = ' + '"' + activeBtn + '"' + ']').classList.add('e-selected-btn');
                },
                select: (args) => {
                    spanElem.textContent = args.item.text;
                    parent.updatePenStrokeWidth(args.item.id);
                    if (Browser.isDevice) {
                        if (document.getElementById(parent.element.id + '_bottomToolbar')) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            const toolbar = getComponent(parent.element.id + '_bottomToolbar', 'toolbar');
                            toolbar.refreshOverflow();
                        }
                    }
                    else {
                        if (document.getElementById(parent.element.id + '_toolbar')) {
                            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                            const toolbar = getComponent(parent.element.id + '_toolbar', 'toolbar');
                            toolbar.refreshOverflow();
                        }
                    }
                }
            });
            // Render initialized DropDownButton.
            drpDownBtn.appendTo('#' + parent.element.id + '_penStrokeWidth');
        }
    }
    getPenStroke(value) {
        let textContent = '';
        const valueToTextContent = {
            1: this.l10n.getConstant('XSmall'),
            2: this.l10n.getConstant('Small'),
            3: this.l10n.getConstant('Medium'),
            4: this.l10n.getConstant('Large'),
            5: this.l10n.getConstant('XLarge')
        };
        if (value >= 1 && value <= 5) {
            textContent = valueToTextContent[value];
        }
        return textContent;
    }
    initAdjustmentToolbarItem() {
        const parent = this.parent;
        const leftItem = this.getLeftToolbarItem(null);
        const rightItem = this.getRightToolbarItem();
        const mainItem = this.getAdjustmentToolbarItem();
        const zoomItem = this.getZoomToolbarItem();
        if (Browser.isDevice) {
            this.defToolbarItems = mainItem;
        }
        else {
            this.defToolbarItems = [...leftItem, ...zoomItem, ...mainItem, ...rightItem];
        }
        const toolbar = new Toolbar({
            width: '100%',
            items: this.defToolbarItems,
            clicked: this.defToolbarClicked.bind(this),
            created: () => {
                this.wireZoomBtnEvents();
                if (!Browser.isDevice) {
                    this.renderSaveBtn();
                }
                if (Browser.isDevice) {
                    if (this.defToolbarItems.length > 0 && document.getElementById(parent.element.id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
                else {
                    this.createLeftToolbarControls();
                    if (this.defToolbarItems.length > 0 && document.getElementById(parent.element.id + '_toolbar')) {
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        toolbar.refreshOverflow();
                    }
                }
            }
        });
        if (Browser.isDevice) {
            toolbar.appendTo('#' + parent.element.id + '_bottomToolbar');
        }
        else {
            toolbar.appendTo('#' + parent.element.id + '_toolbar');
        }
        this.enableDisableTbrBtn();
    }
    initFilterToolbarItem() {
        const parent = this.parent;
        const mainItem = this.getFilterToolbarItem();
        if (document.querySelector('#' + parent.element.id + '_contextualToolbar').classList.contains('e-control')) {
            getComponent(document.getElementById(parent.element.id + '_contextualToolbar'), 'toolbar').destroy();
        }
        const toolbar = new Toolbar({
            width: '100%',
            items: mainItem,
            clicked: this.contextualToolbarClicked.bind(this),
            created: () => {
                this.updatePrivateVariables();
                this.createCanvasFilter();
                if (parent.currentFilter === '') {
                    parent.currentFilter = parent.element.id + '_default';
                }
                const hdrWrapper = document.querySelector('#' + parent.element.id + '_headWrapper');
                if (hdrWrapper) {
                    hdrWrapper.style.display = 'none';
                }
                document.getElementById(parent.currentFilter + 'Canvas').parentElement.parentElement.classList.add('e-selected');
                this.enableDisableTbrBtn();
                toolbar.refreshOverflow();
            }
        });
        toolbar.appendTo('#' + parent.element.id + '_contextualToolbar');
    }
    createCanvasFilter() {
        const parent = this.parent;
        showSpinner(parent.element);
        parent.element.style.opacity = '0.5';
        const imageData = parent.getCurrentCanvasData();
        this.inMemoryCanvas.width = imageData.width;
        this.inMemoryCanvas.height = imageData.height;
        this.inMemoryContext.putImageData(imageData, 0, 0);
        this.updateFilterCanvas('_defaultCanvas', 'default');
        this.updateFilterCanvas('_chromeCanvas', 'chrome');
        this.updateFilterCanvas('_coldCanvas', 'cold');
        this.updateFilterCanvas('_warmCanvas', 'warm');
        this.updateFilterCanvas('_grayscaleCanvas', 'grayscale');
        this.updateFilterCanvas('_sepiaCanvas', 'sepia');
        this.updateFilterCanvas('_invertCanvas', 'invert');
        hideSpinner(parent.element);
        parent.element.style.opacity = '1';
        parent.initialAdjustmentValue = this.lowerContext.filter;
    }
    updateFilterCanvas(selector, type) {
        const parent = this.parent;
        const filter = parent.element.querySelector('#' + parent.element.id + selector);
        if (filter) {
            let ctx = filter.getContext('2d');
            ctx = filter.getContext('2d');
            filter.style.width = '100px';
            filter.style.height = '100px';
            parent.notify('filter', { prop: 'updateAdj', value: { type: type, value: null, isPreview: true, ctx: ctx } });
            ctx.drawImage(this.inMemoryCanvas, 0, 0, 300, 150);
        }
    }
    getQuickAccessToolbarItem(isPenEdit) {
        const parent = this.parent;
        const args = { cancel: false, toolbarItems: [] };
        const toolbarItems = [];
        if (isNullOrUndefined(isPenEdit)) {
            toolbarItems.push('Clone');
            toolbarItems.push('Delete');
            if (parent.activeObj.shape === 'text') {
                toolbarItems.push('EditText');
            }
            args.shape = parent.toPascalCase(parent.activeObj.shape);
        }
        else if (isPenEdit) {
            toolbarItems.push('Delete');
            args.shape = 'Freehand draw';
        }
        args.toolbarItems = extend([], toolbarItems, null, true);
        parent.trigger('quickAccessToolbarOpen', args);
        let orgToolbarItems = [];
        if (args.cancel) {
            orgToolbarItems = [];
        }
        else {
            for (let i = 0; i < args.toolbarItems.length; i++) {
                switch (args.toolbarItems[i]) {
                    case 'Clone':
                        orgToolbarItems.push({ id: parent.element.id + '_duplicate', prefixIcon: 'e-icons e-order', cssClass: 'top-icon e-order',
                            tooltipText: this.l10n.getConstant('Duplicate'), align: 'Left' });
                        break;
                    case 'Delete':
                        orgToolbarItems.push({ id: parent.element.id + '_remove', prefixIcon: 'e-icons e-trash', cssClass: 'top-icon e-trash',
                            tooltipText: this.l10n.getConstant('Remove'), align: 'Left' });
                        break;
                    case 'EditText':
                        orgToolbarItems.push({ id: parent.element.id + '_editText', prefixIcon: 'e-icons e-annotation-edit', cssClass: 'top-icon e-annotation-edit',
                            tooltipText: this.l10n.getConstant('EditText'), align: 'Left' });
                        break;
                    default:
                        orgToolbarItems.push(args.toolbarItems[i]);
                        break;
                }
            }
        }
        return orgToolbarItems;
    }
    renderQAT(isPenEdit) {
        const parent = this.parent;
        if (parent.activeObj && parent.showQuickAccessToolbar) {
            const qtArea = document.getElementById(parent.element.id + '_quickAccessToolbarArea');
            if (qtArea) {
                this.destroyQuickAccessToolbar();
                qtArea.style.display = 'block';
            }
            const items = this.getQuickAccessToolbarItem(isPenEdit);
            if (items.length === 0) {
                return;
            }
            if (isNullOrUndefined(parent.quickAccessToolbarTemplate)) {
                const toolbarObj = new Toolbar({
                    items: items,
                    clicked: this.quickAccessToolbarClicked.bind(this)
                });
                toolbarObj.appendTo('#' + parent.element.id + '_quickAccessToolbar');
            }
            if (isNullOrUndefined(isPenEdit)) {
                qtArea.style.width = 'auto';
                parent.activeObj.activePoint.width = Math.abs(parent.activeObj.activePoint.width);
                parent.activeObj.activePoint.height = Math.abs(parent.activeObj.activePoint.height);
                let x = parent.activeObj.activePoint.startX < parent.activeObj.activePoint.endX ?
                    parent.activeObj.activePoint.startX : parent.activeObj.activePoint.endX;
                let y = parent.activeObj.activePoint.startY < parent.activeObj.activePoint.endY ?
                    parent.activeObj.activePoint.startY : parent.activeObj.activePoint.endY;
                let width = parent.activeObj.activePoint.width;
                if (parent.activeObj.rotatedAngle !== 0 && parent.activeObj.shape !== 'arrow') {
                    const object = { activePoint: null };
                    parent.notify('shape', { prop: 'getSquarePointForRotatedShape', onPropertyChange: false,
                        value: { obj: parent.activeObj, object: object } });
                    const point = object['activePoint'];
                    x = point.startX;
                    y = point.startY;
                    width = point.width;
                }
                else if (parent.activeObj.shape === 'path') {
                    const path = parent.getSquarePointForPath(parent.activeObj);
                    x = path.startX;
                    y = path.startY;
                    width = path.width;
                }
                qtArea.style.left = (x + (width / 2)) - (items.length * 25) + 'px';
                if (y - 60 < parent.img.destTop) {
                    qtArea.style.top = parent.img.destTop + 'px';
                }
                else {
                    qtArea.style.top = y - 60 + 'px';
                }
            }
            else if (isPenEdit) {
                const obj = { activePoint: null };
                const indexObj = { freehandSelectedIndex: null };
                parent.notify('freehand-draw', { prop: 'getFreehandSelectedIndex', onPropertyChange: false, value: { obj: indexObj } });
                parent.notify('freehand-draw', { prop: 'getSqPtFD',
                    value: { idx: indexObj['freehandSelectedIndex'], obj: obj } });
                const point = obj['activePoint'];
                qtArea.style.width = 'auto';
                qtArea.style.left = (point.startX + (point.width / 2)) - (items.length * 27) + 'px';
                if (point.startY - 60 < parent.img.destTop) {
                    qtArea.style.top = parent.img.destTop + 'px';
                }
                else {
                    qtArea.style.top = point.startY - 60 + 'px';
                }
            }
        }
    }
    refreshDropDownBtn(isDisabled) {
        if (isNullOrUndefined(isDisabled)) {
            return;
        }
        const parent = this.parent;
        const annotation = document.querySelector('#' + parent.element.id + '_annotationBtn');
        if (annotation) {
            if (isDisabled) {
                annotation.classList.add('e-disabled');
                annotation.parentElement.classList.add('e-overlay');
            }
            else {
                annotation.classList.remove('e-disabled');
                annotation.parentElement.classList.remove('e-overlay');
            }
            getComponent(annotation, 'dropdown-btn').disabled = isDisabled;
        }
        const transform = document.querySelector('#' + parent.element.id + '_transformBtn');
        if (transform) {
            if (isDisabled) {
                transform.classList.add('e-disabled');
                transform.parentElement.classList.add('e-overlay');
            }
            else {
                transform.classList.remove('e-disabled');
                transform.parentElement.classList.remove('e-overlay');
            }
            getComponent(transform, 'dropdown-btn').disabled = isDisabled;
        }
        const adjustment = document.querySelector('#' + parent.element.id + '_adjustment');
        if (adjustment) {
            if (isDisabled) {
                adjustment.classList.add('e-disabled');
                adjustment.parentElement.classList.add('e-overlay');
            }
            else {
                adjustment.classList.remove('e-disabled');
                adjustment.parentElement.classList.remove('e-overlay');
            }
            getComponent(adjustment, 'btn').disabled = isDisabled;
        }
        const filter = document.querySelector('#' + parent.element.id + '_filter');
        if (filter) {
            if (isDisabled) {
                filter.classList.add('e-disabled');
                filter.parentElement.classList.add('e-overlay');
            }
            else {
                filter.classList.remove('e-disabled');
                filter.parentElement.classList.remove('e-overlay');
            }
            getComponent(filter, 'btn').disabled = isDisabled;
        }
    }
    cropSelect(args) {
        const parent = this.parent;
        parent.isCropTab = true;
        if (isNullOrUndefined(parent.transform.cropZoomFactor)) {
            parent.transform.cropZoomFactor = parent.transform.zoomFactor;
            parent.notify('draw', { prop: 'setTempZoomFactor', onPropertyChange: false, value: { tempZoomFactor: parent.transform.zoomFactor } });
        }
        parent.transform.zoomFactor = parent.transform.cropZoomFactor;
        const text = args.item.id;
        this.currentToolbar = 'crop';
        parent.currSelectionPoint = null;
        parent.select(text);
        this.enableDisableTbrBtn();
        parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
    }
    quickAccessToolbarClicked(args, isContextualToolbar) {
        const parent = this.parent;
        const points = { x: parent.activeObj.activePoint.startX, y: parent.activeObj.activePoint.startY };
        if (args.item) {
            let duplicateObj;
            let objColl;
            let isPreventUndoRedo = null;
            const obj = { prevActObj: null };
            const object = { tempObj: null };
            parent.notify('draw', { prop: 'getPrevActObj', onPropertyChange: false, value: { obj: obj } });
            parent.notify('selection', { prop: 'getTempActObj', onPropertyChange: false, value: { obj: object } });
            object['tempObj']['activePoint']['height'] = Math.abs(object['tempObj']['activePoint']['height']);
            const pathObject = { isNewPath: null };
            parent.notify('draw', { prop: 'getNewPath', value: { obj: pathObject } });
            switch (args.item.id.replace(parent.element.id + '_', '').toLowerCase()) {
                case 'duplicate':
                    if (!parent.element.querySelector('#' + parent.element.id + '_duplicate').classList.contains('e-disabled')) {
                        if (!pathObject['isNewPath'] && JSON.stringify(object['tempObj']) === JSON.stringify(parent.activeObj)) {
                            isPreventUndoRedo = true;
                        }
                        duplicateObj = extend({}, parent.activeObj, {}, true);
                        if (isNullOrUndefined(parent.activeObj.currIndex)) {
                            parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: isPreventUndoRedo } });
                        }
                        else if (obj['prevActObj']) {
                            parent.activeObj.currIndex = null;
                            duplicateObj.currIndex = null;
                            parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: isPreventUndoRedo } });
                        }
                        else {
                            parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: true } });
                        }
                        if (pathObject['isNewPath']) {
                            parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
                        }
                        objColl = extend([], parent.objColl, [], true);
                        duplicateObj.activePoint.startX += 10;
                        duplicateObj.activePoint.startY -= 10;
                        duplicateObj.activePoint.endX += 10;
                        duplicateObj.activePoint.endY -= 10;
                        if (duplicateObj.shape === 'path') {
                            for (let i = 0; i < duplicateObj.pointColl.length; i++) {
                                duplicateObj.pointColl[i].x += 10;
                                duplicateObj.pointColl[i].y -= 10;
                            }
                        }
                        parent.activeObj = duplicateObj;
                        if (parent.activeObj.shape === 'line' || parent.activeObj.shape === 'arrow') {
                            parent.notify('shape', { prop: 'setPointCollForLineArrow', onPropertyChange: false,
                                value: { obj: parent.activeObj } });
                        }
                        // parent.updateTrianglePoints(parent.activeObj); Invoke
                        parent.notify('draw', { prop: 'drawObject', onPropertyChange: false, value: { canvas: 'duplicate', obj: parent.activeObj } });
                        parent.notify('undo-redo', { prop: 'updateUrObj', onPropertyChange: false, value: { objColl: objColl } });
                        this.renderQAT();
                    }
                    break;
                case 'remove':
                    if (!parent.element.querySelector('#' + parent.element.id + '_remove').classList.contains('e-disabled')) {
                        parent.notify('selection', { prop: 'deleteItem', onPropertyChange: false });
                    }
                    break;
                case 'edittext':
                    if (!parent.element.querySelector('#' + parent.element.id + '_editText').classList.contains('e-disabled')) {
                        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                        parent.notify('selection', { prop: 'setTempActObj', onPropertyChange: false,
                            value: { obj: extend({}, parent.activeObj, {}, true) } });
                        parent.notify('selection', { prop: 'setInitialTextEdit', onPropertyChange: false,
                            value: { bool: true } });
                        parent.notify('draw', { prop: 'setPrevActObj', onPropertyChange: false,
                            value: { prevActObj: extend({}, parent.activeObj, {}, true) } });
                        if (parent.activeObj.rotatedAngle !== 0) {
                            points.x = parent.activeObj.horTopLinePointColl[0].x;
                            points.y = parent.activeObj.horTopLinePointColl[0].y;
                        }
                        parent.notify('shape', { prop: 'renderTextArea', onPropertyChange: false,
                            value: { x: points.x, y: points.y, actObj: parent.activeObj } });
                        if (isNullOrUndefined(parent.activeObj.currIndex)) {
                            parent.notify('draw', { prop: 'setShapeTextInsert', onPropertyChange: false, value: { bool: true } });
                        }
                        else if (obj['prevActObj']) {
                            parent.notify('draw', { prop: 'setShapeTextInsert', onPropertyChange: false, value: { bool: true } });
                        }
                        if (document.getElementById(parent.element.id + '_quickAccessToolbarArea')) {
                            document.getElementById(parent.element.id + '_quickAccessToolbarArea').style.display = 'none';
                        }
                    }
                    break;
            }
        }
        if (isNullOrUndefined(isContextualToolbar)) {
            parent.trigger('quickAccessToolbarItemClick', args);
        }
    }
    defToolbarClicked(args) {
        const parent = this.parent;
        let isContextualToolbar = false;
        let isFilterFinetune = false;
        if (parent.element.querySelector('.e-contextual-toolbar-wrapper')) {
            if (!parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.contains('e-hide')) {
                isContextualToolbar = isFilterFinetune = true;
            }
            parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
        }
        if (args.item) {
            const type = args.item.id.replace(parent.element.id + '_', '').toLowerCase();
            if (type === 'duplicate' || type === 'remove' || type === 'edittext') {
                this.quickAccessToolbarClicked(args, true);
                parent.trigger('toolbarItemClicked', args);
            }
            else {
                let isDisabledFilter = false;
                let isDisabledAdjustment = false;
                const adjustment = document.querySelector('#' + parent.element.id + '_adjustment');
                if (adjustment && adjustment.classList.contains('e-disabled')) {
                    isDisabledAdjustment = true;
                }
                const filter = document.querySelector('#' + parent.element.id + '_filter');
                if (filter && filter.classList.contains('e-disabled')) {
                    isDisabledFilter = true;
                }
                this.enableDisableTbrBtn();
                this.performDefTbrClick(type, isContextualToolbar, isDisabledAdjustment, isDisabledFilter, isFilterFinetune);
                parent.trigger('toolbarItemClicked', args);
            }
        }
    }
    performDefTbrClick(type, isContextualToolbar, isDisabledAdjustment, isDisabledFilter, isFilterFinetune) {
        const parent = this.parent;
        const zoomIn = parent.element.querySelector('#' + parent.element.id + '_zoomIn');
        let isCropSelection = false;
        let panBtn;
        let splitWords;
        if (parent.activeObj.shape !== undefined) {
            splitWords = parent.activeObj.shape.split('-');
        }
        if (splitWords === undefined && parent.currObjType.isCustomCrop) {
            isCropSelection = true;
        }
        else if (splitWords !== undefined && splitWords[0] === 'crop') {
            isCropSelection = true;
        }
        if (!parent.disabled) {
            switch (type) {
                case 'pan':
                    parent.currObjType.isCustomCrop = parent.currObjType.isFiltered = false;
                    if (parent.currObjType.isUndoAction) {
                        parent.notify('undo-redo', { prop: 'refreshUrc', value: { bool: null } });
                    }
                    if (isCropSelection) {
                        parent.currObjType.isCustomCrop = false;
                        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
                        this.upperContext.clearRect(0, 0, parent.upperCanvas.width, parent.upperCanvas.height);
                        this.refreshToolbar('main');
                    }
                    if (parent.togglePan) {
                        this.cancelPan();
                        parent.notify('transform', { prop: 'setDisablePan', onPropertyChange: false, value: { bool: true } });
                        if (this.currentToolbar === 'pen') {
                            parent.freehandDraw(true);
                        }
                    }
                    else {
                        panBtn = parent.element.querySelector('.e-img-pan .e-btn');
                        if (panBtn) {
                            panBtn.classList.add('e-selected-btn');
                        }
                        parent.pan(true);
                        parent.notify('transform', { prop: 'setDisablePan', onPropertyChange: false, value: { bool: false } });
                    }
                    if (zoomIn && parent.zoomSettings.zoomFactor >= parent.zoomSettings.maxZoomFactor) {
                        zoomIn.classList.add('e-disabled');
                        zoomIn.parentElement.classList.add('e-overlay');
                    }
                    else if (zoomIn) {
                        zoomIn.classList.remove('e-disabled');
                        zoomIn.parentElement.classList.remove('e-overlay');
                    }
                    this.refreshToolbar('main');
                    break;
                case 'cancel':
                    parent.notify('draw', { prop: 'performCancel', value: { isContextualToolbar: isContextualToolbar } });
                    break;
                case 'ok':
                    parent.okBtn();
                    this.refreshDropDownBtn(false);
                    this.currentToolbar = 'main';
                    break;
                case 'crop':
                    parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
                    break;
                case 'reset':
                    parent.reset();
                    this.currentToolbar = 'main';
                    break;
                case 'undo':
                    parent.notify('undo-redo', { prop: 'call-undo' });
                    break;
                case 'redo':
                    parent.notify('undo-redo', { prop: 'call-redo' });
                    break;
                case 'adjustment':
                    if (!isDisabledAdjustment) {
                        if (parent.currObjType.isFiltered) {
                            parent.okBtn();
                        }
                        this.refreshToolbar('adjustment');
                        parent.setTempFilterProperties();
                        this.openSlider('brightness');
                    }
                    break;
                case 'brightness':
                case 'contrast':
                case 'hue':
                case 'saturation':
                case 'opacity':
                case 'blur':
                case 'exposure':
                    this.openSlider(type);
                    break;
                case 'filter':
                    if (!isDisabledFilter) {
                        showSpinner(parent.element);
                        this.refreshToolbar('filter');
                        parent.setTempFilterProperties();
                        hideSpinner(parent.element);
                    }
                    break;
                case 'default':
                case 'chrome':
                case 'cold':
                case 'warm':
                case 'grayscale':
                case 'blackandwhite':
                case 'sepia':
                case 'invert':
                case 'sharpen':
                    parent.currObjType.isFiltered = true;
                    parent.notify('filter', { prop: 'applyImageFilter', value: { option: type } });
                    break;
                case 'upload':
                    if (isFilterFinetune) {
                        parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.remove('e-hide');
                    }
                    break;
                case 'bold':
                    parent.notify('selection', { prop: 'setInitialTextEdit', value: { bool: false } });
                    if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'italic' } });
                    }
                    else if (parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'default' } });
                    }
                    else if (!parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'bolditalic' } });
                    }
                    else if (!parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'bold' } });
                    }
                    if (parent.element.querySelector('#' + parent.element.id + '_bold').classList.contains('e-selected-btn')) {
                        parent.element.querySelector('#' + parent.element.id + '_bold').classList.remove('e-selected-btn');
                    }
                    else {
                        parent.element.querySelector('#' + parent.element.id + '_bold').classList.add('e-selected-btn');
                    }
                    break;
                case 'italic':
                    parent.notify('selection', { prop: 'setInitialTextEdit', value: { bool: false } });
                    if (parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'bold' } });
                    }
                    else if (parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'bolditalic' } });
                    }
                    else if (!parent.activeObj.textSettings.bold && parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'default' } });
                    }
                    else if (!parent.activeObj.textSettings.bold && !parent.activeObj.textSettings.italic) {
                        parent.notify('shape', { prop: 'applyFontStyle', onPropertyChange: false,
                            value: { item: 'italic' } });
                    }
                    if (parent.element.querySelector('#' + parent.element.id + '_italic').classList.contains('e-selected-btn')) {
                        parent.element.querySelector('#' + parent.element.id + '_italic').classList.remove('e-selected-btn');
                    }
                    else {
                        parent.element.querySelector('#' + parent.element.id + '_italic').classList.add('e-selected-btn');
                    }
                    break;
                case 'croptransform':
                    this.refreshToolbar('croptransform');
                    break;
                case 'rotateleft':
                case 'rotateright':
                case 'horizontalflip':
                case 'verticalflip':
                    parent.transformSelect(type);
                    parent.notify('transform', { prop: 'disableZoomOutBtn', value: { isZoomOut: true } });
                    break;
                case 'save':
                    if (parent.element.querySelector('#' + parent.element.id + '_saveBtn').classList.contains('e-hide')) {
                        parent.element.querySelector('#' + parent.element.id + '_saveBtn').classList.remove('e-hide');
                        break;
                    }
                    else {
                        parent.okBtn();
                    }
                    parent.element.querySelector('#' + parent.element.id + '_saveBtn').classList.add('e-hide');
                    parent.element.querySelector('#' + parent.element.id + '_saveBtn').click();
                    break;
            }
        }
    }
    contextualToolbarClicked(args) {
        const parent = this.parent;
        const selEle = parent.element.querySelector('.e-contextual-toolbar-wrapper .e-toolbar-item.e-selected');
        if (selEle) {
            selEle.classList.remove('e-selected');
        }
        const type = args.item.id.replace(parent.element.id, '').split('_')[1];
        const imageFiltering = { filter: parent.toPascalCase(type), cancel: false };
        parent.trigger('imageFiltering', imageFiltering);
        if (imageFiltering.cancel) {
            return;
        }
        document.getElementById(args.item.id + 'Canvas').parentElement.parentElement.classList.add('e-selected');
        parent.currObjType.isFiltered = true;
        parent.notify('filter', { prop: 'applyImageFilter', value: { option: type.toLowerCase() } });
        parent.currentFilter = args.item.id;
        this.enableDisableTbrBtn();
    }
    refreshShapeDrawing() {
        const parent = this.parent;
        const object = { shape: '' };
        parent.notify('selection', { prop: 'getCurrentDrawingShape', onPropertyChange: false, value: { obj: object } });
        if (object['shape'] !== '') {
            parent.notify('selection', { prop: 'setCurrentDrawingShape', onPropertyChange: false, value: { value: '' } });
            parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
            this.refreshToolbar('main', false);
        }
    }
    zoomInBtnClickHandler(e) {
        const parent = this.parent;
        if ((parent.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar) {
            this.refreshShapeDrawing();
            if (Browser.isDevice && e.type === 'touchstart') {
                if (!e.returnValue) {
                    return;
                }
                e.preventDefault();
            }
            const zoomIn = document.querySelector('#' + parent.element.id + '_zoomIn');
            EventHandler.trigger(zoomIn, 'click');
            const obj = { bool: false };
            parent.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
            if (obj['bool']) {
                parent.notify('freehand-draw', { prop: 'applyFhd', onPropertyChange: false });
                this.destroyQuickAccessToolbar();
            }
            this.applyPreviewFilter();
            parent.currObjType.isFiltered = false;
            if (parent.togglePen) {
                parent.currObjType.isZoomed = true;
                parent.freeHandDraw(false);
                parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            }
            parent.notify('draw', { prop: 'resetCurrentSelectionPoint' });
            parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                value: { zoomFactor: .1, zoomPoint: null } });
        }
    }
    zoomOutBtnClickHandler(e) {
        const parent = this.parent;
        if ((parent.zoomSettings.zoomTrigger & ZoomTrigger.Toolbar) === ZoomTrigger.Toolbar) {
            this.refreshShapeDrawing();
            if (Browser.isDevice && e.type === 'touchstart') {
                if (!e.returnValue) {
                    return;
                }
                e.preventDefault();
            }
            const zoomOut = document.querySelector('#' + parent.element.id + '_zoomOut');
            EventHandler.trigger(zoomOut, 'click');
            const obj = { bool: false };
            parent.notify('selection', { prop: 'getFreehandDrawEditing', onPropertyChange: false, value: { obj: obj } });
            if (obj['bool']) {
                parent.notify('freehand-draw', { prop: 'applyFhd', onPropertyChange: false });
                this.destroyQuickAccessToolbar();
            }
            this.applyPreviewFilter();
            parent.currObjType.isFiltered = false;
            if (parent.togglePen) {
                parent.currObjType.isZoomed = true;
                parent.freeHandDraw(false);
                parent.notify('undo-redo', { prop: 'updateCurrUrc', value: { type: 'ok' } });
            }
            parent.notify('draw', { prop: 'resetCurrentSelectionPoint' });
            parent.notify('transform', { prop: 'zoomAction', onPropertyChange: false,
                value: { zoomFactor: -.1, zoomPoint: null } });
        }
    }
    zoomInBtnMouseDownHandler(e) {
        e.preventDefault();
        this.zoomBtnHold = setInterval(this.zoomInBtnClickHandler.bind(this), 250);
    }
    zoomOutBtnMouseDownHandler(e) {
        e.preventDefault();
        this.zoomBtnHold = setInterval(this.zoomOutBtnClickHandler.bind(this), 250);
    }
    zoomBtnMouseUpHandler() {
        clearInterval(this.zoomBtnHold);
        this.zoomBtnHold = 0;
    }
    closeContextualToolbar() {
        const parent = this.parent;
        let isContextualToolbar = false;
        if ((parent.element.querySelector('#' + parent.element.id + '_contextualToolbar') &&
            !parent.element.querySelector('#' + parent.element.id + '_contextualToolbar').parentElement.classList.contains('e-hide')) ||
            (parent.element.querySelector('#' + parent.element.id + '_headWrapper')
                && !parent.element.querySelector('#' + parent.element.id + '_headWrapper').parentElement.classList.contains('e-hide'))) {
            parent.element.querySelector('.e-contextual-toolbar-wrapper').classList.add('e-hide');
            parent.okBtn();
            this.refreshMainToolbar();
            isContextualToolbar = true;
        }
        return isContextualToolbar;
    }
    destroyQuickAccessToolbar() {
        const parent = this.parent;
        const quickToolbar = document.getElementById(parent.element.id + '_quickAccessToolbar');
        if (quickToolbar && quickToolbar.classList.contains('e-control')) {
            getComponent(quickToolbar, 'toolbar').destroy();
        }
        const qatArea = document.getElementById(parent.element.id + '_quickAccessToolbarArea');
        if (qatArea) {
            qatArea.style.display = 'none';
        }
    }
    renderSlider(type) {
        const parent = this.parent;
        const canvasWrapper = document.querySelector('#' + parent.element.id + '_contextualToolbarArea');
        let hdrWrapper = document.querySelector('#' + parent.element.id + '_headWrapper');
        let labelWrapper = document.querySelector('#' + parent.element.id + '_labelWrapper');
        if (!hdrWrapper) {
            hdrWrapper = canvasWrapper.appendChild(parent.createElement('div', {
                id: parent.element.id + '_headWrapper',
                styles: 'position: relative'
            }));
            labelWrapper = hdrWrapper.appendChild(parent.createElement('label', {
                id: parent.element.id + '_labelWrapper',
                styles: Browser.isDevice ? 'position: absolute; top: 25%; left: calc(50% - 150px); font-size: 15px; text-transform: capitalize; font-weight: 400;'
                    : 'position: absolute; top: 25%; left: calc(50% - 226px); font-size: 15px; text-transform: capitalize; font-weight: 400;'
            }));
        }
        else {
            hdrWrapper.style.display = 'block';
        }
        labelWrapper.textContent = this.l10n.getConstant(parent.toPascalCase(type));
        const sliderWrapper = hdrWrapper.appendChild(parent.createElement('div', {
            id: parent.element.id + '_sliderWrapper',
            styles: 'position: absolute'
        }));
        const value = parent.getCurrAdjustmentValue(type);
        let min;
        let max;
        let slider;
        if (type === 'brightness' || type === 'contrast' || type === 'saturation' || type === 'exposure') {
            if (parent.finetuneSettings) {
                if (type === 'brightness' && parent.finetuneSettings.brightness) {
                    min = parent.finetuneSettings.brightness.min;
                    max = parent.finetuneSettings.brightness.max;
                }
                else if (type === 'contrast' && parent.finetuneSettings.contrast) {
                    min = parent.finetuneSettings.contrast.min;
                    max = parent.finetuneSettings.contrast.max;
                }
                else if (type === 'saturation' && parent.finetuneSettings.saturation) {
                    min = parent.finetuneSettings.saturation.min;
                    max = parent.finetuneSettings.saturation.max;
                }
                else if (type === 'exposure' && parent.finetuneSettings.exposure) {
                    min = parent.finetuneSettings.exposure.min;
                    max = parent.finetuneSettings.exposure.max;
                }
                else {
                    min = -100;
                    max = 100;
                }
            }
            else {
                min = -100;
                max = 100;
            }
            slider = this.createSlider(min, max, value, type);
        }
        else if (type === 'hue' || type === 'blur' || type === 'opacity') {
            if (parent.finetuneSettings) {
                if (type === 'hue' && parent.finetuneSettings.hue) {
                    min = parent.finetuneSettings.hue.min;
                    max = parent.finetuneSettings.hue.max;
                }
                else if (type === 'blur' && parent.finetuneSettings.blur) {
                    min = parent.finetuneSettings.blur.min;
                    max = parent.finetuneSettings.blur.max;
                }
                else if (type === 'opacity' && parent.finetuneSettings.opacity) {
                    min = parent.finetuneSettings.opacity.min;
                    max = parent.finetuneSettings.opacity.max;
                }
                else {
                    min = 0;
                    max = 100;
                }
            }
            else {
                min = 0;
                max = 100;
            }
            slider = this.createSlider(min, max, value, type);
        }
        slider.appendTo('#' + parent.element.id + '_sliderWrapper');
        sliderWrapper.style.left = (parseFloat(canvasWrapper.style.width) - parseFloat(slider.width)) / 2 + 'px';
    }
    createSlider(min, max, value, type) {
        const parent = this.parent;
        return new Slider({
            value: value,
            tooltip: { isVisible: true, placement: 'Before', showOn: 'Always' },
            type: 'MinRange',
            min: min,
            max: max,
            step: 10,
            width: Browser.isDevice ? '200px' : '300px',
            cssClass: 'e-slider',
            change: (args) => {
                parent.setCurrAdjustmentValue(type, args.value);
                this.enableDisableTbrBtn();
            }
        });
    }
    applyPreviewFilter() {
        const parent = this.parent;
        if (document.querySelector('#' + parent.element.id + '_sliderWrapper') ||
            parent.currObjType.isFiltered) {
            parent.initialAdjustmentValue = this.lowerContext.filter;
            parent.canvasFilter = this.lowerContext.filter;
            parent.currObjType.isFiltered = false;
        }
    }
    unselectBtn() {
        const parent = this.parent;
        const selectors = [
            '#' + parent.element.id + '_brightness',
            '#' + parent.element.id + '_contrast',
            '#' + parent.element.id + '_hue',
            '#' + parent.element.id + '_saturation',
            '#' + parent.element.id + '_opacity',
            '#' + parent.element.id + '_blur',
            '#' + parent.element.id + '_exposure'
        ];
        for (const selector of selectors) {
            const element = document.querySelector(selector);
            if (element.classList.contains('e-selected-btn')) {
                element.classList.remove('e-selected-btn');
                break;
            }
        }
    }
    openSlider(type) {
        this.unselectBtn();
        this.parent.currObjType.isFiltered = true;
        this.refreshToolbar('color', null, null, null, type);
        document.getElementById(this.parent.element.id + '_' + type).classList.add('e-selected-btn');
    }
    refreshSlider() {
        const sliderWrapper = document.querySelector('#' + this.parent.element.id + '_sliderWrapper');
        // eslint-disable-next-line
        const slider = document.querySelector('.e-slider');
        const hdrWrapper = document.querySelector('#' + this.parent.element.id + '_headWrapper');
        if (hdrWrapper) {
            hdrWrapper.style.display = 'none';
        }
        if (sliderWrapper && slider) {
            slider.ej2_instances[0].destroy();
            sliderWrapper.remove();
        }
    }
    updateToolbarItems() {
        const parent = this.parent;
        if (!parent.isImageLoaded) {
            return;
        }
        const selFillElem = parent.element.querySelector('.e-fill.e-template .e-dropdownbtn-preview');
        const selStrokeElem = parent.element.querySelector('.e-stroke.e-template .e-dropdownbtn-preview');
        const selTextStrokeElem = parent.element.querySelector('.e-text-font-color.e-template .e-dropdownbtn-preview');
        const selPenStrokeElem = parent.element.querySelector('.e-pen-stroke-color.e-template .e-dropdownbtn-preview');
        const strokeWidthElem = parent.element.querySelector('.e-shape-stroke-width');
        const fontFamilyElem = parent.element.querySelector('.e-text-font-family');
        const fontSizeElem = parent.element.querySelector('.e-text-font-size');
        const boldBtn = parent.element.querySelector('#' + parent.element.id + '_bold');
        const italicBtn = parent.element.querySelector('#' + parent.element.id + '_italic');
        if (isNullOrUndefined(parent.activeObj.strokeSettings.strokeWidth)) {
            parent.activeObj.strokeSettings.strokeWidth = 2;
        }
        if (selFillElem) {
            if (parent.activeObj.strokeSettings.fillColor === '') {
                selFillElem.classList.add('e-nocolor-item');
            }
            else {
                selFillElem.classList.remove('e-nocolor-item');
                selFillElem.style.background = parent.activeObj.strokeSettings.fillColor;
            }
            getComponent(parent.element.id + '_shape_fill', 'colorpicker').value
                = parent.activeObj.strokeSettings.fillColor + 'ff';
        }
        if (selStrokeElem) {
            selStrokeElem.style.background = parent.activeObj.strokeSettings.strokeColor;
            getComponent(parent.element.id + '_shape_stroke', 'colorpicker').value
                = parent.activeObj.strokeSettings.strokeColor + 'ff';
        }
        if (selTextStrokeElem) {
            selTextStrokeElem.style.background = parent.activeObj.strokeSettings.strokeColor;
            getComponent(parent.element.id + '_text_font', 'colorpicker').value
                = parent.activeObj.strokeSettings.strokeColor + 'ff';
        }
        if (selPenStrokeElem) {
            selPenStrokeElem.style.background = parent.activeObj.strokeSettings.strokeColor;
            getComponent(parent.element.id + '_pen_stroke', 'colorpicker').value
                = parent.activeObj.strokeSettings.strokeColor + 'ff';
        }
        if (fontFamilyElem) {
            if (Browser.isDevice) {
                fontFamilyElem.setAttribute('style', 'font-family:' + parent.activeObj.textSettings.fontFamily.toLowerCase());
            }
            else {
                fontFamilyElem.textContent = parent.activeObj.textSettings.fontFamily;
            }
        }
        if (fontSizeElem) {
            for (let i = 0; i < parent.fontSizeColl.length; i++) {
                if (parseInt(parent.fontSizeColl[i].text, 10) >= Math.round(parent.activeObj.textSettings.fontSize)) {
                    fontSizeElem.textContent = (i + 1).toString();
                    break;
                }
            }
        }
        if (boldBtn) {
            if (parent.activeObj.textSettings.bold) {
                boldBtn.classList.add('e-selected-btn');
            }
            else {
                boldBtn.classList.remove('e-selected-btn');
            }
        }
        if (italicBtn) {
            if (parent.activeObj.textSettings.italic) {
                italicBtn.classList.add('e-selected-btn');
            }
            else {
                italicBtn.classList.remove('e-selected-btn');
            }
        }
        if (strokeWidthElem) {
            const strokeWidth = Math.round((parent.activeObj.strokeSettings.strokeWidth)).toString();
            strokeWidthElem.textContent = this.getStrokeWidth(strokeWidth);
        }
    }
    getStrokeWidth(text) {
        let strokeWidth;
        const currentWidth = parseInt(text, 10) / 2;
        switch (currentWidth) {
            case 1:
                strokeWidth = this.l10n.getConstant('XSmall');
                break;
            case 2:
                strokeWidth = this.l10n.getConstant('Small');
                break;
            case 3:
                strokeWidth = this.l10n.getConstant('Medium');
                break;
            case 4:
                strokeWidth = this.l10n.getConstant('Large');
                break;
            case 5:
                strokeWidth = this.l10n.getConstant('XLarge');
                break;
        }
        return strokeWidth;
    }
    cancelPan() {
        const parent = this.parent;
        parent.notify('shape', { prop: 'applyActObj', onPropertyChange: false, value: { isMouseDown: true } });
        const panBtn = parent.element.querySelector('.e-img-pan .e-btn');
        if (panBtn) {
            panBtn.classList.remove('e-selected-btn');
        }
        parent.pan(false);
    }
    refreshMainToolbar() {
        if (this.currToolbar !== 'main') {
            this.refreshToolbar('main');
        }
    }
    destroySubComponents() {
        const parent = this.parent;
        const inputElement = parent.element.querySelectorAll('input.e-control');
        const btnElement = parent.element.querySelectorAll('button.e-control');
        for (let i = 0, len = inputElement.length; i < len; i++) {
            if (inputElement[i].classList.contains('e-color-picker')) {
                getComponent(inputElement[i], 'color-picker').destroy();
                detach(select('input#' + inputElement[i].id, parent.element));
            }
        }
        for (let i = 0, len = btnElement.length; i < len; i++) {
            if (btnElement[i].classList.contains('e-dropdown-btn')) {
                getComponent(btnElement[i], 'dropdown-btn').destroy();
                detach(select('button#' + btnElement[i].id, parent.element));
            }
            else if (btnElement[i].classList.contains('e-btn')) {
                getComponent(btnElement[i], 'btn').destroy();
                detach(select('button#' + btnElement[i].id, parent.element));
            }
        }
    }
    setInitialShapeSettings(args) {
        const parent = this.parent;
        parent.notify('shape', { prop: 'refreshActiveObj', onPropertyChange: false });
        parent.currObjType.shape = args.item.id;
        parent.activeObj.shape = parent.currObjType.shape.toLowerCase();
        parent.currObjType.isDragging = parent.currObjType.isCustomCrop = false;
        parent.activeObj.shapeDegree = parent.transform.degree;
        parent.activeObj.shapeFlip = parent.transform.currFlipState;
        parent.activeObj.textFlip = parent.transform.currFlipState;
        parent.activeObj.flipObjColl = [];
    }
    getModuleName() {
        return 'toolbar-module';
    }
}

/**
 * ImageEditor all modules
 */

export { Crop, Draw, Export, Filter, FreehandDrawing, Selection, Shape, Transform, UndoRedo, FinetuneSettings, ZoomSettings, SelectionSettings, ImageEditor, FileType, Direction, ShapeType, ZoomTrigger, Theme, ImageEditorCommand, ImageFilterOption, ImageFinetuneOption, ArrowheadType, ToolbarModule };
//# sourceMappingURL=ej2-image-editor.es2015.js.map
